<template>
  <div
    class="gantt-bars"
    :style="{ '--bars-min-height': Math.max(tasks.length * 28, 200) + 'px' }"
    @dblclick="handleGlobalDblClick"
    @click="handleComponentClick"
  >
    <!-- È´ò‰∫ÆË°åËÉåÊôØ -->
    <div v-if="highlightedRowId !== null"
      class="highlighted-row-background"
      :style="{
        top: getHighlightedRowTop() + 'px',
        width: chartWidth + 'px',
        height: '28px'
      }"
    ></div>

    <!-- ‰ªªÂä°Êù° -->
    <div
      v-for="bar in taskBars"
      :key="bar.task.id"
      class="gantt-bar-container"
      :data-task-id="bar.task.id"
      :style="{
        top: bar.index * 28 + 'px',
        left: bar.left + 'px',
        width: bar.width + 'px'
      }"
      @dblclick.stop="onBarDblClick(bar, $event)"
    >
      <!-- ËÆ°ÂàíÊó•ÊúüËåÉÂõ¥ËÉåÊôØÔºàÂ¶ÇÊûúÊúâËÆ°ÂàíÊó•Êúü‰∏îÂêØÁî®Ôºâ -->
      <div
        v-if="showPlanNodes && bar.planLeft !== undefined && bar.planWidth !== undefined"
        class="plan-date-range"
        :style="{
          left: (bar.planLeft - bar.left) + 'px',
          width: bar.planWidth + 'px'
        }"
      ></div>

      <!-- Milestone Á±ªÂûãÁâπÊÆäÊòæÁ§∫ -->
      <div
        v-if="bar.task.type === 'milestone'"
        class="gantt-milestone-marker"
        :class="{
          'dragging': bar.isDragging,
          'selected': selectedTask && selectedTask.id === bar.task.id,
          'highlighted': highlightedRowId === bar.task.id,
          'lineage-highlighted': isTaskHighlighted(bar.task.id),
          'lineage-dimmed': isTaskDimmed(bar.task.id),
          'lineage-source': getTaskHighlightType(bar.task.id) === 'source',
          'lineage-upstream': getTaskHighlightType(bar.task.id) === 'upstream',
          'lineage-downstream': getTaskHighlightType(bar.task.id) === 'downstream'
        }"
        @mousedown="onBarMouseDown(bar, $event)"
        @click.stop="selectTask(bar.task)"
        @dblclick.stop="onBarDblClick(bar, $event)"
        @contextmenu.prevent="enableContextMenu && showTaskContextMenu(bar.task, $event)"
        @mouseenter="showTooltip(bar.task, $event)"
        @mouseleave="hideTooltip"
        @mousemove="updateTooltipPosition($event)"
      >
        <!-- Milestone ÂõæÊ†á -->
        <div class="milestone-diamond">
          <span
            class="milestone-icon"
            :class="getTaskTypeConfig(bar.task.type)?.iconClass"
            :style="{
              fontSize: getTaskTypeConfig(bar.task.type)?.iconSize || '16px',
              color: getTaskTypeConfig(bar.task.type)?.iconColor || '#f39c12'
            }"
          >
            <!-- Â¶ÇÊûúÊúâiconClassÈÖçÁΩÆÔºåÂàô‰∏çÊòæÁ§∫emojiÂõæÊ†á -->
            <template v-if="!getTaskTypeConfig(bar.task.type)?.iconClass">
              {{ getTaskTypeConfig(bar.task.type)?.icon || 'üèÅ' }}
            </template>
          </span>
        </div>

        <!-- Milestone Ê†áÈ¢ò -->
        <div class="milestone-title" v-if="showTaskName">
          {{ bar.task.name }}
        </div>

        <!-- MilestoneËøûÊé•ÁÇπ -->
        <div v-if="showConnections && milestoneLinkable" class="milestone-connection-points">
          <!-- Â∑¶‰æßËøûÊé•ÁÇπ - ÂºÄÂßãÁÇπ -->
          <div
            class="milestone-connection-point milestone-connection-left milestone-connection-start"
            :class="{
              'active': connectionState,
              'connecting': connectionState && connectionState.fromBar.task.id === bar.task.id && connectionState.fromPoint === 'start'
            }"
            @mousedown.stop="startConnection(bar, 'start', $event)"
            @mouseenter="handleConnectionHover(bar, 'start')"
            @mouseleave="handleConnectionLeave"
            title="Connect from milestone start (for SS/SF dependencies)"
          >
            <div class="connection-dot connection-dot-start"></div>
          </div>

          <!-- Âè≥‰æßËøûÊé•ÁÇπ - ÁªìÊùüÁÇπ -->
          <div
            class="milestone-connection-point milestone-connection-right milestone-connection-end"
            :class="{
              'active': connectionState,
              'connecting': connectionState && connectionState.fromBar.task.id === bar.task.id && connectionState.fromPoint === 'end'
            }"
            @mousedown.stop="startConnection(bar, 'end', $event)"
            @mouseenter="handleConnectionHover(bar, 'end')"
            @mouseleave="handleConnectionLeave"
            title="Connect from milestone end (for FS/FF dependencies)"
          >
            <div class="connection-dot connection-dot-end"></div>
          </div>
        </div>
      </div>

      <!-- ÊôÆÈÄö‰ªªÂä°Êù° -->
      <div
        v-else
        class="gantt-bar"
        :class="{
          'dragging': bar.isDragging,
          'connecting': connectionState && connectionState.fromBar.task.id === bar.task.id,
          'selected': selectedTask && selectedTask.id === bar.task.id,
          'parent-task': bar.task.isParentNode,
          'parent-dragging': bar.task.isParentNode && bar.isDragging,
          'highlighted': highlightedRowId === bar.task.id,
          'lineage-highlighted': isTaskHighlighted(bar.task.id),
          'lineage-dimmed': isTaskDimmed(bar.task.id),
          'lineage-source': getTaskHighlightType(bar.task.id) === 'source',
          'lineage-upstream': getTaskHighlightType(bar.task.id) === 'upstream',
          'lineage-downstream': getTaskHighlightType(bar.task.id) === 'downstream',
          'critical-path': bar.isCriticalPath
        }"
        :style="{ backgroundColor: bar.task.color }"
        @mousedown="onBarMouseDown(bar, $event)"
        @click.stop="selectTask(bar.task)"
        @dblclick.stop="onBarDblClick(bar, $event)"
        @contextmenu.prevent="enableContextMenu && showTaskContextMenu(bar.task, $event)"
        @mouseenter="showTooltip(bar.task, $event)"
        @mouseleave="hideTooltip"
        @mousemove="updateTooltipPosition($event)"
      >
        <!-- Áà∂Á∫ßËäÇÁÇπÊåáÁ§∫Âô® -->
        <div
          v-if="bar.task.isParentNode"
          class="parent-indicator"
          :data-collapsed="isTaskCollapsed(bar.task.id) ? 'true' : 'false'"
          @click.stop="toggleTaskCollapse(bar.task.id)"
        ></div>
        <!-- ËøõÂ∫¶Êù° -->
        <div
          class="gantt-bar-progress"
          :style="{
            width: Math.max(bar.task.progress, bar.task.progress === 0 ? 8 : 0) + (bar.task.progress === 0 ? 'px' : '%'),
            minWidth: bar.task.progress === 0 ? '8px' : 'auto'
          }"
        >
                    <!-- BryntumÈ£éÊ†ºÁöÑÂ∫ïÈÉ®‰∏âËßíÂΩ¢ËøõÂ∫¶ÊãñÊãΩÊâãÊüÑ -->
          <div v-if="!bar.task.isParentNode && showProgressHandle && bar.task.progress > 0"
            class="gantt-progress-handle-container"
            @mousedown.stop="startProgressDrag(bar, $event)"
            :title="`ÊãñÊãΩË∞ÉÊï¥ËøõÂ∫¶: ${bar.task.progress}%`"
          >
            <div class="gantt-progress-handle"></div>
          </div>
          <!-- ÁôæÂàÜÊØîÊòæÁ§∫ - Á¥ßË∑üÂú®ËøõÂ∫¶ÊâãÊüÑÂêéÈù¢ -->
          <div class="gantt-bar-progress-text"
               v-if="showProgress && bar.task.progress > 0">
            {{ bar.task.progress }}%
          </div>
        </div>

        <!-- ‰ªªÂä°ÊñáÊú¨ -->
        <div class="gantt-bar-text">
          <span class="task-name" v-if="showTaskName">
            <!-- ‰ªªÂä°Á±ªÂûãÂõæÊ†á - ÊîØÊåÅiconClassË¶ÜÁõñ -->
            <span
              v-if="bar.task.type"
              class="task-type-icon"
              :class="getTaskTypeConfig(bar.task.type)?.iconClass"
              :style="{
                fontSize: getTaskTypeConfig(bar.task.type)?.iconSize || '14px',
                color: getTaskTypeConfig(bar.task.type)?.iconColor || '#666'
              }"
              :title="getTaskTypeConfig(bar.task.type)?.name"
            >
              <!-- Â¶ÇÊûúÊúâiconClassÈÖçÁΩÆÔºåÂàô‰∏çÊòæÁ§∫emojiÂõæÊ†á -->
              <template v-if="!getTaskTypeConfig(bar.task.type)?.iconClass">
                {{ getTaskTypeConfig(bar.task.type)?.icon }}
              </template>
            </span>
            {{ bar.task.name }}
          </span>
        </div>

        <!-- Â∑¶‰æßË∞ÉÊï¥ÊâãÊüÑ - ÁßªÂà∞ËäÇÁÇπÂ§ñÈù¢ -->
        <div v-if="!bar.task.isParentNode"
          class="resize-handle left"
          @mousedown.stop.prevent="startResize(bar, 'left', $event)"
        ></div>

        <!-- Âè≥‰æßË∞ÉÊï¥ÊâãÊüÑ - ÁßªÂà∞ËäÇÁÇπÂ§ñÈù¢ -->
        <div v-if="!bar.task.isParentNode"
          class="resize-handle right"
          @mousedown.stop.prevent="startResize(bar, 'right', $event)"
        ></div>

        <!-- Âà†Èô§ÊåâÈíÆ - ÈúÄË¶ÅÊ£ÄÊü•Âà†Èô§ÊùÉÈôê -->
        <div v-if="!bar.task.isParentNode && hasPermission(bar.task, 'deletable')"
          class="task-delete-btn"
          @click.stop="deleteTaskDirectly(bar.task)"
          title="Delete Task"
        >
          √ó
        </div>
      </div>

      <!-- dhtmlxÈ£éÊ†ºÁöÑÂ§ñÈÉ®ËøûÊé•ÁÇπÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ -->
      <div v-if="showConnections && (allowParentConnection || !bar.task.isParentNode) && bar.task.type !== 'milestone'" class="gantt-connection-points">
        <!-- Â∑¶‰æßËøûÊé•ÁÇπ - ‰ªªÂä°ÂºÄÂßãÁÇπÔºåÂêëÂ∑¶Â§ñÂÅèÁßªÊõ¥ËøúÔºåÈÅøÂÖç‰∏éÊãñÊãΩÊâãÊüÑÈáçÂè† -->
        <div
          class="gantt-connection-point gantt-connection-point-left gantt-connection-start"
          :class="{
            'active': connectionState,
            'connecting': connectionState && connectionState.fromBar.task.id === bar.task.id && connectionState.fromPoint === 'start'
          }"
          @mousedown.stop="startConnection(bar, 'start', $event)"
          @mouseenter="handleConnectionHover(bar, 'start')"
          @mouseleave="handleConnectionLeave"
          style="left: -16px;"
          title="Connect from task start (for SS/SF dependencies)"
        >
          <div class="gantt-connection-dot gantt-connection-dot-start"></div>
        </div>

        <!-- Âè≥‰æßËøûÊé•ÁÇπ - ‰ªªÂä°ÁªìÊùüÁÇπÔºåÂêëÂè≥Â§ñÂÅèÁßªÊõ¥ËøúÔºåÈÅøÂÖç‰∏éÊãñÊãΩÊâãÊüÑÈáçÂè† -->
        <div
          class="gantt-connection-point gantt-connection-point-right gantt-connection-end"
          :class="{
            'active': connectionState,
            'connecting': connectionState && connectionState.fromBar.task.id === bar.task.id && connectionState.fromPoint === 'end'
          }"
          @mousedown.stop="startConnection(bar, 'end', $event)"
          @mouseenter="handleConnectionHover(bar, 'end')"
          @mouseleave="handleConnectionLeave"
          style="right: -16px;"
          title="Connect from task end (for FS/FF dependencies)"
        >
          <div class="gantt-connection-dot gantt-connection-dot-end"></div>
        </div>

        <!-- ‰ªªÂä°ÂêçÁß∞Ê†áÁ≠æ (JIRAÈ£éÊ†º) - ÊòæÁ§∫Âú®ÁîòÁâπÊù°Âè≥‰æß -->
        <div
          v-if="showTaskNames && !bar.task.isParentNode"
          class="gantt-task-name-label"
          :style="{
            left: (bar.width + 8) + 'px',
            top: '8px'
          }"
        >
          {{ bar.task.name.length > 25 ? bar.task.name.substring(0, 25) + '...' : bar.task.name }}
        </div>
      </div>

    </div>

    <!-- ‰æùËµñÁ∫øÂ±ÇÔºöÊô∫ËÉΩpointer-eventsÔºåÂè™ÊúâÁ∫øÊù°ÂèØÁÇπÂáªÔºåÂÖ∂‰ªñÂå∫ÂüüÁ©øÈÄè -->
    <svg v-if="internalShowDependencyLines" class="gantt-dependency-lines" :width="chartWidth" :height="chartHeight" style="position:absolute;top:0;left:0;z-index:3;pointer-events:none;">
      <!-- SVGÁÆ≠Â§¥Ê†áËÆ∞ÂÆö‰πâ -->
      <defs>
                <!-- Ê†áÂáÜÁÆ≠Â§¥Ê†áËÆ∞ - ‰øÆÂ§çÁÆ≠Â§¥‰∏éËøûÁ∫øÁöÑËøûÊé• -->
        <marker
          id="arrow-default"
          markerWidth="8"
          markerHeight="8"
          refX="8"
          refY="4"
          orient="auto"
          markerUnits="userSpaceOnUse"
        >
          <path
            d="M 0,0 L 8,4 L 0,8 L 2,4 Z"
            fill="#666"
            stroke="none"
          />
        </marker>

        <!-- ÈÄâ‰∏≠Áä∂ÊÄÅÁÆ≠Â§¥ -->
        <marker
          id="arrow-selected"
          markerWidth="8"
          markerHeight="8"
          refX="8"
          refY="4"
          orient="auto"
          markerUnits="userSpaceOnUse"
        >
          <path
            d="M 0,0 L 8,4 L 0,8 L 2,4 Z"
            fill="#ff4757"
            stroke="none"
          />
        </marker>

        <!-- È´ò‰∫ÆÁä∂ÊÄÅÁÆ≠Â§¥ -->
        <marker
          id="arrow-highlighted"
          markerWidth="8"
          markerHeight="8"
          refX="8"
          refY="4"
          orient="auto"
          markerUnits="userSpaceOnUse"
        >
          <path
            d="M 0,0 L 8,4 L 0,8 L 2,4 Z"
            fill="#1890ff"
            stroke="none"
          />
        </marker>

        <!-- Â¢ûÂº∫ÁöÑÁªàÁÇπÊåáÁ§∫Âô® -->
        <marker
          v-for="color in arrowColors"
          :key="`endPoint-${color.replace('#', '')}`"
          :id="`endPoint-${color.replace('#', '')}`"
          markerWidth="8"
          markerHeight="8"
          refX="4"
          refY="4"
          orient="auto"
          markerUnits="strokeWidth"
          viewBox="0 0 8 8"
        >
          <circle
            cx="4"
            cy="4"
            r="3"
            :fill="color"
            stroke="white"
            stroke-width="1"
          />
        </marker>

        <!-- Èò¥ÂΩ±Êª§ÈïúÂÆö‰πâ -->
        <filter id="connectionShadow" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="1" dy="1" stdDeviation="1" flood-opacity="0.2"/>
        </filter>
      </defs>
      <g v-for="line in visibleDependencyLines" :key="line.key" class="gantt-dependency-group"
         v-show="shouldShowDependencyLine(line)" :data-from="line.from" :data-to="line.to">
        <g class="gantt-link-container">
          <!-- Êâ©Â§ßÁöÑÈöêÂΩ¢ÁÇπÂáªÂå∫ÂüüÔºåÁ°Æ‰øùpointer-events:auto -->
          <path
            :d="line.path"
            stroke="transparent"
            stroke-width="16"
            fill="none"
            class="gantt-link-hit-area"
            style="cursor: pointer; pointer-events: auto;"
            @click.stop="selectDependencyLine(line, $event)"
            @dblclick.stop="connectionEditable && openLinkEditModal(line, $event)"
            @contextmenu.prevent="showDependencyContextMenu(line, $event)"
          />
          <!-- ÂèØËßÜÂåñËøûÊé•Á∫ø -->
          <path
            :d="line.path"
            :stroke="line.selected ? '#ff4757' : (isDependencyHighlighted(line) ? '#1890ff' : getConnectionLineColor(line))"
            :stroke-width="line.selected ? 1.5 : (isDependencyHighlighted(line) ? 1.5 : 1)"
            fill="none"
            :marker-end="line.selected ? 'url(#arrow-selected)' : (isDependencyHighlighted(line) ? 'url(#arrow-highlighted)' : 'url(#arrow-default)')"
            class="gantt-dependency-line-visual"
            :class="{
              'selected': line.selected,
              'highlighted': isDependencyHighlighted(line),
              'dimmed': highlightedConnections.isHighlightMode && !isDependencyHighlighted(line),
              'gray-mode': grayConnectionMode && !line.selected && !isDependencyHighlighted(line),
              'bezier': connectionStyle === 'bezier'
            }"
            style="pointer-events: auto; stroke-linecap: square; stroke-linejoin: round;"
          />

          <!-- ‰∏∫ËøûÊé•Âà∞ÁªìÊùüÁÇπÁöÑËøûÁ∫øÊ∑ªÂä†È¢ùÂ§ñÁöÑÁªàÁÇπÊåáÁ§∫Âô® -->
          <circle
            v-if="isEndPointConnection(line)"
            :cx="getEndPointIndicatorX(line)"
            :cy="getEndPointIndicatorY(line)"
            r="4"
            :fill="line.selected ? '#ff4757' : (isDependencyHighlighted(line) ? '#1890ff' : getConnectionLineColor(line))"
            stroke="white"
            stroke-width="2"
            class="gantt-end-point-indicator"
            style="pointer-events: auto; cursor: pointer;display:none"
            filter="url(#connectionShadow)"
            @click.stop="selectDependencyLine(line, $event)"
            @dblclick.stop="connectionEditable && openLinkEditModal(line, $event)"
          />
        </g>

        <!-- ‰æùËµñÁ∫øÊ†áÁ≠æ - Âè™ÊúâÂú®ÂêØÁî®Êó∂ÊâçÊòæÁ§∫ -->
        <g v-if="showConnectionLabels && line.label" class="gantt-link-label-group">
          <!-- Ê†áÁ≠æËÉåÊôØ -->
          <rect
            :x="line.labelX - 15"
            :y="line.labelY - 8"
            width="30"
            height="16"
            rx="8"
            class="gantt-link-label-bg"
            fill="rgba(255, 255, 255, 0.15)"
            stroke="rgba(0, 0, 0, 0.1)"
            stroke-width="0.5"
          />
          <!-- Ê†áÁ≠æÊñáÂ≠ó -->
          <text
            :x="line.labelX"
            :y="line.labelY + 3"
            class="gantt-link-label-text"
            :class="{ 'selected': line.selected }"
            fill="#666"
            font-size="10"
            text-anchor="middle"
            font-family="Arial, sans-serif"
            @click.stop="selectDependencyLine(line, $event)"
            @dblclick.stop="connectionEditable && editDependencyLabel(line, $event)"
          >
            {{ line.label }}
          </text>
        </g>
      </g>
    </svg>
    <!-- È¢ÑËßàËøûÁ∫øÂ±ÇÔºöpointer-events:noneÔºåÁ°Æ‰øù‰∏çÈòªÊå°‰∏ãÂ±Ç‰∫ã‰ª∂ -->
    <svg v-if="connectionPreview" class="gantt-connection-preview" :width="chartWidth" :height="chartHeight" style="position:absolute;top:0;left:0;z-index:2;pointer-events:none;">
      <line :x1="connectionPreview.startX" :y1="connectionPreview.startY" :x2="connectionPreview.endX" :y2="connectionPreview.endY" stroke="#1890ff" stroke-width="1.5" stroke-dasharray="3,3" stroke-linecap="round" opacity="0.9" filter="url(#connectionShadow)" />
      <circle :cx="connectionPreview.endX" :cy="connectionPreview.endY" r="3" fill="#1890ff" opacity="0.9" filter="url(#connectionShadow)" />
          </svg>

    <!-- Âè≥ÈîÆËèúÂçï -->
    <div v-if="enableContextMenu && contextMenu.visible" class="gantt-context-menu" :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }">
      <!-- ‰ªªÂä°Âè≥ÈîÆËèúÂçï -->
      <template v-if="contextMenu.type === 'task'">
        <div class="context-menu-header">{{ contextMenu.task?.name || '‰ªªÂä°Êìç‰Ωú' }}</div>
        <div class="context-menu-item" @click="editTaskFromMenu" v-if="hasPermission(contextMenu.task, 'editable')">
          <i class="el-icon-edit"></i> ÁºñËæë‰ªªÂä°
        </div>
        <div class="context-menu-item" @click="deleteTaskFromMenu" v-if="hasPermission(contextMenu.task, 'deletable')">
          <i class="el-icon-delete"></i> Âà†Èô§‰ªªÂä°
        </div>
        <div class="context-menu-item" @click="addChildTaskFromMenu" v-if="hasPermission(contextMenu.task, 'editable')">
          <i class="el-icon-plus"></i> Ê∑ªÂä†Â≠ê‰ªªÂä°
        </div>
        <div class="context-menu-item" @click="addSiblingTaskFromMenu" v-if="hasPermission(contextMenu.task, 'editable')">
          <i class="el-icon-circle-plus"></i> Ê∑ªÂä†ÂêåÁ∫ß‰ªªÂä°
        </div>
      </template>

      <!-- ‰æùËµñÁ∫øÂè≥ÈîÆËèúÂçï -->
      <template v-else-if="contextMenu.type === 'dependency'">
        <div class="context-menu-header">ËøûÁ∫øÊìç‰Ωú</div>
        <div class="context-menu-item" @click="editDependencyFromMenu" v-if="connectionEditable">
          <i class="el-icon-edit"></i> ÁºñËæëËøûÁ∫ø
        </div>
        <div class="context-menu-item" @click="deleteDependencyFromMenu" v-if="connectionEditable">
          <i class="el-icon-delete"></i> Âà†Èô§ËøûÁ∫ø
        </div>
      </template>
    </div>

    <!-- ‰ªªÂä°ÁºñËæëÂäüËÉΩÂ∑≤ÁßªËá≥GanttChartÁªü‰∏ÄÂºπÊ°Ü -->

    <!-- ËøûÊé•Á∫øÁºñËæëÂºπÊ°Ü -->
    <el-dialog
      title="Edit Connection"
      :visible.sync="linkEditModal.visible"
      width="500px"
      class="gantt-dialog gantt-link-edit-dialog gantt-bars-dialog"
      :close-on-click-modal="false"
      :close-on-press-escape="true"
      :append-to-body="true"
      :modal-append-to-body="true"
      @close="closeLinkEditModal"
    >
      <div class="gantt-link-edit-content">
        <div class="gantt-link-info" v-if="linkEditModal.link">
          <p><strong>From:</strong> {{ linkEditModal.link.fromTaskName }}</p>
          <p><strong>To:</strong> {{ linkEditModal.link.toTaskName }}</p>
        </div>

        <el-form label-width="120px" size="medium" ref="linkEditForm">
          <el-form-item label="Dependency Type">
            <el-select
              v-model="linkEditModal.type"
              placeholder="Select dependency type"
              class="gantt-dependency-type-selector"
              @change="onDependencyTypeChange"
              disabled
            >
              <el-option
                v-for="option in dependencyTypeOptions"
                :key="option.value"
                :label="option.label"
                :value="option.value"
                class="gantt-dependency-type-option"
              >
                <span class="dependency-type-icon" :style="{ color: option.color }">
                  {{ option.icon }}
                </span>
                <span class="dependency-type-label">{{ option.label }}</span>
                <div class="dependency-type-description">{{ option.description }}</div>
              </el-option>
            </el-select>
          </el-form-item>

          <el-form-item label="Lag (Days)">
            <el-input-number
              v-model="linkEditModal.lag"
              :min="-999"
              :max="999"
              :step="1"
              :precision="0"
              placeholder="Enter lag value"
              class="gantt-lag-input"
              controls-position="right"
            >
              <template slot="append">days</template>
            </el-input-number>
            <div class="lag-help-text">
              <div class="lag-explanation">
                <strong>LagËØ¥ÊòéÔºö</strong>
                <ul>
                  <li><strong>Ê≠£Êï∞ (+)Ôºö</strong> Âª∂ËøüÊâßË°åÔºåÊé®ËøüÂêéÁª≠‰ªªÂä°</li>
                  <li><strong>Ë¥üÊï∞ (-)Ôºö</strong> ÊèêÂâçÊâßË°åÔºåÂêéÁª≠‰ªªÂä°ÊèêÂâçÂêØÂä®</li>
                  <li><strong>0Ôºö</strong> Êó†Âª∂ËøüÔºåÊåâ‰æùËµñÁ±ªÂûãÁöÑÈªòËÆ§ËßÑÂàôÊâßË°å</li>
                </ul>
              </div>
              <div class="lag-current-info" v-if="linkEditModal.link">
                <strong>ÂΩìÂâçÈÖçÁΩÆÔºö</strong>
                {{ getDependencyDescription(linkEditModal.type) }}
                <span v-if="linkEditModal.lag !== 0" class="lag-effect">
                  {{ getLagEffectDescription(linkEditModal.type, linkEditModal.lag) }}
                </span>
              </div>
            </div>
          </el-form-item>

          <el-form-item label="Label">
            <el-input
              v-model="linkEditModal.label"
              placeholder="Enter connection label"
              clearable
            />
          </el-form-item>

          <el-form-item label="Color">
            <div class="gantt-color-selector">
              <div class="gantt-color-preview" :style="{ backgroundColor: linkEditModal.color }">
                <span class="color-text">{{ linkEditModal.color }}</span>
              </div>
              <div class="gantt-color-options">
                <div
                  v-for="color in availableColors"
                  :key="color"
                  class="gantt-color-option"
                  :class="{ selected: linkEditModal.color === color }"
                  :style="{ backgroundColor: color }"
                  @click="linkEditModal.color = color"
                ></div>
              </div>
            </div>
          </el-form-item>
        </el-form>
      </div>

      <div slot="footer" class="dialog-footer">
        <div>
          <el-button
            type="danger"
            @click="deleteLinkFromModal"
            v-if="connectionEditable"
          >
            Delete Connection
          </el-button>
        </div>
        <div>
          <el-button @click="closeLinkEditModal">
            Cancel
          </el-button>
          <el-button
            type="primary"
            @click="saveLinkChanges"
            :loading="linkEditModal.saving"
          >
            Save Changes
          </el-button>
        </div>
      </div>
    </el-dialog>

    <!-- Tooltip -->
    <div
      v-if="tooltip.visible"
      class="gantt-tooltip"
      :style="{ left: tooltip.x + 'px', top: tooltip.y + 'px' }"
      @mouseenter="onTooltipMouseEnter"
      @mouseleave="onTooltipMouseLeave"
    >
      <div class="tooltip-header">
        <div class="tooltip-title">{{ tooltip.task.name }}</div>
        <div class="tooltip-progress" :class="getTooltipStatusClass(tooltip.task)">
          {{ tooltip.task.progress || 0 }}%
        </div>
      </div>
      <div class="tooltip-content">
        <div class="tooltip-row">
          <span class="tooltip-label">Start:</span>
          <span class="tooltip-value">{{ formatTooltipDate(tooltip.task.startDate) }}</span>
        </div>
        <div class="tooltip-row">
          <span class="tooltip-label">End:</span>
          <span class="tooltip-value">{{ formatTooltipDate(tooltip.task.endDate) }}</span>
        </div>
        <div class="tooltip-row" v-if="tooltip.task.planStartDate">
          <span class="tooltip-label">Plan Start:</span>
          <span class="tooltip-value plan-date-tooltip">{{ formatTooltipDate(tooltip.task.planStartDate) }}</span>
        </div>
        <div class="tooltip-row" v-if="tooltip.task.planEndDate">
          <span class="tooltip-label">Plan End:</span>
          <span class="tooltip-value plan-date-tooltip">{{ formatTooltipDate(tooltip.task.planEndDate) }}</span>
        </div>
        <div class="tooltip-row">
          <span class="tooltip-label">Status:</span>
          <span class="tooltip-value status" :class="getTooltipStatusClass(tooltip.task)">
            {{ getTaskStatus(tooltip.task) }}
          </span>
        </div>
        <div class="tooltip-row" v-if="tooltip.task.milestone">
          <span class="tooltip-label">Type:</span>
          <span class="tooltip-value milestone">Milestone</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import moment from 'moment'
import { mapState, mapActions, mapGetters } from 'vuex'
import { getTaskTypeConfig } from '@/config/features'
import { getDependencyTypeOptions, getDependencyTypeConfig } from '@/config/dependencyTypes'
import { DependencyConstraintEngine } from '@/services/dependencyConstraints'

export default {
  name: 'GanttBars',
  props: {
    tasks: {
      type: Array,
      required: true
    },
    dependencies: {
      type: Array,
      default: () => []
    },
    startDate: {
      type: String,
      required: true
    },
    endDate: {
      type: String,
      required: true
    },
    unitWidth: {
      type: Number,
      required: false
    },
    chartWidth: {
      type: Number,
      required: true
    },
    chartHeight: {
      type: Number,
      required: true
    },
    containerWidth: {
      type: Number,
      default: null
    },
    viewMode: {
      type: String,
      default: 'month'
    },
    leftPanelWidth: {
      type: Number,
      default: 0
    },
    selectedTask: {
      type: Object,
      default: null
    },
    highlightedRowId: {
      type: [String, Number],
      default: null
    },
    // TooltipÈÖçÁΩÆ
    tooltipEnabled: {
      type: Boolean,
      default: false
    },
    tooltipDelay: {
      type: Number,
      default: 1000
    },
    tooltipHideDelay: {
      type: Number,
      default: 300
    },
    // ËäÇÁÇπÊòæÁ§∫ÈÖçÁΩÆÈÄâÈ°π
    showTaskName: {
      type: Boolean,
      default: true
    },
    showProgress: {
      type: Boolean,
      default: true
    },
    showProgressHandle: {
      type: Boolean,
      default: true
    },
    // Êñ∞Â¢ûÈÖçÁΩÆÈ°π
    showConnections: {
      type: Boolean,
      default: true
    },
    showConnectionLabels: {
      type: Boolean,
      default: false
    },
    showPlanNodes: {
      type: Boolean,
      default: false
    },
    showMilestones: {
      type: Boolean,
      default: true
    },
    showCriticalPath: {
      type: Boolean,
      default: false
    },
    allowParentDrag: {
      type: Boolean,
      default: false // ÈªòËÆ§‰∏çÂÖÅËÆ∏Áà∂ËäÇÁÇπÊãñÊãΩ
    },
    allowParentEdit: {
      type: Boolean,
      default: false // ÈªòËÆ§‰∏çÂÖÅËÆ∏Áà∂ËäÇÁÇπÁºñËæë
    },
    highlightTaskLineage: {
      type: Boolean,
      default: false // ÁÇπÂáªËäÇÁÇπÊòØÂê¶È´ò‰∫ÆÊòæÁ§∫Ë°ÄÁºòÂÖ≥Á≥ª
    },
    // ËøûÊé•Á∫øÊòØÂê¶ÂèØÁºñËæë
    connectionEditable: {
      type: Boolean,
      default: true  // ÈªòËÆ§ÂêØÁî®ËøûÊé•Á∫øÁºñËæë
    },
    // ËøûÊé•Á∫øÈªòËÆ§È¢úËâ≤ÔºàÂΩì‰∏çÂèØÁºñËæëÊó∂Ôºâ
    connectionDefaultColor: {
      type: String,
      default: '#9ca3af'
    },
    showDependencyLines: {
      type: Boolean,
      default: true // ÊéßÂà∂‰æùËµñÁ∫øÊòæÁ§∫
    },
    // Áà∂Â≠êËäÇÁÇπÊó∂Èó¥ÊòØÂê¶ÂÖ≥ËÅîÈÖçÁΩÆ
    linkParentChildDates: {
      type: Boolean,
      default: false // ÈªòËÆ§‰∏çÂÖ≥ËÅîÔºåÁà∂Â≠êËäÇÁÇπÁã¨Á´ãÁºñËæë
    },

    // ÊòØÂê¶ÂêØÁî®Âè≥ÈîÆËèúÂçï
    enableContextMenu: {
      type: Boolean,
      default: true
    },

    // ÊòØÂê¶ÂÖÅËÆ∏ÊãñÊãΩÂà∞ÂèØËßÜÂå∫ÂüüÂ§ñÈÉ®
    allowDragOutside: {
      type: Boolean,
      default: false
    },

    // ÊòØÂê¶Âú®ÁîòÁâπÊù°ÂêéÊòæÁ§∫‰ªªÂä°ÂêçÁß∞
    showTaskNames: {
      type: Boolean,
      default: true // ÈªòËÆ§ÊòæÁ§∫‰ªªÂä°ÂêçÁß∞
    },

    // ÊãñÊãΩÂà∞Â§ñÈÉ®Êó∂ÁöÑÈÖçÁΩÆ
    dragOutsideConfig: {
      type: Object,
      default: () => ({
        enabled: true,
        expandDays: 30,
        maxExpansions: 10,
        animationDuration: 300
      })
    },

    // Áà∂ËäÇÁÇπËøûÁ∫øÊéßÂà∂ÈÖçÁΩÆ
    allowParentConnection: {
      type: Boolean,
      default: false // ÈªòËÆ§‰∏çÂÖÅËÆ∏Áà∂ËäÇÁÇπËøûÁ∫øÔºå‰øùÊåÅÂÖºÂÆπÊÄß
    },

    // ËøûÁ∫øÊ†∑ÂºèÊ®°ÂºèÔºö'z-shaped' | 'traditional' | 'bezier' | 'smart'
    connectionStyle: {
      type: String,
      default: 'z-shaped', // ÈªòËÆ§‰ΩøÁî®ZÂ≠óÂΩ¢ËøûÁ∫ø
      validator: value => ['z-shaped', 'traditional', 'bezier', 'smart'].includes(value)
    },
    milestoneLinkable: {
      type: Boolean,
      default: false // ÈªòËÆ§‰∏çÂÖÅËÆ∏milestoneËøûÁ∫ø
    },
  },
  data() {
    return {
      // ÂÜÖÈÉ®Áä∂ÊÄÅÁÆ°ÁêÜ‰æùËµñÁ∫øÊòæÁ§∫ÔºåÈÅøÂÖçÁõ¥Êé•‰øÆÊîπprop
      internalShowDependencyLines: this.showDependencyLines,
      dragState: null,
      resizeState: null,
      connectionState: null,
      connectionPreview: null,
      temporarilyHideDependencies: false, // ÊéßÂà∂ÊãñÊãΩÊó∂ÈöêËóè‰æùËµñÁ∫ø
      hidingTaskId: null, // ÂΩìÂâçÊ≠£Âú®ÊãñÊãΩÁöÑ‰ªªÂä°IDÔºåÁî®‰∫éÂè™ÈöêËóèÁõ∏ÂÖ≥ÁöÑ‰æùËµñÁ∫ø
      hidingTaskIds: [], // Â≠òÂÇ®ÈúÄË¶ÅÈöêËóèËøûÁ∫øÁöÑ‰ªªÂä°IDÂàóË°®ÔºàÁà∂ËäÇÁÇπÂèäÂÖ∂Â≠êËäÇÁÇπÔºâ
      // dependencyLinesReady: false, // Â∑≤ÁßªÈô§ÔºåÈò≤Ê≠¢ËøûÁ∫øÈó™ÁÉÅ
      isSourceNodeDragging: false, // ÊòØÂê¶Ê≠£Âú®ÊãñÊãΩÈ´ò‰∫ÆÊ∫êËäÇÁÇπ
      isLineageNodeDragging: false, // ÊòØÂê¶Ê≠£Âú®ÊãñÊãΩË°ÄÁºòÂÖ≥Á≥ª‰∏≠ÁöÑËäÇÁÇπ
      preventNextBarClick: false, // ÈòªÊ≠¢resizeÂêéÁöÑÁÇπÂáª‰∫ã‰ª∂
      selectedDependency: null,
      // selectedTaskÁßªÈô§ÔºåÈÅøÂÖç‰∏épropÈáçÂ§ç

      // ÊÄßËÉΩ‰ºòÂåñÁõ∏ÂÖ≥
      rafId: null,
      pendingUpdates: null,
      updateThrottle: null,
      resizeThrottle: null,
      isDragOptimized: false,

      // ËøûÁ∫øÈÅøÈöúÂíåÁºìÂ≠ò‰ºòÂåñ
      _dependencyLayoutCache: null, // Â∏ÉÂ±ÄËÆ°ÁÆóÁºìÂ≠òÔºåÂú®mounted‰∏≠ÂàùÂßãÂåñ
      _layoutHash: null, // Â∏ÉÂ±ÄÂìàÂ∏åÂÄº
      _visibleAreaCache: null, // ÂèØËßÜÂå∫ÂüüÁºìÂ≠ò
      lineOffsetMap: null, // ËøûÁ∫øÂÅèÁßªÊò†Â∞ÑÔºåÂú®mounted‰∏≠ÂàùÂßãÂåñ
      connectionConflictMap: null, // ËøûÁ∫øÂÜ≤Á™ÅÊ£ÄÊµãÊò†Â∞ÑÔºåÂú®mounted‰∏≠ÂàùÂßãÂåñ
      scrollUpdateTimer: null, // ÊªöÂä®Êõ¥Êñ∞ËÆ°Êó∂Âô®


      colorPicker: {
        visible: false,
        x: 0,
        y: 0,
        targetLine: null
      },
      connectionHint: {
        visible: false,
        x: 0,
        y: 0,
        text: ''
      },
      availableColors: [
        '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#34495e', '#e67e22', '#8e44ad', '#27ae60',
        '#16a085', '#c0392b', '#d35400', '#7f8c8d', '#2c3e50'
      ],
      // ‰ªªÂä°ÁºñËæëÂäüËÉΩÂ∑≤ÁßªËá≥GanttChartÁªü‰∏ÄÂºπÊ°Ü
      // Element UI Áõ∏ÂÖ≥
      predefineColors: [
        '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#34495e', '#e67e22', '#8e44ad', '#27ae60'
      ],
      // Tooltip Áõ∏ÂÖ≥
      tooltip: {
        visible: false,
        x: 0,
        y: 0,
        task: null
      },
      linkEditModal: {
        visible: false,
        link: null,
        label: '',
        color: '#3498db',
        type: 'FS',
        lag: 0,
        originalState: null,
        saving: false
      },
      progressDragState: null,
      tooltipConfig: {
        enabled: this.tooltipEnabled,
        delay: this.tooltipDelay,
        hideDelay: this.tooltipHideDelay
      },
      tooltipTimer: null,      // tooltipÊòæÁ§∫ËÆ°Êó∂Âô®
      tooltipHideTimer: null,  // tooltipÈöêËóèËÆ°Êó∂Âô®
      scrollLeft: 0,
      preDragLineageSource: null,
      dragDelayTimer: null, // ÊãñÊãΩÂª∂ËøüÂÆöÊó∂Âô®
      dragPreventedByDblClick: false, // ÂÖ®Â±ÄÂèåÂáªÈò≤ÊãñÊãΩÊ†áÂøó

      // Âè≥ÈîÆËèúÂçïÁõ∏ÂÖ≥
      contextMenu: {
        visible: false,
        x: 0,
        y: 0,
        type: null, // 'task' Êàñ 'dependency'
        task: null,
        dependency: null
      },

      // ÊãñÊãΩÊâ©Â±ïÁõëÂê¨Áä∂ÊÄÅ
      dragOutsideMonitoring: {
        enabled: false,
        task: null,
        expansionCount: 0,
        lastDirection: null
      },
    }
  },
  watch: {
    // ÁõëÂê¨propÂèòÂåñÔºåÂêåÊ≠•Âà∞ÂÜÖÈÉ®Áä∂ÊÄÅ
    showDependencyLines: {
      handler(newVal) {
        this.internalShowDependencyLines = newVal;
      },
      immediate: true
    }
  },
  computed: {
    ...mapState({
      storeDependencies: 'dependencies',
      highlightedConnections: 'highlightedConnections',
      grayConnectionMode: 'grayConnectionMode'
    }),
    ...mapGetters(['getDependencyLabel', 'isTaskSelected', 'isTaskHighlighted', 'isTaskDimmed', 'getTaskHighlightType', 'isDependencyHighlighted']),

    // ËÆ°ÁÆóÊÄªÂ§©Êï∞
    totalDays() {
      return moment(this.endDate).diff(moment(this.startDate), 'days') + 1
    },

    // Ëé∑ÂèñÂÆπÂô®ÂèØÁî®ÂÆΩÂ∫¶
    actualContainerWidth() {
      // ‰ºòÂÖà‰ΩøÁî®Áà∂ÁªÑ‰ª∂‰º†ÂÖ•ÁöÑÂÆΩÂ∫¶
      if (this.containerWidth) {
        return this.containerWidth
      }

      // Â∞ùËØï‰ªéÂ§ö‰∏™Â±ÇÁ∫ßËé∑ÂèñÂÆûÈôÖÂÆπÂô®ÂÆΩÂ∫¶
      let width = 1200 // ÈªòËÆ§ÂÄº

      if (this.$el) {
        // ÂÖàÂ∞ùËØï‰ªéÁªÑ‰ª∂ÂÖÉÁ¥†Êú¨Ë∫´Ëé∑Âèñ
        width = this.$el.clientWidth

        // Â¶ÇÊûúÂÖÉÁ¥†Êú¨Ë∫´ÂÆΩÂ∫¶‰∏∫0ÊàñÂæàÂ∞èÔºåÂ∞ùËØï‰ªéÁà∂Á∫ßËé∑Âèñ
        if (width < 100) {
          let parent = this.$el.parentElement
          while (parent && width < 100) {
            width = parent.clientWidth
            parent = parent.parentElement
          }
        }
      }

      return Math.max(width, 800) // Á°Æ‰øùÊúÄÂ∞èÂÆΩÂ∫¶
    },

    // ËÆ°ÁÆóÂ±ûÊÄßÔºöËé∑ÂèñÂÆûÈôÖÂçï‰ΩçÂÆΩÂ∫¶
    actualUnitWidth() {
      // ‰ºòÂÖà‰ΩøÁî®props‰º†ÂÖ•ÁöÑunitWidth
      if (this.unitWidth) {
        return this.unitWidth
      }

      // Â¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•ÔºåÂàôËá™Âä®ËÆ°ÁÆó
      const availableWidth = Math.max(this.actualContainerWidth, 800)

      let baseWidth
      switch(this.viewMode) {
      case 'day':
        baseWidth = Math.min(Math.max(availableWidth / this.totalDays, 40), 80)
        break
      case 'month':
        baseWidth = Math.min(Math.max(availableWidth / this.totalDays, 3), 20)
        break
      case 'quarter':
        baseWidth = Math.min(Math.max(availableWidth / this.totalDays, 2), 10)
        break
      case 'year':
        baseWidth = Math.min(Math.max(availableWidth / this.totalDays, 1), 5)
        break
      default:
        baseWidth = Math.max(availableWidth / this.totalDays, 3)
      }

      return baseWidth
    },

    actualChartWidth() {
      // ‰ºòÂÖà‰ΩøÁî®props‰º†ÂÖ•ÁöÑchartWidth
      if (this.chartWidth) {
        return this.chartWidth
      }

      // Â¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•ÔºåÂàôËá™Âä®ËÆ°ÁÆó
      if (!this.startDate || !this.endDate) return 1200
      const daysDiff = moment(this.endDate).diff(moment(this.startDate), 'days')
      return Math.max(daysDiff * this.actualUnitWidth, 1200)
    },

    actualChartHeight() {
      // ‰ºòÂÖà‰ΩøÁî®props‰º†ÂÖ•ÁöÑchartHeight
      if (this.chartHeight) {
        return this.chartHeight
      }

      // Â¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•ÔºåÂàôËá™Âä®ËÆ°ÁÆó
      return this.tasks.length * 40 + 100
    },

    uniqueColors() {
      const colors = new Set(['#3498db', '#ff4757', '#666']) // ÈªòËÆ§È¢úËâ≤
      this.dependencies.forEach(dep => {
        if (dep.color) colors.add(dep.color)
      })
      return Array.from(colors)
    },

    // ËÆ°ÁÆóÂÖ≥ÈîÆË∑ØÂæÑ‰ªªÂä°IDÈõÜÂêà
    criticalPathTaskIds() {
      // Â¶ÇÊûúÊú™ÂêØÁî®ÂÖ≥ÈîÆË∑ØÂæÑÊòæÁ§∫ÔºåËøîÂõûÁ©∫ÈõÜÂêà
      if (!this.showCriticalPath) {
        return new Set()
      }

      // ËÆ°ÁÆóÂÖ≥ÈîÆË∑ØÂæÑÂπ∂ËøîÂõûIDÈõÜÂêà
      const criticalPathIds = this.calculateCriticalPath()
      return new Set(criticalPathIds)
    },

    // Ëé∑Âèñ‰ªªÂä°ÊåÅÁª≠Êó∂Èó¥ÔºàËÆ°ÁÆóÂ±ûÊÄßÔºâ
    taskDuration() {
      return (task) => {
        if (!task.startDate || !task.endDate) return 1 // ÈªòËÆ§Ëá≥Â∞ë1Â§©
        const start = moment(task.startDate)
        const end = moment(task.endDate)
        // ËÆ°ÁÆóÊåÅÁª≠Â§©Êï∞ÔºàÂåÖÊã¨ÂºÄÂßãÂíåÁªìÊùüÊó•Ôºâ
        return end.diff(start, 'days') + 1
      }
    },

    taskBars() {
      return this.tasks.map((task, index) => {
        const left = this.getDatePosition(task.startDate)
        const endLeft = this.getDatePosition(task.endDate)
        const width = Math.max(endLeft - left, 60) // ÊúÄÂ∞èÂÆΩÂ∫¶60px

        // ËÆ°ÂàíÊó•Êúü‰ΩçÁΩÆÔºàÂ¶ÇÊûúÊúâÔºâ
        let planLeft, planWidth
        if (task.planStartDate && task.planEndDate) {
          planLeft = this.getDatePosition(task.planStartDate)
          const planEndLeft = this.getDatePosition(task.planEndDate)
          planWidth = Math.max(planEndLeft - planLeft, 60)
        }

        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂÖ≥ÈîÆË∑ØÂæÑ‰ªªÂä°
        const isCriticalPath = this.criticalPathTaskIds.has(task.id)

        return {
          task,
          index,
          left,
          width,
          planLeft,
          planWidth,
          isCriticalPath,
          isDragging: this.dragState && this.dragState.bar.task.id === task.id
        }
      })
    },

    dependencyLines() {
      // ËÆ°ÁÆóÊúÄÊñ∞ÁöÑËøûÁ∫øÔºåÂìçÂ∫îselectedDependencyÂèòÂåñ
      // Âº∫Âà∂‰æùËµñselectedDependencyÔºåÁ°Æ‰øùÈÄâ‰∏≠Áä∂ÊÄÅÂèòÂåñÊó∂ÈáçÊñ∞ËÆ°ÁÆó
      const selectedKey = this.selectedDependency ?
        `${this.selectedDependency.from}-${this.selectedDependency.to}` : null

      // console.log('[Ë∞ÉËØï] dependencyLinesËÆ°ÁÆóÔºåÈÄâ‰∏≠ËøûÁ∫ø:', selectedKey)
      return this.calculateDependencyLines()
    },

    // Âà§Êñ≠‰ªªÂä°ÊòØÂê¶Âú®È´ò‰∫ÆËøûÊé•‰∏≠
    isTaskInHighlight() {
      return (taskId) => {
        if (!this.highlightedConnections.sourceTaskId) return false
        return taskId === this.highlightedConnections.sourceTaskId ||
               this.highlightedConnections.relatedTaskIds.includes(taskId)
      }
    },

    // Âà§Êñ≠‰ªªÂä°ÊòØÂê¶‰∏∫ËøûÊé•Ê∫ê
    isConnectionSource() {
      return (taskId) => {
        return taskId === this.highlightedConnections.sourceTaskId
      }
    },

    // Ëé∑Âèñ‰∏éÊåáÂÆö‰ªªÂä°Áõ∏ÂÖ≥ÁöÑÊâÄÊúâ‰ªªÂä°ID
    getRelatedTasks() {
      return (taskId) => {
        const relatedIds = new Set()
        this.dependencies.forEach(dep => {
          if (dep.from === taskId) {
            relatedIds.add(dep.to)
          }
          if (dep.to === taskId) {
            relatedIds.add(dep.from)
          }
        })
        return Array.from(relatedIds)
      }
    },

    // Âà§Êñ≠‰æùËµñÂÖ≥Á≥ªÊòØÂê¶Ë¢´È´ò‰∫Æ
    isDependencyHighlighted() {
      return (line) => {
        if (!this.highlightedConnections.isHighlightMode) return false

        return this.highlightedConnections.relatedDependencies.some(dep =>
          dep.from === line.from && dep.to === line.to
        )
      }
    },

    // Ëé∑Âèñ‰ªªÂä°È´ò‰∫ÆÁ±ªÂûã
    getTaskHighlightType() {
      return (taskId) => {
        if (!this.highlightedConnections.isHighlightMode) return null

        if (taskId === this.highlightedConnections.sourceTaskId) {
          return 'source'
        } else if (this.highlightedConnections.upstreamTasks.includes(taskId)) {
          return 'upstream'
        } else if (this.highlightedConnections.downstreamTasks.includes(taskId)) {
          return 'downstream'
        }

        return null
      }
    },

    // Âà§Êñ≠‰ªªÂä°ÊòØÂê¶Ë¢´È´ò‰∫Æ
    isTaskHighlighted() {
      return (taskId) => {
        return this.highlightedConnections.relatedTaskIds.includes(taskId)
      }
    },

    // Âà§Êñ≠‰ªªÂä°ÊòØÂê¶Ë¢´Ê∑°Âåñ
    isTaskDimmed() {
      return (taskId) => {
        return this.highlightedConnections.isHighlightMode &&
               !this.highlightedConnections.relatedTaskIds.includes(taskId)
      }
    },

    // ÊâÄÊúâÂèØÁî®È¢úËâ≤ÔºàÂåÖÊã¨ÁÅ∞Ëâ≤Ôºâ
    allAvailableColors() {
      const grayColor = '#9e9e9e' // bryntumÈ£éÊ†ºÁöÑÁÅ∞Ëâ≤
      return [...this.availableColors, grayColor]
    },

    // Ëé∑Âèñ‰æùËµñÁ±ªÂûãÈÄâÈ°π
    dependencyTypeOptions() {
      return this.$store.getters.dependencyTypeOptions || []
    },

    // Ëé∑ÂèñÊâÄÊúâÈúÄË¶ÅÁÆ≠Â§¥Ê†áËÆ∞ÁöÑÈ¢úËâ≤
    arrowColors() {
      const colors = new Set()

      // Ê∑ªÂä†ÈªòËÆ§È¢úËâ≤
      colors.add('#666')
      colors.add('#3498db')
      colors.add('#ff4757')  // ÈÄâ‰∏≠Áä∂ÊÄÅ
      colors.add('#1890ff')  // È´ò‰∫ÆÁä∂ÊÄÅ

      // Ê∑ªÂä†ÂèØÁî®È¢úËâ≤
      this.availableColors.forEach(color => colors.add(color))

      // Ê∑ªÂä†‰æùËµñÁ∫ø‰∏≠‰ΩøÁî®ÁöÑÈ¢úËâ≤
      this.dependencies.forEach(dep => {
        if (dep.color) colors.add(dep.color)
      })

      return Array.from(colors)
    },

    visibleDependencyLines() {
      // ‰ªÖÊ∏≤ÊüìÂèØËßÅÂå∫ÁöÑ‰æùËµñÁ∫øÔºåÊèêÂçáÊÄßËÉΩ
      if (!this.internalShowDependencyLines || this.temporarilyHideDependencies) return [];
      const visibleTaskIds = this.getVisibleTaskIds(); // Ëé∑ÂèñÂèØËßÅ‰ªªÂä°ID
      return this.dependencyLines.filter(line =>
        visibleTaskIds.includes(line.from) || visibleTaskIds.includes(line.to)
      );
    }
  },
  watch: {
    closeModalTrigger() {
      // ÂΩìÁà∂ÁªÑ‰ª∂Ëß¶ÂèëÂÖ≥Èó≠Ê®°ÊÄÅÊ°ÜÊó∂
      this.closeTaskEditor()
    },
    highlightedRowId: {
      handler(newVal, oldVal) {
        // Âº∫Âà∂Êõ¥Êñ∞‰ª•Á°Æ‰øùÈ´ò‰∫ÆÊ†∑ÂºèÂ∫îÁî®
        this.$forceUpdate()
      },
      immediate: true
    },
    // ÁõëÂê¨‰ªªÂä°Êï∞ÊçÆÂèòÂåñÔºåÊ∏ÖÈô§‰æùËµñÁ∫øÁºìÂ≠ò
    tasks: {
      handler(newTasks, oldTasks) {
        if (newTasks !== oldTasks) {
          this.clearDependencyCache()
        }
      }
    },
    // ÁõëÂê¨‰æùËµñÂÖ≥Á≥ªÂèòÂåñÔºåÊ∏ÖÈô§ÁºìÂ≠ò
    storeDependencies: {
      handler(newDeps, oldDeps) {
        if (newDeps !== oldDeps) {
          this.clearDependencyCache()
        }
      }
    },
    // ÁõëÂê¨Êó∂Èó¥ËΩ¥ÂèòÂåñÔºåÊ∏ÖÈô§ÁºìÂ≠ò
    actualUnitWidth(newVal, oldVal) {
      if (newVal !== oldVal) {
        this.clearDependencyCache()
      }
    },
    // ÁõëÂê¨ËßÜÂõæÊ®°ÂºèÂèòÂåñ
    viewMode(newMode, oldMode) {
      if (newMode !== oldMode) {
        this.clearDependencyCache()
        this.$nextTick(() => {
          this.$forceUpdate()
        })
      }
    },
    // ÁõëÂê¨Êó•ÊúüËåÉÂõ¥ÂèòÂåñ
    startDate() {
      this.clearDependencyCache()
      this.$nextTick(() => {
        this.$forceUpdate()
      })
    },
    endDate() {
      this.clearDependencyCache()
      this.$nextTick(() => {
        this.$forceUpdate()
      })
    },
    // ÁõëÂê¨tooltipÈÖçÁΩÆÂèòÂåñ
    tooltipEnabled(newVal) {
      this.tooltipConfig.enabled = newVal
      if (!newVal) {
        this.hideTooltip()
      }
    },
    tooltipDelay(newVal) {
      this.tooltipConfig.delay = newVal
    },
    tooltipHideDelay(newVal) {
      this.tooltipConfig.hideDelay = newVal
    },
    // ÁõëÂê¨ËøûÁ∫øÈÄâ‰∏≠Áä∂ÊÄÅÂèòÂåñ
    selectedDependency: {
      handler(newVal, oldVal) {
        console.log('[Ë∞ÉËØï] selectedDependencyÂèòÂåñ:', newVal, oldVal)
        // ÈÄâ‰∏≠Áä∂ÊÄÅÂèòÂåñÊó∂ÔºåÊ∏ÖÈô§ÁºìÂ≠òÂπ∂Âº∫Âà∂Êõ¥Êñ∞
        this._cachedDependencyLines = null
        this.$forceUpdate()
      },
      deep: true
    }
  },
  mounted() {
    // ÂàùÂßãÂåñÁºìÂ≠òMapÂØπË±°ÔºåÈÅøÂÖçundefinedÈîôËØØ
    this.initializeCacheMaps()

    this.setupEventListeners()
    this.$el.addEventListener('click', this.handleComponentClick)
    document.addEventListener('click', this.handleGlobalClick)

    // ÁõëÂê¨Á™óÂè£Â§ßÂ∞èÂèòÂåñÔºåÈáçÊñ∞ËÆ°ÁÆó
    this.handleResize = this.optimizedUpdate(() => {
      this.clearDependencyCache()
      this.$forceUpdate()
    }, 100) // Èôç‰ΩéÁ™óÂè£Â§ßÂ∞èÂèòÂåñÁöÑÂìçÂ∫îÈ¢ëÁéá

    window.addEventListener('resize', this.handleResize)

    // ÂàùÂßãÂåñÊó∂Âº∫Âà∂Êõ¥Êñ∞‰∏ÄÊ¨°
    this.$nextTick(() => {
      // Áõ¥Êé•Êõ¥Êñ∞Ôºå‰∏çÂÜç‰ΩøÁî®dependencyLinesReadyÊéßÂà∂Èó™ÁÉÅ
      this.clearDependencyCache()
      this.$forceUpdate()
    })

    // ÁõëÂê¨Áà∂Á∫ßÊªöÂä®ÂÆπÂô®ÁöÑscroll‰∫ã‰ª∂
    this.$nextTick(() => {
      let parent = this.$el
      while (parent && !parent.classList.contains('gantt-scroll-container')) {
        parent = parent.parentElement
      }
      this._ganttScrollContainer = parent
      if (parent) {
        parent.addEventListener('scroll', this.handleParentScroll, { passive: true })
        this.scrollLeft = parent.scrollLeft
      }
    })

    // ÂàùÂßãÂåñÁà∂ËäÇÁÇπÊåáÁ§∫Âô®Áä∂ÊÄÅ
    this.$nextTick(() => {
      this.updateParentIndicators()
    })

    // Ê∑ªÂä†ÂÖ®Â±ÄÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨ÔºåÁî®‰∫éÂÖ≥Èó≠Âè≥ÈîÆËèúÂçï
    document.addEventListener('click', this.hideContextMenu)
    document.addEventListener('contextmenu', this.hideContextMenu)

    // È¶ñÊ¨°Ê∏≤ÊüìÂêéÂº∫Âà∂Âà∑Êñ∞‰æùËµñÁ∫øÔºåËß£ÂÜ≥ÂàùÂßãÂåñÂè™ÊòæÁ§∫ÈÉ®ÂàÜËøûÁ∫øÈóÆÈ¢ò
    this.$nextTick(() => {
      this.$forceUpdate();
    });
  },
  beforeDestroy() {
    // Âº∫Âà∂Ê∏ÖÁêÜÊãñÊãΩÁä∂ÊÄÅÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè
    this.forceClearDragState()

    // Ê∏ÖÁêÜÊâÄÊúâËÆ°Êó∂Âô®ÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè
    if (this.tooltipTimer) {
      clearTimeout(this.tooltipTimer)
    }
    if (this.tooltipHideTimer) {
      clearTimeout(this.tooltipHideTimer)
    }

    // ÁßªÈô§ÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨Âô®
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    document.removeEventListener('click', this.handleGlobalClick)

    if (this._ganttScrollContainer) {
      this._ganttScrollContainer.removeEventListener('scroll', this.handleParentScroll)
    }

    // ÁßªÈô§ÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨
    document.removeEventListener('click', this.hideContextMenu)
    document.removeEventListener('contextmenu', this.hideContextMenu)

    // Ê∏ÖÁêÜÁºìÂ≠òMapÂØπË±°ÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè
    if (this._dependencyLayoutCache) {
      this._dependencyLayoutCache.clear()
      this._dependencyLayoutCache = null
    }
    if (this.lineOffsetMap) {
      this.lineOffsetMap.clear()
      this.lineOffsetMap = null
    }
    if (this.connectionConflictMap) {
      this.connectionConflictMap.clear()
      this.connectionConflictMap = null
    }
    if (this.scrollUpdateTimer) {
      clearTimeout(this.scrollUpdateTimer)
      this.scrollUpdateTimer = null
    }
  },
  methods: {
    ...mapActions(['addDependency', 'updateDependencyLabel', 'removeDependency']),

    // Ê£ÄÊü•‰ªªÂä°ÊòØÂê¶Â∑≤ÊäòÂè†
    isTaskCollapsed(taskId) {
      return this.$store.getters.isTaskCollapsed(taskId)
    },

    setupEventListeners() {
      // ÁßªÈô§Ë¢´Âä®ÁõëÂê¨Âô®Ôºå‰øùÊåÅÂéüÊúâÁöÑ‰∫ã‰ª∂Â§ÑÁêÜËÉΩÂäõ
      document.addEventListener('mousemove', this.handleMouseMove)
      document.addEventListener('mouseup', this.handleMouseUp)
    },

    removeEventListeners() {
      document.removeEventListener('mousemove', this.handleMouseMove)
      document.removeEventListener('mouseup', this.handleMouseUp)

      // Ê∏ÖÁêÜRAF
      if (this.rafId) {
        cancelAnimationFrame(this.rafId)
        this.rafId = null
      }

      // Ê∏ÖÁêÜËäÇÊµÅ
      if (this.updateThrottle) {
        clearTimeout(this.updateThrottle)
        this.updateThrottle = null
      }
    },

    // ‰ºòÂåñÁöÑÈò≤ÊäñÊõ¥Êñ∞ÂáΩÊï∞
    optimizedUpdate(updateFn, delay = 16) {
      if (this.updateThrottle) {
        clearTimeout(this.updateThrottle)
      }

      this.updateThrottle = setTimeout(() => {
        updateFn()
      }, delay)
    },

    // ÊâπÈáèÂ§ÑÁêÜDOMÊõ¥Êñ∞
    batchDOMUpdate(updates) {
      if (this.rafId) {
        cancelAnimationFrame(this.rafId)
      }

      this.rafId = requestAnimationFrame(() => {
        updates.forEach(update => update())
      })
    },

    getDatePosition(date) {
      // Èò≤Êä§Êé™ÊñΩÔºöÁ°Æ‰øùËæìÂÖ•ÊúâÊïà
      if (!date || !this.startDate || !this.actualUnitWidth) {
        return 0
      }

      // Á°Æ‰øùÊó•Êúü‰ªéÂºÄÂßãÁöÑÊï¥Â§©ÁÆóËµ∑
      const startOfDay = moment(date).startOf('day')
      const startOfStartDate = moment(this.startDate).startOf('day')
      const daysDiff = startOfDay.diff(startOfStartDate, 'days')

      // ‰ΩøÁî®‰∏éTimelineÁõ∏ÂêåÁöÑÂçï‰ΩçÂÆΩÂ∫¶Áõ¥Êé•ËÆ°ÁÆó
      const result = daysDiff * this.actualUnitWidth

      // Èò≤Êä§ÔºöÁ°Æ‰øùËøîÂõûÊúâÊïàÊï∞ÂÄº
      return isNaN(result) ? 0 : result
    },

    getPositionDate(position) {
      // ‰ΩøÁî®‰∏éTimeline‰∏ÄËá¥ÁöÑËÆ°ÁÆóÊñπÂºè
      const days = position / this.actualUnitWidth
      return moment(this.startDate).startOf('day').add(Math.round(days), 'days')
    },

    onBarMouseDown(bar, event) {
      // Ë∞ÉËØï‰ø°ÊÅØÔºöËæìÂá∫ÊãñÊãΩ‰∫ã‰ª∂Ëß¶ÂèëÊÉÖÂÜµ
      console.log('[ÊãñÊãΩË∞ÉËØï] onBarMouseDown Ëß¶Âèë', {
        taskId: bar.task.id,
        taskName: bar.task.name,
        button: event.button,
        target: event.target.className,
        dragPreventedByDblClick: this.dragPreventedByDblClick
      })

      // Âè™Â§ÑÁêÜÂ∑¶ÈîÆÁÇπÂáªÔºàbutton=0ÔºâÔºåÂè≥ÈîÆÁÇπÂáª‰∏çËß¶ÂèëÊãñÂä®
      if (event.button !== 0) {
        console.log('[ÊãñÊãΩË∞ÉËØï] ÈùûÂ∑¶ÈîÆÁÇπÂáªÔºåÂøΩÁï•ÊãñÊãΩ')
        return;
      }

      // ÂèåÂáªÂêéÁü≠Êó∂Èó¥ÂÜÖÁ¶ÅÊ≠¢ÊãñÊãΩ
      if (this.dragPreventedByDblClick) {
        console.log('[ÊãñÊãΩË∞ÉËØï] ÂèåÂáªÂêéÁ¶ÅÊ≠¢ÊãñÊãΩÊúüÈó¥ÔºåÂøΩÁï•ÊãñÊãΩ')
        event.preventDefault();
        return;
      }

      console.log('[ÊãñÊãΩË∞ÉËØï] ËÆæÁΩÆÊãñÊãΩÂª∂ËøüÂÆöÊó∂Âô®Ôºå150msÂêéÂºÄÂßãÊãñÊãΩ')
      // ÊãñÊãΩÂª∂ËøüÂà§ÂÆöÔºå150msÂêéÊâçÂÖÅËÆ∏ÊãñÊãΩ
      this.dragDelayTimer = setTimeout(() => {
        if (!this.dragPreventedByDblClick) {
          console.log('[ÊãñÊãΩË∞ÉËØï] Âª∂ËøüÊó∂Èó¥Âà∞ÔºåÂºÄÂßãÊâßË°åÊãñÊãΩ')
          this.startDrag(bar, event);
        } else {
          console.log('[ÊãñÊãΩË∞ÉËØï] Âª∂ËøüÊúüÈó¥ÂèëÁîüÂèåÂáªÔºåÂèñÊ∂àÊãñÊãΩ')
        }
        this.dragDelayTimer = null;
      }, 150);
    },

    onBarDblClick(bar, event) {
      if (this.dragDelayTimer) {
        clearTimeout(this.dragDelayTimer);
        this.dragDelayTimer = null;
      }
      this.dragPreventedByDblClick = true;
      setTimeout(() => { this.dragPreventedByDblClick = false; }, 300);
      this.editTask(bar.task);
    },

    startDrag(bar, event) {
      if (this.dragPreventedByDblClick) {
        return;
      }
      // ÈòªÊ≠¢Âú®ËøûÊé•Ê®°Âºè‰∏ãÊãñÊãΩ‰ªªÂä°
      if (this.connectionState) {
        return
      }

      // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÁà∂ËäÇÁÇπÁöÑÂ±ïÂºÄ/ÊäòÂè†ÂõæÊ†áÔºå‰∏çËøõË°åÊãñÊãΩ
      if (bar.task.isParentNode && event.target.closest('.parent-indicator')) {
        // Â§ÑÁêÜÊäòÂè†/Â±ïÂºÄÈÄªËæëÂ∑≤ÁªèÂú®parent-indicatorÁöÑclick‰∫ã‰ª∂‰∏≠Â§ÑÁêÜ
        // ËøôÈáåÂè™ÈúÄÈòªÊ≠¢ÊãñÊãΩÂç≥ÂèØ
        return
      }

      // Ê£ÄÊü•Áà∂ËäÇÁÇπÊãñÊãΩÈÖçÁΩÆÔºåÂ¶ÇÊûú‰∏çÂÖÅËÆ∏Áà∂ËäÇÁÇπÊãñÊãΩ‰∏îÂΩìÂâçÊòØÁà∂ËäÇÁÇπÔºåÂàôÈòªÊ≠¢ÊãñÊãΩ
      if (bar.task.isParentNode && !this.allowParentDrag) {
        console.log('Áà∂ËäÇÁÇπÊãñÊãΩÂ∑≤Á¶ÅÁî®')
        return
      }

      // Ê£ÄÊü•‰ªªÂä°ÊãñÊãΩÊùÉÈôê - Âè≥‰æßËäÇÁÇπÊØè‰∏ÄË°åÈÉΩÈúÄË¶ÅÊúâÁºñËæëÊùÉÈôêÊéßÂà∂
      if (!this.hasPermission(bar.task, 'movable')) {
        this.$message.warning('ËØ•‰ªªÂä°‰∏çÂÖÅËÆ∏ÊãñÊãΩÁßªÂä®')
        event.preventDefault()
        return
      }

      // ÊãñÊãΩÂâçÊöÇÂ≠òÈ´ò‰∫ÆË°ÄÁºòÁä∂ÊÄÅ
      this._preDragLineageSource = this.$store.state.highlightedConnections?.sourceTaskId
      console.log('[Ë∞ÉËØï] startDrag Ë¢´Ë∞ÉÁî®', bar.task.id, 'È´ò‰∫ÆÊ∫ê:', this._preDragLineageSource)

      // Âè™ÈöêËóè‰∏éÂΩìÂâçÊãñÊãΩËäÇÁÇπÁõ∏ÂÖ≥ÁöÑË°ÄÁºòÂÖ≥Á≥ªÁ∫ø
      if (this._preDragLineageSource && this._preDragLineageSource === bar.task.id) {
        // Âè™ÊúâÂΩìÊãñÊãΩÁöÑÊòØÈ´ò‰∫ÆÊ∫êËäÇÁÇπÊó∂ÊâçÊ∏ÖÈô§È´ò‰∫Æ
        this.$store.dispatch('clearLineageHighlight')
        console.log('[Ë∞ÉËØï] Â∑≤Ê∏ÖÁ©∫È´ò‰∫ÆË°ÄÁºò - ÊãñÊãΩÁöÑÊòØÊ∫êËäÇÁÇπ')
        this._isSourceNodeDragging = true
      } else if (this._preDragLineageSource) {
        // Ê£ÄÊü•ÂΩìÂâçÊãñÊãΩÁöÑËäÇÁÇπÊòØÂê¶Âú®È´ò‰∫ÆÁöÑË°ÄÁºòÂÖ≥Á≥ª‰∏≠
        const isInLineage = this.isTaskHighlighted(bar.task.id)
        if (isInLineage) {
          // Âè™ÊúâÂΩìÊãñÊãΩÁöÑËäÇÁÇπÂú®Ë°ÄÁºòÂÖ≥Á≥ª‰∏≠Êó∂ÊâçÊ∏ÖÈô§È´ò‰∫Æ
          this.$store.dispatch('clearLineageHighlight')
          console.log('[Ë∞ÉËØï] Â∑≤Ê∏ÖÁ©∫È´ò‰∫ÆË°ÄÁºò - ÊãñÊãΩÁöÑËäÇÁÇπÂú®Ë°ÄÁºòÂÖ≥Á≥ª‰∏≠')
          this._isLineageNodeDragging = true
        } else {
          // ÊãñÊãΩÁöÑËäÇÁÇπ‰∏çÂú®Ë°ÄÁºòÂÖ≥Á≥ª‰∏≠Ôºå‰∏çÈúÄË¶ÅÊ∏ÖÈô§È´ò‰∫Æ
          console.log('[Ë∞ÉËØï] ‰øùÁïôÈ´ò‰∫ÆË°ÄÁºò - ÊãñÊãΩÁöÑËäÇÁÇπ‰∏çÂú®Ë°ÄÁºòÂÖ≥Á≥ª‰∏≠')
          this._isLineageNodeDragging = false
          this._isSourceNodeDragging = false
        }
      }

      // Áà∂ËäÇÁÇπÊãñÊãΩÊó∂ÈöêËóèÊâÄÊúâÂ≠êËäÇÁÇπÁöÑÁõ∏ÂÖ≥ËøûÁ∫ø
      if (bar.task.isParentNode) {
        // Ëé∑ÂèñÊâÄÊúâÂ≠êËäÇÁÇπID
        const childTaskIds = this.getAllChildTaskIds(bar.task.id)
        // ÈöêËóèÁà∂ËäÇÁÇπÂèäÂÖ∂ÊâÄÊúâÂ≠êËäÇÁÇπÁöÑËøûÊé•Á∫ø
        this.hidingTaskIds = [bar.task.id, ...childTaskIds]
        this.temporarilyHideDependencies = true

        // ÊòæÁ§∫ÊãñÊãΩÊèêÁ§∫
        console.log(`ÂºÄÂßãÊãñÊãΩÁà∂ËäÇÁÇπ: ${bar.task.name}ÔºåÂ∞ÜÂêåÊó∂ÁßªÂä®ÊâÄÊúâÂ≠êËäÇÁÇπ`)

        // Ê∑ªÂä†ËßÜËßâÂèçÈ¶à
        const barElement = event.target.closest('.gantt-bar')
        if (barElement) {
          barElement.classList.add('parent-dragging-active')
        }
      } else {
        // ÊôÆÈÄöËäÇÁÇπÂè™ÈöêËóè‰∏éÂΩìÂâçËäÇÁÇπÁõ∏ÂÖ≥ÁöÑ‰æùËµñËøûÊé•Á∫ø
        this.hidingTaskId = bar.task.id
        this.temporarilyHideDependencies = false
      }

      // Á´ãÂç≥ÈòªÊ≠¢‰∫ã‰ª∂‰º†Êí≠ÔºåÈò≤Ê≠¢Ëß¶ÂèëËÉåÊôØÊãñÊãΩ
      event.preventDefault()
      event.stopPropagation()

      // ÈÄöÁü•Áà∂ÁªÑ‰ª∂ÂºÄÂßãÊãñÊãΩÔºåÁ¶ÅÁî®ËÉåÊôØ‰∫§‰∫í
      this.$emit('node-drag-start', bar.task)

      // Â¶ÇÊûúÂêØÁî®‰∫ÜÊãñÊãΩÊâ©Â±ïÂäüËÉΩÔºåËÆæÁΩÆÁõëÂê¨
      if (this.allowDragOutside && this.dragOutsideConfig.enabled) {
        this.dragOutsideMonitoring = {
          enabled: true,
          task: bar.task,
          expansionCount: 0
        }
      }

      setTimeout(() => {
        this.dragState = {
          bar,
          startX: event.clientX,
          startLeft: bar.left,
          originalStartDate: moment(bar.task.startDate),
          originalEndDate: moment(bar.task.endDate),
          isParentNode: bar.task.isParentNode, // Ê†áËÆ∞ÊòØÂê¶‰∏∫Áà∂Á∫ßËäÇÁÇπ
          // Áà∂ËäÇÁÇπÊãñÊãΩ‰ºòÂåñÂèÇÊï∞
          lastUpdateTime: Date.now(),
          lastDaysDelta: 0,
          dragStartTime: Date.now(), // ËÆ∞ÂΩïÊãñÊãΩÂºÄÂßãÊó∂Èó¥
          dragVelocity: 0, // ËÆ∞ÂΩïÊãñÊãΩÈÄüÂ∫¶
          lastX: event.clientX, // ËÆ∞ÂΩï‰∏ä‰∏ÄÊ¨°Èº†Ê†á‰ΩçÁΩÆ
          smoothingFactor: 0.3 // Âπ≥ÊªëÂõ†Â≠êÔºåÂÄºË∂äÂ∞èÁßªÂä®Ë∂äÂπ≥Êªë
        }
        this.clearDependencyCache()

        console.log('[Ë∞ÉËØï] dragState Â∑≤ËÆæÁΩÆ', this.dragState)
      }, 0)

      this.internalShowDependencyLines = false; // ÊãñÊãΩÊó∂ÈöêËóè‰æùËµñÁ∫ø
    },

    // Ëé∑Âèñ‰ªªÂä°ÁöÑÊâÄÊúâÂ≠ê‰ªªÂä°IDÔºàÈÄíÂΩíÔºâ
    getAllChildTaskIds(taskId) {
      const childIds = []

      const findChildren = (tasks, parentId) => {
        for (const task of tasks) {
          if (task.id === parentId) {
            if (task.children && task.children.length > 0) {
              task.children.forEach(child => {
                childIds.push(child.id)
                // ÈÄíÂΩíÊü•ÊâæÂ≠êËäÇÁÇπÁöÑÂ≠êËäÇÁÇπ
                findChildren(tasks, child.id)
              })
            }
            return true
          }

          if (task.children && task.children.length > 0) {
            if (findChildren(task.children, parentId)) {
              return true
            }
          }
        }
        return false
      }

      findChildren(this.tasks, taskId)
      return childIds
    },

    // ÊäòÂè†/Â±ïÂºÄ‰ªªÂä°
    toggleTaskCollapse(taskId) {
      // Ë∞ÉÁî®storeÁöÑÊäòÂè†/Â±ïÂºÄÂä®‰Ωú
      this.$store.dispatch('toggleTaskCollapsed', taskId)

      // Êõ¥Êñ∞Áà∂ËäÇÁÇπÊåáÁ§∫Âô®ÁöÑÊòæÁ§∫
      this.$nextTick(() => {
        this.updateParentIndicators()
      })
    },

    // Êõ¥Êñ∞Áà∂ËäÇÁÇπÊåáÁ§∫Âô®ÁöÑÊòæÁ§∫ÔºàÂ∑≤ÁÆÄÂåñÔºå‰∫ã‰ª∂ÁªëÂÆöÁé∞Âú®Áõ¥Êé•Âú®Ê®°Êùø‰∏≠Â§ÑÁêÜÔºâ
    updateParentIndicators() {
      // Áî±‰∫é‰∫ã‰ª∂Áé∞Âú®Áõ¥Êé•Âú®Ê®°Êùø‰∏≠ÁªëÂÆöÔºåËøô‰∏™ÊñπÊ≥ïÁé∞Âú®‰∏ªË¶ÅÁî®‰∫éÂº∫Âà∂Êõ¥Êñ∞
      this.$forceUpdate()
    },

    startResize(bar, direction, event) {
      // ÈòªÊ≠¢Áà∂ËäÇÁÇπÁöÑÂ§ßÂ∞èË∞ÉÊï¥
      if (bar.task.isParentNode) {
        return
      }

      // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°ÂíåÈªòËÆ§Ë°å‰∏∫
      event.stopPropagation()
      event.preventDefault()

      // ËÆæÁΩÆÊ†áÂøóÔºåÈòªÊ≠¢‰∏ã‰∏ÄÊ¨°ÁÇπÂáª‰∫ã‰ª∂
      this.preventNextBarClick = true

      this.resizeState = {
        bar,
        direction,
        startX: event.clientX,
        startLeft: bar.left,
        startWidth: bar.width,
        originalStartDate: moment(bar.task.startDate),
        originalEndDate: moment(bar.task.endDate)
      }

      // Ê∑ªÂä†Ë∞ÉÊï¥Â§ßÂ∞èÊó∂ÁöÑÊ†∑ÂºèÁ±ª
      const barElement = event.target.closest('.gantt-bar')
      if (barElement) {
        barElement.classList.add('resizing')
      }

      // Ë∞ÉÊï¥ÂºÄÂßãÂêéÊ∏ÖÈô§ÁºìÂ≠ò
      this.clearDependencyCache()
    },

    startConnection(bar, point, event) {
      this.connectionState = {
        fromBar: bar,
        fromPoint: point,
        startX: event.clientX,
        startY: event.clientY
      }

      // ÊòæÁ§∫ËøûÊé•ÊèêÁ§∫
      if (!this.$el || typeof this.$el.getBoundingClientRect !== 'function') {
        console.warn('startConnection: ÁªÑ‰ª∂Êú™Ê≠£Á°ÆÊåÇËΩΩÊàñ$elÊó†Êïà')
        return
      }

      const rect = this.$el.getBoundingClientRect()
      this.connectionHint = {
        visible: true,
        x: event.clientX - rect.left + this.scrollLeft,
        y: event.clientY - rect.top - 30,
        text: 'Drag to another task to create connection'
      }

      // ËøûÊé•ÂºÄÂßãÂêéÊ∏ÖÈô§ÁºìÂ≠ò
      this.clearDependencyCache()
      event.preventDefault()
      this.internalShowDependencyLines = false; // ËøûÁ∫øÊó∂ÈöêËóè‰æùËµñÁ∫ø
    },

    handleConnectionHover(bar, point) {
      if (this.connectionState &&
          this.connectionState.fromBar.task.id !== bar.task.id) {
        // ÂΩìÊãñÊãΩÂà∞ÊúâÊïàÁõÆÊ†áÊó∂ÊòæÁ§∫ÊèêÁ§∫
        this.connectionHint.text = `Release to connect to "${bar.task.name}"`
      }
    },

    handleConnectionLeave() {
      if (this.connectionState) {
        this.connectionHint.text = 'Drag to another task to create connection'
      }
    },

    handleMouseMove(event) {
      // ÁÆÄÂåñRAF‰ºòÂåñÔºåÁ°Æ‰øù‰∏çÈòªÂ°ûÊ≠£Â∏∏‰∫ã‰ª∂Â§ÑÁêÜ
      if (this.dragState) {
        this.handleDragMove(event)
      } else if (this.resizeState) {
        this.handleResizeMove(event)
      } else if (this.connectionState) {
        this.handleConnectionMove(event)
      } else if (this.progressDragState) {
        this.handleProgressDragMove(event)
      }
    },

    handleDragMove(event) {
      if (this.dragPreventedByDblClick) {
        return;
      }
      if (!this.dragState) {
        return
      }

      // ÁÆÄÂçïÁöÑËäÇÊµÅÔºöË∑≥ËøáÈáçÂ§çÁöÑÈº†Ê†á‰ΩçÁΩÆ
      if (this.dragState.lastMouseX === event.clientX) {
        return
      }
      this.dragState.lastMouseX = event.clientX

      const deltaX = event.clientX - this.dragState.startX
      const newLeft = this.dragState.startLeft + deltaX
      const newStartDate = this.getPositionDate(newLeft)
      const duration = this.dragState.originalEndDate.diff(this.dragState.originalStartDate, 'days')
      const newEndDate = newStartDate.clone().add(duration, 'days')
      const daysDelta = newStartDate.diff(this.dragState.originalStartDate, 'days')

      // ÁÆÄÂåñÊãñÊãΩÈÄªËæëÔºåÁõ¥Êé•Êõ¥Êñ∞Êó†Âª∂Ëøü
      this.pendingUpdates = {
        id: this.dragState.bar.task.id,
        updates: {
          startDate: newStartDate.format('YYYY-MM-DD'),
          endDate: newEndDate.format('YYYY-MM-DD')
        },
        isParentNode: this.dragState.isParentNode,
        daysDelta
      }

      // ‰ºòÂåñÊãñÊãΩË∂ÖÂá∫ÂèØËßÜËåÉÂõ¥ÁöÑÂ§ÑÁêÜ
      // Ëé∑ÂèñÁà∂ÊªöÂä®ÂÆπÂô®
      const scrollContainer = this._ganttScrollContainer
      if (scrollContainer) {
        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅËá™Âä®ÊªöÂä®
        const containerRect = scrollContainer.getBoundingClientRect()
        const mouseX = event.clientX
        const scrollMargin = 80 // Â¢ûÂä†ËæπÁºòÊ£ÄÊµãËåÉÂõ¥ÔºåÊõ¥Êó©ÂºÄÂßãÊªöÂä®

        // ËÆ∞ÂΩïÂΩìÂâçÊãñÊãΩÊñπÂêë
        if (!this.dragState.lastMouseX) {
          this.dragState.lastMouseX = mouseX
        }
        const dragDirection = mouseX < this.dragState.lastMouseX ? 'left' : 'right'
        this.dragState.lastMouseX = mouseX

        // Â¶ÇÊûúÈº†Ê†áÊé•ËøëÂ∑¶ËæπÁºòÊàñÂêëÂ∑¶ÊãñÊãΩÊó∂Ë∂ÖÂá∫Â∑¶ËæπÁºòÔºåÂêëÂ∑¶ÊªöÂä®
        if (mouseX < containerRect.left + scrollMargin ||
            (dragDirection === 'left' && mouseX < containerRect.left + containerRect.width * 0.3)) {
          // Âü∫Á°ÄÊªöÂä®ÈÄüÂ∫¶
          let scrollSpeed = Math.max(15, (scrollMargin - (mouseX - containerRect.left)) / 1)

          // Â¶ÇÊûúÈº†Ê†áÂ∑≤ÁªèË∂ÖÂá∫Â∑¶ËæπÁºòÊàñÊé•ËøëÂ∑¶ËæπÁºòÔºåÂä†ÈÄüÊªöÂä®
          if (mouseX <= containerRect.left + 20) {
            // Èº†Ê†áÂ∑≤ÁªèË∂ÖÂá∫ÊàñÊé•ËøëÂ∑¶ËæπÁºòÔºåÂ§ßÂπÖÂä†ÈÄüÊªöÂä®
            scrollSpeed = Math.max(scrollSpeed, 40)
          }

          // Â∫îÁî®ÊªöÂä®
          scrollContainer.scrollLeft = Math.max(0, scrollContainer.scrollLeft - scrollSpeed)
          this.scrollLeft = scrollContainer.scrollLeft

          // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊªöÂä®Âà∞ÊúÄÂ∑¶‰æßÔºåÂ¶ÇÊûúÊòØÂàôÈúÄË¶ÅÂä®ÊÄÅÂπ≥ÁßªËßÜÂõæ
          if (scrollContainer.scrollLeft <= 0 && dragDirection === 'left') {
            // ËÆ°ÁÆóÈúÄË¶ÅÁöÑÂπ≥ÁßªÈáè
            const panAmount = Math.min(50, Math.max(10, scrollSpeed / 2))

            // Ëß¶ÂèëËßÜÂõæÂπ≥Áßª‰∫ã‰ª∂ÔºåÈÄöÁü•Áà∂ÁªÑ‰ª∂Êõ¥Êñ∞panOffsetÂíåÊó∂Èó¥ËΩ¥
            this.$emit('request-pan', {
              direction: 'right', // ÂêëÂè≥Âπ≥ÁßªËßÜÂõæÔºå‰ΩøÂÜÖÂÆπÂêëÂ∑¶ÁßªÂä®
              amount: panAmount,
              updateTimeline: true, // ÂëäÁü•Áà∂ÁªÑ‰ª∂ÈúÄË¶ÅÊõ¥Êñ∞Êó∂Èó¥ËΩ¥
              extendLeft: true // ÊåáÁ§∫ÈúÄË¶ÅÂêëÂ∑¶Êâ©Â±ïÊó∂Èó¥ËΩ¥
            })

            // Êõ¥Êñ∞ÊãñÊãΩÁä∂ÊÄÅÔºåË∞ÉÊï¥‰ΩçÁΩÆ‰ª•‰øùÊåÅÊãñÊãΩÁöÑËøûÁª≠ÊÄß
            if (this.dragState) {
              this.dragState.startX -= panAmount
              if (this.dragState.lastClientX) {
                this.dragState.lastClientX -= panAmount
              }
            }

            // ÈÄöÁü•Áà∂ÁªÑ‰ª∂Êõ¥Êñ∞ÁîòÁâπÂõæÂÆΩÂ∫¶
            this.$emit('update-chart-width', {
              direction: 'left',
              amount: panAmount
            })
          }

          // Âº∫Âà∂Êõ¥Êñ∞ËßÜÂõæÔºåÁ°Æ‰øùÊãñÊãΩÂÖÉÁ¥†‰ΩçÁΩÆÊ≠£Á°Æ
          this.$forceUpdate()
        }
        // Â¶ÇÊûúÈº†Ê†áÊé•ËøëÂè≥ËæπÁºòÊàñÂêëÂè≥ÊãñÊãΩÊó∂Ë∂ÖÂá∫Âè≥ËæπÁºòÔºåÂêëÂè≥ÊªöÂä®
        else if (mouseX > containerRect.right - scrollMargin ||
                (dragDirection === 'right' && mouseX > containerRect.right - containerRect.width * 0.3)) {
          // Âü∫Á°ÄÊªöÂä®ÈÄüÂ∫¶
          let scrollSpeed = Math.max(15, (mouseX - (containerRect.right - scrollMargin)) / 1)

          // Â¶ÇÊûúÈº†Ê†áÂ∑≤ÁªèË∂ÖÂá∫Âè≥ËæπÁºòÊàñÊé•ËøëÂè≥ËæπÁºòÔºåÂä†ÈÄüÊªöÂä®
          if (mouseX >= containerRect.right - 20) {
            // Èº†Ê†áÂ∑≤ÁªèË∂ÖÂá∫ÊàñÊé•ËøëÂè≥ËæπÁºòÔºåÂ§ßÂπÖÂä†ÈÄüÊªöÂä®
            scrollSpeed = Math.max(scrollSpeed, 40)
          }

          // Â∫îÁî®ÊªöÂä®
          scrollContainer.scrollLeft += scrollSpeed
          this.scrollLeft = scrollContainer.scrollLeft

          // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂêëÂè≥Êâ©Â±ïËßÜÂõæ
          const maxScroll = scrollContainer.scrollWidth - scrollContainer.clientWidth
          if (scrollContainer.scrollLeft >= maxScroll - 50 && dragDirection === 'right') {
            // Ëß¶ÂèëËßÜÂõæÂπ≥Áßª‰∫ã‰ª∂ÔºåÈÄöÁü•Áà∂ÁªÑ‰ª∂Êõ¥Êñ∞Êó∂Èó¥ËΩ¥
            this.$emit('request-pan', {
              direction: 'right',
              amount: 0, // ‰∏çÈúÄË¶ÅÂπ≥ÁßªÔºåÂè™ÈúÄË¶ÅÊâ©Â±ï
              updateTimeline: true,
              extendRight: true // ÊåáÁ§∫ÈúÄË¶ÅÂêëÂè≥Êâ©Â±ïÊó∂Èó¥ËΩ¥
            })

            // ÈÄöÁü•Áà∂ÁªÑ‰ª∂Êõ¥Êñ∞ÁîòÁâπÂõæÂÆΩÂ∫¶
            this.$emit('update-chart-width', {
              direction: 'right',
              amount: scrollSpeed
            })
          }

          // Ê£ÄÊü•ÊòØÂê¶ÊãñÊãΩÂà∞Â§ñÈÉ®Âπ∂Ëß¶ÂèëÊâ©Â±ï
          if (this.dragOutsideMonitoring.enabled) {
            this.checkDragOutside(event, 'right')
          }

          // Âº∫Âà∂Êõ¥Êñ∞ËßÜÂõæÔºåÁ°Æ‰øùÊãñÊãΩÂÖÉÁ¥†‰ΩçÁΩÆÊ≠£Á°Æ
          this.$forceUpdate()
        }
      }

      // ÂèëÈÄÅÊï∞ÊçÆÊõ¥Êñ∞‰∫ã‰ª∂ÔºåÊ∑ªÂä†linkParentChildDatesÈÖçÁΩÆ
      if (this.pendingUpdates) {
        this.$emit('bar-drag', {
          ...this.pendingUpdates,
          linkParentChildDates: this.linkParentChildDates // ‰º†ÈÄíÁà∂Â≠êËäÇÁÇπÊó∂Èó¥ÂÖ≥ËÅîÈÖçÁΩÆ
        })
        this.pendingUpdates = null
      }
    },

    handleResizeMove(event) {
      if (!this.resizeState) {
        return
      }

      const deltaX = event.clientX - this.resizeState.startX
      const minWidth = 60 // ÊúÄÂ∞èÂÆΩÂ∫¶ÈôêÂà∂

      let updates = null

      if (this.resizeState.direction === 'left') {
        const newLeft = this.resizeState.startLeft + deltaX
        const maxLeft = this.resizeState.startLeft + this.resizeState.startWidth - minWidth
        const constrainedLeft = Math.min(newLeft, maxLeft)
        const newStartDate = this.getPositionDate(constrainedLeft)

        updates = {
          id: this.resizeState.bar.task.id,
          updates: {
            startDate: newStartDate.format('YYYY-MM-DD')
          }
        }
      } else {
        const newWidth = this.resizeState.startWidth + deltaX
        const constrainedWidth = Math.max(newWidth, minWidth)
        const newEndPosition = this.resizeState.startLeft + constrainedWidth
        const newEndDate = this.getPositionDate(newEndPosition)

        updates = {
          id: this.resizeState.bar.task.id,
          updates: {
            endDate: newEndDate.format('YYYY-MM-DD')
          }
        }
      }

      if (updates) {
        this.pendingUpdates = updates

        // ‰ºòÂåñÊãñÊãΩË∂ÖÂá∫ÂèØËßÜËåÉÂõ¥ÁöÑÂ§ÑÁêÜ
        const scrollContainer = this._ganttScrollContainer
        if (scrollContainer) {
          // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅËá™Âä®ÊªöÂä®
          const containerRect = scrollContainer.getBoundingClientRect()
          const mouseX = event.clientX
          const scrollMargin = 50 // Ë∑ùÁ¶ªËæπÁºòÂ§öÂ∞ëÂÉèÁ¥†ÂºÄÂßãÊªöÂä®

          // Â¶ÇÊûúÈº†Ê†áÊé•ËøëÂè≥ËæπÁºòÔºåÂêëÂè≥ÊªöÂä®
          if (mouseX > containerRect.right - scrollMargin) {
            const scrollSpeed = Math.max(5, (mouseX - (containerRect.right - scrollMargin)) / 2)
            scrollContainer.scrollLeft += scrollSpeed
            this.scrollLeft = scrollContainer.scrollLeft
          }
        }

        // Á´ãÂç≥Êõ¥Êñ∞Ôºå‰∏ç‰ΩøÁî®Âä®Áîª
        this.clearDependencyCache()
        this.$forceUpdate()

        // ÂèëÈÄÅresizeÊõ¥Êñ∞‰∫ã‰ª∂ÔºåÊ∑ªÂä†linkParentChildDatesÈÖçÁΩÆ
        if (this.pendingUpdates) {
          this.$emit('bar-resize', {
            ...this.pendingUpdates,
            linkParentChildDates: this.linkParentChildDates // ‰º†ÈÄíÁà∂Â≠êËäÇÁÇπÊó∂Èó¥ÂÖ≥ËÅîÈÖçÁΩÆ
          })
          this.pendingUpdates = null
        }
      }
    },

    handleConnectionMove(event) {
      if (!this.connectionState) {
        return
      }
      // Èò≤Ê≠¢undefinedÈîôËØØÔºöÂÆâÂÖ®Ê£ÄÊü•eventÂíåthis.$el
      if (!event || !this.$el) {
        console.warn('handleConnectionMove: eventÊàñ$elÊó†Êïà')
        return
      }
      // Ëé∑ÂèñSVGÂÆπÂô®ÔºàÈ¢ÑËßàËøûÁ∫øÊâÄÂú®SVGÔºâÁöÑrect
      const svgPreview = this.$el && typeof this.$el.querySelector === 'function' ?
        this.$el.querySelector('.gantt-connection-preview') : null
      const svgRect = svgPreview ? svgPreview.getBoundingClientRect() : this.$el.getBoundingClientRect()
      // Èº†Ê†áÂú®SVGÂÆπÂô®ÂÜÖÁöÑÂùêÊ†á
      const mouseX = event.clientX - svgRect.left
      const mouseY = event.clientY - svgRect.top
      const {fromBar} = this.connectionState
      if (!fromBar) {
        console.warn('handleConnectionMove: fromBarÊó†Êïà')
        return
      }
      // ËÆ°ÁÆóËµ∑ÂßãËøûÊé•ÁÇπ‰ΩçÁΩÆÔºàÂêåÊ†∑‰ª•SVGÂÆπÂô®‰∏∫Âü∫ÂáÜÔºâ
      let startX, startY
      const elRect = this.$el.getBoundingClientRect()
      if (this.connectionState.fromPoint === 'start') {
        startX = fromBar.left - (elRect.left - svgRect.left) - 16 // ‰∏éËøûÊé•ÁÇπ‰ΩçÁΩÆ‰øùÊåÅ‰∏ÄËá¥
        startY = fromBar.index * 28 + 14 // ‰øÆÂ§çËøûÁ∫øËµ∑ÂßãYÂùêÊ†á
      } else {
        startX = fromBar.left + fromBar.width - (elRect.left - svgRect.left) + 16 // ‰∏éËøûÊé•ÁÇπ‰ΩçÁΩÆ‰øùÊåÅ‰∏ÄËá¥
        startY = fromBar.index * 28 + 14 // ‰øÆÂ§çËøûÁ∫øËµ∑ÂßãYÂùêÊ†á
      }
      // Âà§Êñ≠Èº†Ê†áÊòØÂê¶ÊÇ¨ÂÅúÂú®ÊúâÊïàÁõÆÊ†áËäÇÁÇπ‰∏ä
      let endX = mouseX
      let endY = mouseY
      const targetElement = document.elementFromPoint(event.clientX, event.clientY)
      if (targetElement && targetElement.classList.contains('gantt-bar')) {
        // Ëé∑ÂèñÁõÆÊ†áËäÇÁÇπ‰∏≠ÂøÉÁÇπÁöÑÂ±èÂπïÂùêÊ†á
        const barRect = targetElement.getBoundingClientRect()
        const barCenterX = (barRect.left + barRect.right) / 2
        const barCenterY = (barRect.top + barRect.bottom) / 2
        // Êç¢ÁÆó‰∏∫SVGÂÆπÂô®ÂÜÖÂùêÊ†á
        endX = barCenterX - svgRect.left
        endY = barCenterY - svgRect.top
      }
      // ËÆæÁΩÆËøûÊé•È¢ÑËßàÔºà‰ª•SVGÂÆπÂô®‰∏∫Âü∫ÂáÜÁöÑÂùêÊ†áÔºâ
      this.connectionPreview = {
        startX,
        startY,
        endX,
        endY
      }
      // Êõ¥Êñ∞ËøûÊé•ÊèêÁ§∫‰ΩçÁΩÆÔºà‰ΩøÁî®SVGÂÜÖÂùêÊ†áÔºâ
      this.connectionHint.x = mouseX + 10
      this.connectionHint.y = mouseY - 30
      this.connectionHint.visible = true
      // ËøûÁ∫øÂùêÊ†áËÆ°ÁÆóÂÆåÊàê - ÂΩªÂ∫ïÊ∂àÈô§ÊªöÂä®/ÂÅèÁßªÂΩ±Âìç
    },

    handleMouseUp(event) {
      if (this.connectionState) {
        // Ê£ÄÊü•ÊòØÂê¶ÈáäÊîæÂú®Âè¶‰∏Ä‰∏™‰ªªÂä°Êù°‰∏ä
        const targetElement = document.elementFromPoint(event.clientX, event.clientY)
        const targetBar = this.findBarFromElement(targetElement)

        if (targetBar && targetBar.task.id !== this.connectionState.fromBar.task.id) {
          // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåËøûÊé•
          const exists = this.dependencies.find(dep =>
            dep.from === this.connectionState.fromBar.task.id &&
            dep.to === targetBar.task.id
          )

          if (!exists) {
            // Á°ÆÂÆöËøûÊé•Âà∞ÁõÆÊ†á‰ªªÂä°ÁöÑÂì™‰∏™ÁÇπ
            const targetPoint = this.getTargetConnectionPoint(event, targetBar)

            // Ê†πÊçÆËøûÊé•ÁÇπÁ±ªÂûãÁ°ÆÂÆö‰æùËµñÁ±ªÂûã
            const dependencyType = this.getDependencyTypeFromPoints(
              this.connectionState.fromPoint,
              targetPoint
            )

            // ÊùæÊâãÂêéÂàõÂª∫ÁúüÊ≠£ÁöÑËøûÊé•Á∫ø - ÂåÖÂê´‰æùËµñÁ±ªÂûã‰ø°ÊÅØ
            this.addDependency({
              from: this.connectionState.fromBar.task.id,
              to: targetBar.task.id,
              type: dependencyType,
              lag: 0,
              color: this.getRandomColor()
            })

            console.log('[Ë∞ÉËØï] ‰æùËµñÂÖ≥Á≥ªÂàõÂª∫', {
              from: this.connectionState.fromBar.task.name,
              to: targetBar.task.name,
              fromPoint: this.connectionState.fromPoint,
              toPoint: targetPoint,
              type: dependencyType
            })
          }
        }

        // Ê∏ÖÁêÜËøûÊé•È¢ÑËßà
        this.connectionPreview = null
        this.connectionHint.visible = false
      }

      // Áà∂ËäÇÁÇπÊãñÊãΩÁªìÊùüÊó∂ÁöÑÁâπÊÆäÂ§ÑÁêÜ
      if (this.dragState && this.dragState.isParentNode) {
        console.log(`Áà∂ËäÇÁÇπÊãñÊãΩÁªìÊùü: ${this.dragState.bar.task.name}`)

        // ÊúÄÂêé‰∏ÄÊ¨°ÂèëÈÄÅÊõ¥Êñ∞ÔºåÁ°Æ‰øùÊâÄÊúâÊõ¥ÊîπÈÉΩË¢´‰øùÂ≠ò
        if (this.pendingUpdates) {
          this.$emit('bar-drag', {
            ...this.pendingUpdates,
            linkParentChildDates: this.linkParentChildDates // ‰º†ÈÄíÁà∂Â≠êËäÇÁÇπÊó∂Èó¥ÂÖ≥ËÅîÈÖçÁΩÆ
          })
          this.pendingUpdates = null
        }
      }

      // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÁ∫ßËÅîÊõ¥Êñ∞ÔºàÂú®Ê∏ÖÁêÜÊãñÊãΩÁä∂ÊÄÅ‰πãÂâçÔºâ
      if (this.dragState || this.resizeState) {
        const draggedTask = this.dragState?.bar?.task || this.resizeState?.bar?.task;
        if (draggedTask) {
          // Ëé∑ÂèñÊãñÊãΩÂâçÁöÑÊó∂Èó¥Êï∞ÊçÆ
          const originalStart = this.dragState?.originalStartDate?.format('YYYY-MM-DD') || this.resizeState?.originalStartDate?.format('YYYY-MM-DD');
          const originalEnd = this.dragState?.originalEndDate?.format('YYYY-MM-DD') || this.resizeState?.originalEndDate?.format('YYYY-MM-DD');

          // Ëé∑ÂèñÂΩìÂâç‰ªªÂä°ÁöÑÊúÄÊñ∞Êó∂Èó¥Êï∞ÊçÆ
          // ‰ªéstore‰∏≠Ëé∑ÂèñÊúÄÊñ∞ÁöÑ‰ªªÂä°Êï∞ÊçÆÔºåÁ°Æ‰øùËé∑ÂèñÂà∞ÊãñÊãΩÂêéÁöÑÊó∂Èó¥
          const currentTask = this.$store.getters.getTaskById(draggedTask.id);
          const currentStart = currentTask ? currentTask.startDate : draggedTask.startDate;
          const currentEnd = currentTask ? currentTask.endDate : draggedTask.endDate;

          console.log(`[ÊãñÊãΩÁ∫ßËÅîÊõ¥Êñ∞] Ê£ÄÊü•‰ªªÂä° ${draggedTask.id} Êó∂Èó¥ÂèòÂåñ:`, {
            originalStart,
            originalEnd,
            currentStart,
            currentEnd,
            hasDragState: !!this.dragState,
            hasResizeState: !!this.resizeState,
            currentTask: currentTask ? 'found' : 'not found'
          });

          // Ê£ÄÊü•Êó∂Èó¥ÊòØÂê¶ÂèëÁîü‰∫ÜÂèòÂåñ
          if (originalStart && originalEnd &&
              (originalStart !== currentStart || originalEnd !== currentEnd)) {
            console.log(`[ÊãñÊãΩÁ∫ßËÅîÊõ¥Êñ∞] Ê£ÄÊµãÂà∞‰ªªÂä° ${draggedTask.id} Êó∂Èó¥ÂèòÂåñÔºåËß¶ÂèëÁ∫ßËÅîÊõ¥Êñ∞Ê£ÄÊü•`);

            // ‰ΩøÁî®Áªü‰∏ÄÁöÑ‰ªªÂä°Êó∂Èó¥ÂèòÊõ¥Â§ÑÁêÜ
            this.$store.dispatch('handleTaskTimeChange', {
              taskId: draggedTask.id,
              newStartDate: currentStart,
              newEndDate: currentEnd,
              source: this.dragState ? 'drag' : 'resize'
            });
          } else {
            console.log(`[ÊãñÊãΩÁ∫ßËÅîÊõ¥Êñ∞] ‰ªªÂä° ${draggedTask.id} Êó∂Èó¥Êú™ÂèëÁîüÂèòÂåñÔºåË∑≥ËøáÁ∫ßËÅîÊõ¥Êñ∞Ê£ÄÊü•`);
          }
        } else {
          console.log(`[ÊãñÊãΩÁ∫ßËÅîÊõ¥Êñ∞] Êú™ÊâæÂà∞ÊãñÊãΩÁöÑ‰ªªÂä°ÂØπË±°`);
        }
      } else {
        console.log(`[ÊãñÊãΩÁ∫ßËÅîÊõ¥Êñ∞] Ê≤°ÊúâÊãñÊãΩÊàñË∞ÉÊï¥Áä∂ÊÄÅ`);
      }

      // ÈÄöÁü•Áà∂ÁªÑ‰ª∂ÊãñÊãΩÁªìÊùüÔºåÊÅ¢Â§çËÉåÊôØ‰∫§‰∫í
      this.$emit('node-drag-end');

      // Âº∫Âà∂Ê∏ÖÁêÜÊâÄÊúâÁä∂ÊÄÅÔºåÁ°Æ‰øùÊãñÊãΩËÉΩÂ§üÊ≠£Á°ÆÁªìÊùü
      this.forceClearDragState();

      // Êìç‰ΩúÁªìÊùüÂêéÊ∏ÖÈô§ÁºìÂ≠òÔºåËÆ©‰æùËµñÁ∫øÈáçÊñ∞ËÆ°ÁÆó
      this.clearDependencyCache();

      // Ê∏ÖÈô§ÈöêËóè‰æùËµñÁ∫øÁöÑÊ†áËÆ∞
      this.hidingTaskId = null;
      this.hidingTaskIds = []; // Ê∏ÖÈô§Â≠ê‰ªªÂä°IDÂàóË°®
      this.temporarilyHideDependencies = false;

      // ÁßªÈô§Áà∂ËäÇÁÇπÊãñÊãΩÁöÑËßÜËßâÊïàÊûú
      if (this.$el && typeof this.$el.querySelectorAll === 'function') {
        const parentDraggingElements = this.$el.querySelectorAll('.parent-dragging-active');
        parentDraggingElements.forEach(element => {
          element.classList.remove('parent-dragging-active');
        });
      }

      // ÊãñÊãΩÁªìÊùüÂêéÊÅ¢Â§çË°ÄÁºòÈ´ò‰∫Æ
      if (this._preDragLineageSource && (this._isSourceNodeDragging || this._isLineageNodeDragging)) {
        // Âª∂Ëøü‰∏ÄÁÇπÁÇπÂÜçÊÅ¢Â§çÈ´ò‰∫ÆÔºåÁ°Æ‰øùUIÂÖàÊõ¥Êñ∞
        setTimeout(() => {
          this.$store.dispatch('setLineageHighlight', this._preDragLineageSource);
          console.log('[Ë∞ÉËØï] ÊãñÊãΩÁªìÊùüÊÅ¢Â§çÈ´ò‰∫Æ', this._preDragLineageSource);
          this._preDragLineageSource = null;
          this._isSourceNodeDragging = false;
          this._isLineageNodeDragging = false;
        }, 50);
      }
      this.internalShowDependencyLines = true; // ÊãñÊãΩÁªìÊùüÂêéÊÅ¢Â§ç‰æùËµñÁ∫ø
    },

    // Âº∫Âà∂Ê∏ÖÁêÜÊãñÊãΩÁä∂ÊÄÅÔºåÈò≤Ê≠¢"ÂÅú‰∏ç‰∏ãÊù•"
    forceClearDragState() {
      this.dragState = null
      this.resizeState = null
      this.connectionState = null
      this.progressDragState = null
      this.pendingUpdates = null
      this.hidingTaskId = null

      // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øùÁªÑ‰ª∂Â∑≤ÊåÇËΩΩ‰∏î$elÊòØÊúâÊïàÁöÑDOMÂÖÉÁ¥†
      if (!this.$el || typeof this.$el.querySelectorAll !== 'function') {
        console.warn('forceClearDragState: ÁªÑ‰ª∂Êú™Ê≠£Á°ÆÊåÇËΩΩÊàñ$elÊó†Êïà')
        return
      }

      // Ê∏ÖÁêÜÊâÄÊúâÊãñÊãΩÁä∂ÊÄÅÁöÑCSSÁ±ª
      const progressDraggingElements = this.$el.querySelectorAll('.progress-dragging')
      progressDraggingElements.forEach(element => {
        element.classList.remove('progress-dragging')
      })

      // ÈáçÁΩÆËøõÂ∫¶ÊãñÊãΩÊâãÊüÑÊ†∑Âºè
      const progressHandles = this.$el.querySelectorAll('.gantt-progress-handle-container')
      progressHandles.forEach(handle => {
        handle.style.transform = ''
        handle.style.opacity = ''
      })



      if (this.updateThrottle) {
        cancelAnimationFrame(this.updateThrottle)
        this.updateThrottle = null
      }
      if (this.resizeThrottle) {
        cancelAnimationFrame(this.resizeThrottle)
        this.resizeThrottle = null
      }
      if (this.rafId) {
        cancelAnimationFrame(this.rafId)
        this.rafId = null
      }

      // Ê∏ÖÁêÜÊãñÊãΩÂ§ñÈÉ®ÁõëÂê¨Áä∂ÊÄÅ
      this.dragOutsideMonitoring = {
        enabled: false,
        task: null,
        expansionCount: 0,
        lastDirection: null
      }

      console.log('ÊãñÊãΩÁä∂ÊÄÅÂ∑≤Âº∫Âà∂Ê∏ÖÁêÜ')
    },

    // Ê£ÄÊü•ÊãñÊãΩÊòØÂê¶Âà∞Â§ñÈÉ®Âå∫Âüü
    checkDragOutside(event, direction) {
      if (!this.dragOutsideMonitoring.enabled || !this.dragOutsideMonitoring.task) {
        return
      }

      // Ëé∑ÂèñÂÆπÂô®ËæπÁïå
      const scrollContainer = this._ganttScrollContainer
      if (!scrollContainer) return

      const containerRect = scrollContainer.getBoundingClientRect()
      const mouseX = event.clientX
      const threshold = 50 // Ëß¶ÂèëÊâ©Â±ïÁöÑËæπÁïåË∑ùÁ¶ª

      let shouldExpand = false
      let expandDirection = direction

      // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖÂá∫ËæπÁïå
      if (direction === 'left' && mouseX < containerRect.left + threshold) {
        shouldExpand = true
        expandDirection = 'left'
      } else if (direction === 'right' && mouseX > containerRect.right - threshold) {
        shouldExpand = true
        expandDirection = 'right'
      }

      // Èò≤Ê≠¢È¢ëÁπÅÊâ©Â±ï
      if (shouldExpand &&
          this.dragOutsideMonitoring.lastDirection !== expandDirection &&
          this.dragOutsideMonitoring.expansionCount < this.dragOutsideConfig.maxExpansions) {

        // ËÆ°ÁÆóÊãñÊãΩË∑ùÁ¶ª
        const distance = direction === 'left'
          ? containerRect.left - mouseX
          : mouseX - containerRect.right

        // Ëß¶ÂèëÊâ©Â±ï‰∫ã‰ª∂
        this.$emit('node-drag-outside', {
          direction: expandDirection,
          distance: Math.max(0, distance),
          task: this.dragOutsideMonitoring.task
        })

        // Êõ¥Êñ∞ÁõëÂê¨Áä∂ÊÄÅ
        this.dragOutsideMonitoring.lastDirection = expandDirection
        this.dragOutsideMonitoring.expansionCount++

        console.log(`[ÊãñÊãΩÊâ©Â±ï] Ëß¶Âèë${expandDirection}Êâ©Â±ï, Ë∑ùÁ¶ª: ${distance}px, Êâ©Â±ïÊ¨°Êï∞: ${this.dragOutsideMonitoring.expansionCount}`)
      }
    },

    findBarFromElement(element) {
      let current = element
      while (current) {
        if (current.classList && current.classList.contains('gantt-bar-container')) {
          // ÈÄöËøádata-task-idÂ±ûÊÄßÊâæÂà∞ÂØπÂ∫îÁöÑ‰ªªÂä°Êù°
          const taskId = current.getAttribute('data-task-id')
          if (taskId) {
            return this.taskBars.find(bar => bar.task.id.toString() === taskId)
          }
        }
        current = current.parentElement
      }
      return null
    },

    // Á°ÆÂÆöÁõÆÊ†áËøûÊé•ÁÇπÁ±ªÂûã
    getTargetConnectionPoint(event, targetBar) {
      // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øùÁªÑ‰ª∂Â∑≤ÊåÇËΩΩ‰∏î$elÊòØÊúâÊïàÁöÑDOMÂÖÉÁ¥†
      if (!this.$el || typeof this.$el.querySelector !== 'function') {
        console.warn('getTargetConnectionPoint: ÁªÑ‰ª∂Êú™Ê≠£Á°ÆÊåÇËΩΩÊàñ$elÊó†Êïà')
        return 'start'
      }

      // Ëé∑ÂèñÁõÆÊ†á‰ªªÂä°Êù°ÁöÑËæπÁïå
      const targetElement = this.$el.querySelector(`[data-task-id="${targetBar.task.id}"]`)
      if (!targetElement) return 'start'

      const targetRect = targetElement.getBoundingClientRect()
      const mouseX = event.clientX

      // Ê†πÊçÆÈº†Ê†á‰ΩçÁΩÆÁ°ÆÂÆöËøûÊé•Âà∞Â∑¶‰æßËøòÊòØÂè≥‰æß
      const targetCenter = (targetRect.left + targetRect.right) / 2

      return mouseX < targetCenter ? 'start' : 'end'
    },

    // Ê†πÊçÆËøûÊé•ÁÇπÁ±ªÂûãÁ°ÆÂÆö‰æùËµñÁ±ªÂûã
    getDependencyTypeFromPoints(fromPoint, toPoint) {
      // Ê†πÊçÆÊ∫êÁÇπÂíåÁõÆÊ†áÁÇπÁöÑÁªÑÂêàÁ°ÆÂÆö‰æùËµñÁ±ªÂûã
      if (fromPoint === 'end' && toPoint === 'start') {
        return 'FS' // Finish-To-Start (ÊúÄÂ∏∏ËßÅ)
      } else if (fromPoint === 'start' && toPoint === 'start') {
        return 'SS' // Start-To-Start
      } else if (fromPoint === 'end' && toPoint === 'end') {
        return 'FF' // Finish-To-Finish
      } else if (fromPoint === 'start' && toPoint === 'end') {
        return 'SF' // Start-To-Finish
      }

      // ÈªòËÆ§ËøîÂõûÊúÄÂ∏∏ËßÅÁöÑFSÁ±ªÂûã
      return 'FS'
    },

    getRandomColor() {
      return this.availableColors[Math.floor(Math.random() * this.availableColors.length)]
    },

    selectDependencyLine(line, event) {
      event.stopPropagation()
      console.log('[Ë∞ÉËØï] ËøûÁ∫øË¢´ÁÇπÂáª', line)

      // ËÆæÁΩÆÈÄâ‰∏≠ÁöÑ‰æùËµñÁ∫ø
      this.selectedDependency = { from: line.from, to: line.to }

      // ÈöêËóèÈ¢úËâ≤ÈÄâÊã©Âô®
      this.hideColorPicker()

      // Ê∏ÖÈô§‰æùËµñÁ∫øÁºìÂ≠òÔºåÂº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆóÈÄâ‰∏≠Áä∂ÊÄÅ
      this.clearDependencyCache()

      // ÂèëÂá∫ËøûÁ∫øÈÄâ‰∏≠‰∫ã‰ª∂
      this.$emit('dependency-select', line)
    },

    editDependencyLabel(line, event) {
      event.stopPropagation()
      const currentLabel = line.label || ''
      const newLabel = prompt('Enter dependency label:', currentLabel)

      if (newLabel !== null) {
        this.updateDependencyLabel({
          from: line.from,
          to: line.to,
          label: newLabel.trim()
        })
      }
    },

    deleteDependencyLine(line, event) {
      event.stopPropagation()
      if (confirm('Are you sure you want to delete this connection?')) {
        this.removeDependency({
          from: line.from,
          to: line.to
        })
        this.selectedDependency = null
      }
    },

    showColorPicker(line, event) {
      event.stopPropagation()

      // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øùÁªÑ‰ª∂Â∑≤ÊåÇËΩΩ‰∏î$elÊòØÊúâÊïàÁöÑDOMÂÖÉÁ¥†
      if (!this.$el || typeof this.$el.getBoundingClientRect !== 'function') {
        console.warn('showColorPicker: ÁªÑ‰ª∂Êú™Ê≠£Á°ÆÊåÇËΩΩÊàñ$elÊó†Êïà')
        return
      }

      const rect = this.$el.getBoundingClientRect()
      this.colorPicker = {
        visible: true,
        x: event.clientX - rect.left + this.scrollLeft,
        y: event.clientY - rect.top,
        targetLine: line
      }
    },

    hideColorPicker() {
      this.colorPicker.visible = false
      this.colorPicker.targetLine = null
    },

    changeLineColor(color) {
      if (this.colorPicker.targetLine) {
        // Êõ¥Êñ∞‰æùËµñÂÖ≥Á≥ªÁöÑÈ¢úËâ≤
        this.$store.commit('UPDATE_DEPENDENCY_COLOR', {
          from: this.colorPicker.targetLine.from,
          to: this.colorPicker.targetLine.to,
          color
        })
      }
      this.hideColorPicker()
    },

    handleComponentClick(event) {
      if (!this.selectedDependency) {
        return
      }

      const isConnectionElement = event.target.closest('.gantt-dependency-group') ||
                                event.target.closest('.gantt-link-container') ||
                                event.target.classList.contains('gantt-dependency-line-visual') ||
                                event.target.classList.contains('gantt-link-hit-area') ||
                                event.target.classList.contains('gantt-end-point-indicator') ||
                                event.target.classList.contains('gantt-link-label-text')

      if (!isConnectionElement) {
        console.log('[Ë∞ÉËØï] ÁÇπÂáªÁ©∫ÁôΩÂ§ÑÔºåÊ∏ÖÈô§ËøûÁ∫øÈÄâ‰∏≠Áä∂ÊÄÅ')
        this.selectedDependency = null
        this.clearDependencyCache() // Ëß¶ÂèëÈáçÊñ∞Ê∏≤Êüì
      }
    },

    handleGlobalClick(event) {
      // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øùÁªÑ‰ª∂Â∑≤ÊåÇËΩΩ‰∏î$elÊòØÊúâÊïàÁöÑDOMÂÖÉÁ¥†
      if (this.$el && typeof this.$el.contains === 'function' && !this.$el.contains(event.target)) {
        this.selectedDependency = null
        // Ê∏ÖÈô§ÈÄâÊã©Áä∂ÊÄÅÁî±Áà∂ÁªÑ‰ª∂Â§ÑÁêÜ
        this.$emit('task-select', null)
        this.hideColorPicker()
      }
    },

    // ÈÄâÊã©‰ªªÂä°
    selectTask(task) {
      // Â¶ÇÊûúÊòØÊãñÊãΩÊìç‰ΩúÂêéÁöÑÁÇπÂáªÔºåÂàôÂøΩÁï•
      if (this.preventNextBarClick) {
        this.preventNextBarClick = false
        return
      }

      // ÂèëÂá∫‰∫ã‰ª∂ËÆ©Áà∂ÁªÑ‰ª∂Â§ÑÁêÜÈÄâÊã©Áä∂ÊÄÅÔºåËÄå‰∏çÊòØÁõ¥Êé•‰øÆÊîπprop
      this.$emit('task-select', task)
      this.$emit('task-highlight', task.id)

      // Ê†πÊçÆÈÖçÁΩÆÂÜ≥ÂÆöÊòØÂê¶Ëß¶ÂèëË°ÄÁºòÂÖ≥Á≥ªÈ´ò‰∫Æ
      if (this.highlightTaskLineage) {
        // ÂêØÁî®Ë°ÄÁºòÂÖ≥Á≥ªÈ´ò‰∫Æ
        this.$store.dispatch('toggleLineageHighlight', task.id)
      } else if (this.$store.state.highlightedConnections?.sourceTaskId) {
        // Â¶ÇÊûúÂΩìÂâçÊúâÈ´ò‰∫Æ‰ΩÜÈÖçÁΩÆÂ∑≤Á¶ÅÁî®ÔºåÊ∏ÖÈô§È´ò‰∫Æ
        this.$store.dispatch('clearLineageHighlight')
      }
    },

    editTask(task) {
      console.log('[Ë∞ÉËØï] editTaskË¢´Ë∞ÉÁî®', task);

      // Ê£ÄÊü•Áà∂ËäÇÁÇπÁºñËæëÊùÉÈôê
      if (task.isParentNode && !this.allowParentEdit) {
        this.$message.warning('Parent node editing is disabled')
        return
      }

      // Ê£ÄÊü•‰ªªÂä°ÊùÉÈôê - Âè≥‰æßËäÇÁÇπÊØè‰∏ÄË°åÈÉΩÈúÄË¶ÅÊúâÁºñËæëÊùÉÈôêÊéßÂà∂
      if (!this.hasPermission(task, 'editable')) {
        this.$message.warning('ËØ•‰ªªÂä°‰∏çÂÖÅËÆ∏ÁºñËæë')
        return
      }

      // ÈÄöÁü•Áà∂ÁªÑ‰ª∂ÊòæÁ§∫Áªü‰∏ÄÁöÑÁºñËæëÂºπÊ°Ü
      this.$emit('edit-task', {
        taskId: task.id,
        task: task
      })

      console.log('[Ë∞ÉËØï] ‰ªªÂä°ÁºñËæë‰∫ã‰ª∂Â∑≤ÂèëÈÄÅÁªôÁà∂ÁªÑ‰ª∂');
    },

    // ‰ªªÂä°ÁºñËæëÊñπÊ≥ïÂ∑≤ÁßªËá≥GanttChartÁªü‰∏ÄÂ§ÑÁêÜ

    deleteTaskDirectly(task) {
      // Ê£ÄÊü•Âà†Èô§ÊùÉÈôê - Âè≥‰æßËäÇÁÇπÊØè‰∏ÄË°åÈÉΩÈúÄË¶ÅÊúâÁºñËæëÊùÉÈôêÊéßÂà∂
      if (!this.hasPermission(task, 'deletable')) {
        this.$message.warning('ËØ•‰ªªÂä°‰∏çÂÖÅËÆ∏Âà†Èô§')
        return
      }

      if (confirm(`Are you sure you want to delete task "${task.name}"?`)) {
        this.$emit('task-delete', task.id)
      }
    },

        // Ê£ÄÊü•‰ªªÂä°ÊùÉÈôêÊñπÊ≥ï - ‰∏éÂ∑¶‰æßË°®Ê†º‰øùÊåÅ‰∏ÄËá¥
    hasPermission(task, permission) {
      // Èò≤Ê≠¢ undefined ÈîôËØØÔºöÂÆâÂÖ®Ê£ÄÊü•‰ªªÂä°ÂØπË±°
      if (!task || typeof task !== 'object') {
        console.warn('hasPermission: ‰ªªÂä°ÂØπË±°Êó†Êïà', task)
        return true // ÈªòËÆ§ÂÖÅËÆ∏Êìç‰ΩúÔºàÂêëÂêéÂÖºÂÆπÔºâ
      }

      // Â¶ÇÊûú‰ªªÂä°Ê≤°ÊúâÊùÉÈôêÈÖçÁΩÆÔºåÈªòËÆ§ÂÖÅËÆ∏ÊâÄÊúâÊìç‰ΩúÔºàÂêëÂêéÂÖºÂÆπÔºâ
      if (!task.permissions || typeof task.permissions !== 'object') {
        return true
      }

      // ÁâπÊÆäÂ§ÑÁêÜÔºöÁà∂ËäÇÁÇπÁöÑÁºñËæëÊùÉÈôê
      // Áà∂ËäÇÁÇπÂ∫îËØ•ÂèØ‰ª•ÁºñËæëÔºåÈô§ÈùûÊòéÁ°ÆËÆæÁΩÆ‰∏∫false
      if (permission === 'editable' && task.children && task.children.length > 0) {
        // Áà∂ËäÇÁÇπÈªòËÆ§ÂèØÁºñËæëÔºåÈô§ÈùûÊùÉÈôêÊòéÁ°ÆËÆæÁΩÆ‰∏∫false
        return task.permissions[permission] !== false
      }

      // Ê£ÄÊü•ÂÖ∑‰ΩìÊùÉÈôê
      return task.permissions[permission] === true
    },

    // Milestone Áõ∏ÂÖ≥ÊñπÊ≥ï
    editMilestone(task) {
      // Âø´ÈÄüÁºñËæëmilestoneÁä∂ÊÄÅ
      const currentProgress = task.progress || 0
      const options = ['0% - Not Started', '50% - In Progress', '100% - Completed']
      const selectedIndex = currentProgress >= 100 ? 2 : (currentProgress > 0 ? 1 : 0)

      this.$prompt('Select milestone status:', 'Edit Milestone', {
        inputType: 'select',
        inputOptions: options,
        inputValue: options[selectedIndex],
        showInput: false,
        showCancelButton: true,
        confirmButtonText: 'Update',
        cancelButtonText: 'Cancel'
      }).then(({ value }) => {
        let newProgress
        switch(value) {
        case '0% - Not Started': newProgress = 0; break
        case '50% - In Progress': newProgress = 50; break
        case '100% - Completed': newProgress = 100; break
        default: newProgress = currentProgress
        }

        this.$emit('task-update', {
          id: task.id,
          updates: { progress: newProgress }
        })
      }).catch(() => {
        // Áî®Êà∑ÂèñÊ∂à
      })
    },

    isMilestoneOverdue(task) {
      if ((task.progress || 0) >= 100) return false
      const today = moment()
      const endDate = moment(task.endDate || task.startDate)
      return today.isAfter(endDate)
    },

    getMilestoneStatus(task) {
      if ((task.progress || 0) >= 100) return 'Completed'
      if (this.isMilestoneOverdue(task)) return 'Overdue'
      if ((task.progress || 0) > 0) return 'In Progress'
      return 'Not Started'
    },

    getMilestoneIcon(task) {
      if ((task.progress || 0) >= 100) return '‚úÖ'
      if (this.isMilestoneOverdue(task)) return '‚ö†Ô∏è'
      if ((task.progress || 0) > 0) return 'üîÑ'
      return 'üéØ'
    },

    // Tooltip Áõ∏ÂÖ≥ÊñπÊ≥ï
    showTooltip(task, event) {
      // Ê£ÄÊü•ÊòØÂê¶ÂêØÁî®tooltip
      if (!this.tooltipConfig.enabled) {
        return
      }

      // Ê∏ÖÈô§ÈöêËóèËÆ°Êó∂Âô®
      if (this.tooltipHideTimer) {
        clearTimeout(this.tooltipHideTimer)
        this.tooltipHideTimer = null
      }

      // Â¶ÇÊûúÂ∑≤ÁªèÊòæÁ§∫‰∫ÜÁõ∏Âêå‰ªªÂä°ÁöÑtooltipÔºåÁõ¥Êé•Êõ¥Êñ∞‰ΩçÁΩÆ
      if (this.tooltip.visible && this.tooltip.task && this.tooltip.task.id === task.id) {
        this.updateTooltipPosition(event)
        return
      }

      // Ê∏ÖÈô§‰πãÂâçÁöÑÊòæÁ§∫ËÆ°Êó∂Âô®
      if (this.tooltipTimer) {
        clearTimeout(this.tooltipTimer)
      }

      // ËÆæÁΩÆÂª∂ËøüÊòæÁ§∫
      this.tooltipTimer = setTimeout(() => {
        this.calculateTooltipPosition(event, task)
        this.tooltipTimer = null
      }, this.tooltipConfig.delay)
    },

    calculateTooltipPosition(event, task) {
      const tooltipWidth = 280
      const tooltipHeight = 200
      const padding = 10
      const extraBottomPadding = 20 // Â∫ïÈÉ®È¢ùÂ§ñËæπË∑ù

      // Ëé∑ÂèñGanttÂå∫ÂüüÂÆπÂô®
      const container = this._ganttScrollContainer
      if (!container) {
        // ÂÖúÂ∫ïÔºöÊó†ÂÆπÂô®Êó∂ÈÄÄÂõûwindowÂÆö‰Ωç
        let x = event.clientX + 15
        let y = event.clientY - 80
        if (x + tooltipWidth > window.innerWidth - padding) {
          x = event.clientX - tooltipWidth - 15
        }
        if (x < padding) x = padding
        if (y + tooltipHeight > window.innerHeight - padding) {
          y = event.clientY - tooltipHeight - 15
        }
        if (y < padding) y = event.clientY + 25
        this.tooltip = {
          visible: true,
          x: Math.max(padding, Math.min(x, window.innerWidth - tooltipWidth - padding)),
          y: Math.max(padding, Math.min(y, window.innerHeight - tooltipHeight - padding)),
          task
        }
        return
      }

      // Ëé∑ÂèñÂÆπÂô®ËæπÁïå‰ø°ÊÅØ
      const containerRect = container.getBoundingClientRect()

      // ËÆ°ÁÆóÁõ∏ÂØπ‰∫éÂÆπÂô®ÁöÑÈº†Ê†á‰ΩçÁΩÆ
      const relativeX = event.clientX - containerRect.left
      const relativeY = event.clientY - containerRect.top

      // ËÆ°ÁÆóÂú®ÂÆπÂô®ÂÜÖÁöÑÁªùÂØπ‰ΩçÁΩÆÔºàËÄÉËôëÊªöÂä®Ôºâ
      let x = relativeX + container.scrollLeft + 15  // ÈªòËÆ§Âú®Èº†Ê†áÂè≥‰æß
      let y = relativeY + container.scrollTop - 80   // ÈªòËÆ§Âú®Èº†Ê†á‰∏äÊñπ

      // ÂÆπÂô®ÂèØËßÜÂå∫ÂüüËæπÁïå
      const containerWidth = container.clientWidth
      const containerHeight = container.clientHeight
      const scrollTop = container.scrollTop
      const scrollLeft = container.scrollLeft

      // Â¢ûÂº∫ËæπÁïåËÆ°ÁÆó - ËÄÉËôëËßÜÂè£ËæπÁïåÂíåÈ¢ùÂ§ñËæπË∑ù
      const viewportBottom = scrollTop + containerHeight - extraBottomPadding
      const viewportTop = scrollTop + padding
      const viewportRight = scrollLeft + containerWidth - padding
      const viewportLeft = scrollLeft + padding

      // Êô∫ËÉΩ‰ΩçÁΩÆË∞ÉÊï¥ - Ê∞¥Âπ≥ÊñπÂêë
      if (x + tooltipWidth > viewportRight) {
        // tooltipË∂ÖÂá∫Âè≥ËæπÁïåÔºåË∞ÉÊï¥Âà∞Èº†Ê†áÂ∑¶‰æß
        x = relativeX + scrollLeft - tooltipWidth - 15
      }
      if (x < viewportLeft) {
        // tooltipË∂ÖÂá∫Â∑¶ËæπÁïåÔºåË¥¥ËøëÂ∑¶ËæπÁïå
        x = viewportLeft
      }

      // Êô∫ËÉΩ‰ΩçÁΩÆË∞ÉÊï¥ - ÂûÇÁõ¥ÊñπÂêëÔºàÈáçÁÇπ‰ºòÂåñÂ∫ïÈÉ®ÈÅÆÊå°ÈóÆÈ¢òÔºâ
      // Â¢ûÂº∫Â∫ïÈÉ®Ê£ÄÊµãÔºöË∑ùÁ¶ªÂ∫ïÈÉ®80px‰ª•ÂÜÖËÆ§‰∏∫ÊòØÂ∫ïÈÉ®Âå∫Âüü
      const isNearBottom = (relativeY + scrollTop + tooltipHeight + 80) > (scrollTop + containerHeight)

      if (isNearBottom) {
        // Â∫ïÈÉ®Âå∫ÂüüÔºöÂº∫Âà∂ÊîæÁΩÆÂú®Èº†Ê†á‰∏äÊñπ
        const topY = relativeY + scrollTop - tooltipHeight - 30
        if (topY >= viewportTop) {
          // ‰∏äÊñπÊúâË∂≥Â§üÁ©∫Èó¥ÔºåÊîæÁΩÆÂú®‰∏äÊñπ
          y = topY
        } else {
          // ‰∏äÊñπÁ©∫Èó¥‰∏çË∂≥ÔºåËÆ°ÁÆóÊúÄ‰Ω≥‰ΩçÁΩÆ
          const availableTopSpace = relativeY + scrollTop - viewportTop
          const availableBottomSpace = viewportBottom - (relativeY + scrollTop)

          if (availableTopSpace >= availableBottomSpace) {
            // ‰∏äÊñπÁ©∫Èó¥Êõ¥Â§ßÔºåÂ∞ΩÈáèÊîæÂú®‰∏äÊñπ
            y = Math.max(viewportTop, relativeY + scrollTop - tooltipHeight - 10)
          } else {
            // ‰∏ãÊñπÁ©∫Èó¥Êõ¥Â§ßÔºå‰ΩÜÁ°Æ‰øù‰∏çË¢´ÈÅÆÊå°
            y = Math.min(relativeY + scrollTop + 30, viewportBottom - tooltipHeight)
          }
        }
      } else {
        // ÈùûÂ∫ïÈÉ®Âå∫ÂüüÔºöÊ≠£Â∏∏Âà§Êñ≠
        if (y + tooltipHeight > viewportBottom) {
          // tooltipË∂ÖÂá∫‰∏ãËæπÁïåÔºåË∞ÉÊï¥Âà∞Èº†Ê†á‰∏äÊñπ
          const newY = relativeY + scrollTop - tooltipHeight - 15
          if (newY >= viewportTop) {
            y = newY
          } else {
            // ‰∏ä‰∏ãÈÉΩÊîæ‰∏ç‰∏ãÔºåÈÄâÊã©ÈÅÆÊå°ÊúÄÂ∞ëÁöÑ‰ΩçÁΩÆ
            const topOverflow = viewportTop - newY
            const bottomOverflow = (y + tooltipHeight) - viewportBottom

            if (topOverflow <= bottomOverflow) {
              y = viewportTop
            } else {
              y = viewportBottom - tooltipHeight
            }
          }
        }
        if (y < viewportTop) {
          // tooltipË∂ÖÂá∫‰∏äËæπÁïåÔºåË∞ÉÊï¥Âà∞Èº†Ê†á‰∏ãÊñπ
          const newY = relativeY + scrollTop + 25
          if (newY + tooltipHeight <= viewportBottom) {
            y = newY
          } else {
            // ‰∏ãÊñπÁ©∫Èó¥‰∏çË∂≥ÔºåË¥¥Ëøë‰∏äËæπÁïå
            y = viewportTop
          }
        }
      }

      // ÊúÄÁªàËæπÁïå‰øùÊä§ - Á°Æ‰øùtooltipÂÆåÂÖ®Âú®ÂèØËßÜËåÉÂõ¥ÂÜÖ
      x = Math.max(viewportLeft, Math.min(x, viewportRight - tooltipWidth))
      y = Math.max(viewportTop, Math.min(y, viewportBottom - tooltipHeight))

      // ËÆæÁΩÆtooltip‰ΩçÁΩÆ
      this.tooltip = {
        visible: true,
        x: Math.round(x),
        y: Math.round(y),
        task
      }
    },

    hideTooltip() {
      // Ê∏ÖÈô§ÊòæÁ§∫ËÆ°Êó∂Âô®
      if (this.tooltipTimer) {
        clearTimeout(this.tooltipTimer)
        this.tooltipTimer = null
      }

      // ËÆæÁΩÆÂª∂ËøüÈöêËóèÔºåÁªôÁî®Êà∑Êó∂Èó¥ÁßªÂä®Âà∞tooltip‰∏ä
      if (this.tooltipHideTimer) {
        clearTimeout(this.tooltipHideTimer)
      }

      this.tooltipHideTimer = setTimeout(() => {
        this.tooltip.visible = false
        this.tooltipHideTimer = null
      }, this.tooltipConfig.hideDelay)
    },

    // Èº†Ê†áËøõÂÖ•tooltipÊó∂ÂèñÊ∂àÈöêËóè
    onTooltipMouseEnter() {
      if (this.tooltipHideTimer) {
        clearTimeout(this.tooltipHideTimer)
        this.tooltipHideTimer = null
      }
    },

    // Èº†Ê†áÁ¶ªÂºÄtooltipÊó∂ÈöêËóè
    onTooltipMouseLeave() {
      this.hideTooltip()
    },

    updateTooltipPosition(event) {
      if (this.tooltip.visible && this.tooltip.task) {
        this.calculateTooltipPosition(event, this.tooltip.task)
      }
    },

    formatTooltipDate(dateString) {
      if (!dateString) return '-'
      return moment(dateString).format('MMM DD, YYYY')
    },

    getTaskStatus(task) {
      if (!task.progress) return 'Not Started'
      if (task.progress >= 100) return 'Completed'
      if (task.progress > 0) return 'In Progress'
      return 'Not Started'
    },

    getTooltipStatusClass(task) {
      const status = this.getTaskStatus(task)
      return {
        'status-completed': status === 'Completed',
        'status-progress': status === 'In Progress',
        'status-not-started': status === 'Not Started'
      }
    },

    // Ëé∑ÂèñÈ´ò‰∫ÆË°åÁöÑÂûÇÁõ¥‰ΩçÁΩÆ
    getHighlightedRowTop() {
      if (this.highlightedRowId === null) return 0

      // Âú®taskBars‰∏≠ÊâæÂà∞È´ò‰∫Æ‰ªªÂä°ÁöÑÁ¥¢Âºï
      const highlightedBar = this.taskBars.find(bar =>
        String(bar.task.id) === String(this.highlightedRowId)
      )

      if (highlightedBar) {
        return highlightedBar.index * 28 // ‰øÆÂ§ç‰∏∫28pxË°åÈ´ò
      }

      return 0
    },

    // ËÆ°ÁÆó‰æùËµñÁ∫ø - ÂàÜÁ¶ªÂá∫Áã¨Á´ãÊñπÊ≥ï‰æø‰∫é‰ºòÂåñ
    calculateDependencyLines() {
      if (!this.dependencies || this.dependencies.length === 0) {
        return []
      }

      // ‰ΩøÁî®Â∏ÉÂ±ÄÁºìÂ≠ò - Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÊñ∞ËÆ°ÁÆó
      if (this.isLayoutCached()) {
        return this._cachedDependencyLines
      }

      // Ê∏ÖÈô§ËøûÁ∫øÂÜ≤Á™ÅÁºìÂ≠òÔºåÂáÜÂ§áÈáçÊñ∞ËÆ°ÁÆó
      if (this.connectionConflictMap && typeof this.connectionConflictMap.clear === 'function') {
        this.connectionConflictMap.clear()
      } else {
        this.connectionConflictMap = new Map()
      }

      if (this.lineOffsetMap && typeof this.lineOffsetMap.clear === 'function') {
        this.lineOffsetMap.clear()
      } else {
        this.lineOffsetMap = new Map()
      }

      // ÂàõÂª∫‰ªªÂä°Êò†Â∞Ñ‰ª•ÊèêÂçáÊü•ÊâæÊÄßËÉΩ
      const taskBarMap = new Map()
      this.taskBars.forEach(bar => {
        taskBarMap.set(bar.task.id, bar)
      })

      const lines = []

      for (const dep of this.dependencies) {
        const fromBar = taskBarMap.get(dep.from)
        const toBar = taskBarMap.get(dep.to)

        if (!fromBar || !toBar) {
          continue
        }

        // Ê†πÊçÆ‰æùËµñÁ±ªÂûãËÆ°ÁÆóËøûÊé•ÁÇπ‰ΩçÁΩÆ
        let fromX, toX
        const fromY = (fromBar.index || 0) * 28 + 14 // ‰øÆÂ§çËøûÁ∫øYÂùêÊ†áËÆ°ÁÆóÔºå28pxË°åÈ´òÁöÑ‰∏≠ÂøÉ‰ΩçÁΩÆ
        const toY = (toBar.index || 0) * 28 + 14 // ‰øÆÂ§çËøûÁ∫øYÂùêÊ†áËÆ°ÁÆóÔºå28pxË°åÈ´òÁöÑ‰∏≠ÂøÉ‰ΩçÁΩÆ

        // Ëé∑Âèñ‰æùËµñÁ±ªÂûãÔºåÈªòËÆ§‰∏∫FS
        const dependencyType = dep.type || 'FS'

        // Ê†πÊçÆ‰æùËµñÁ±ªÂûãÂíå‰ªªÂä°Á±ªÂûãËÆ°ÁÆóÊ∫ê‰ªªÂä°ËøûÊé•ÁÇπ
        fromX = this.getConnectionPoint(fromBar, dependencyType, 'from')

        // Ê†πÊçÆ‰æùËµñÁ±ªÂûãÂíå‰ªªÂä°Á±ªÂûãËÆ°ÁÆóÁõÆÊ†á‰ªªÂä°ËøûÊé•ÁÇπ
        toX = this.getConnectionPoint(toBar, dependencyType, 'to')

        // Ê£ÄÊü•ÂùêÊ†áÊúâÊïàÊÄß
        if (isNaN(fromX) || isNaN(fromY) || isNaN(toX) || isNaN(toY)) {
          console.warn('Invalid coordinates detected, skipping dependency line:', {
            fromX, fromY, toX, toY, fromBar, toBar, dep
          })
          continue
        }

        // Ë∞ÉËØï‰ø°ÊÅØÔºöËøûÊé•ÁÇπ‰ΩçÁΩÆÔºà‰ªÖÂú®ÂºÄÂèëÊ®°Âºè‰∏ãÔºâ
        if (process.env.NODE_ENV === 'development') {
          // console.log(`[ËøûÁ∫øËÆ°ÁÆó] ${fromBar.task.name} -> ${toBar.task.name}`, {
          //   type: dependencyType,
          //   fromX, toX,
          //   fromTask: `${fromBar.task.name} (${fromBar.left}, ${fromBar.left + fromBar.width})`,
          //   toTask: `${toBar.task.name} (${toBar.left}, ${toBar.left + toBar.width})`
          // })
        }

                // ÂÖ®Êñ∞ÁöÑÂàÜÊÆµËøûÁ∫øÁÆóÊ≥ï - Á°Æ‰øùÁÆ≠Â§¥ÂßãÁªàÂèØËßÅ
        let path = this.calculateOptimizedPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar)

        // Á°Æ‰øùÁÆ≠Â§¥‰∏çË¢´‰ªªÂä°Êù°ÈÅÆÊå° - ÈÄÇÁî®‰∫éÊâÄÊúâËøûÁ∫øÊ†∑Âºè
        path = this.ensureArrowVisibility(path, dependencyType, fromBar, toBar)

        // ÁâπÊÆäÂ§ÑÁêÜmilestoneËøûÁ∫øÔºåÁ°Æ‰øùÁÆ≠Â§¥‰∏çË¢´diamondÂΩ¢Áä∂ÈÅÆÊå°
        const isMilestoneTarget = toBar.task.type === 'milestone'
        if (isMilestoneTarget) {
          path = this.adjustMilestoneArrowPath(path, dependencyType, toBar)
        }

        // Ë∞ÉËØïÊ®°ÂºèÔºöËæìÂá∫ËøûÁ∫ø‰ø°ÊÅØ
        if (process.env.NODE_ENV === 'development') {
          // console.log(`[ËøûÁ∫øË∞ÉËØï] ${fromBar.task.name} -> ${toBar.task.name}`, {
          //   type: dependencyType,
          //   from: { x: fromX, y: fromY },
          //   to: { x: toX, y: toY },
          //   path: path,
          //   isEndPoint: dependencyType === 'FF' || dependencyType === 'SF'
          // })
        }

        // ÁîüÊàêËøûÊé•Á∫øÊ†áÁ≠æÔºöÁªìÂêà‰æùËµñÁ±ªÂûã„ÄÅlagÂíåËá™ÂÆö‰πâÊ†áÁ≠æ
        const label = this.generateConnectionLabel(dep)

        // ËÆ°ÁÆóÊ†áÁ≠æ‰ΩçÁΩÆÔºöÂú®ËøûÁ∫ø‰∏≠Èó¥ÁÇπÈôÑËøë
        // ËÆ°ÁÆóÊ†áÁ≠æ‰ΩçÁΩÆÁöÑÂä®ÊÄÅÂÅèÁßª
        const baseOffset = 20
        const rowDiff = Math.abs(toBar.index - fromBar.index)
        const dynamicOffset = baseOffset + Math.min(rowDiff * 5, 30)

        let midX, midY
        if (fromY === toY) {
          // Âêå‰∏ÄË°åÊó∂ÔºåÊ†áÁ≠æÂú®Ê∞¥Âπ≥Á∫ø‰∏≠Èó¥
          midX = (fromX + toX) / 2
          midY = fromY - 5 // Á®çÂæÆÂÅè‰∏äÔºåÈÅøÂÖç‰∏éËøûÁ∫øÈáçÂè†
        } else {
          // ‰∏çÂêåË°åÊó∂ÔºåÊ†áÁ≠æ‰ΩçÁΩÆÂú®ÂûÇÁõ¥Á∫øÊÆµÁöÑ‰∏≠Èó¥
          if (toX < fromX) {
            // Â§çÊùÇË∑ØÂæÑÁöÑÊ†áÁ≠æ‰ΩçÁΩÆ
            midX = fromX + Math.max(dynamicOffset, 40)
            midY = fromY + (toY - fromY) / 2
          } else {
            midX = fromX + dynamicOffset
            midY = fromY + (toY - fromY) / 2
          }
        }

        // Á°Æ‰øùÊ†áÁ≠æ‰ΩçÁΩÆÊúâÊïà
        midX = isNaN(midX) ? fromX : midX
        midY = isNaN(midY) ? fromY : midY

        const isSelected = this.selectedDependency &&
                          this.selectedDependency.from === dep.from &&
                          this.selectedDependency.to === dep.to

        lines.push({
          key: `${dep.from}-${dep.to}`,
          path,
          from: dep.from,
          to: dep.to,
          color: dep.color || '#666',
          type: dep.type || 'FS',
          lag: dep.lag || 0,
          label,
          labelX: midX,
          labelY: midY,
          colorButtonX: midX - 30,
          colorButtonY: midY - 15,
          deleteButtonX: midX + 30,
          deleteButtonY: midY - 15,
          selected: isSelected,
          dependency: dep,  // Ê∑ªÂä†ÂÆåÊï¥ÁöÑ‰æùËµñÂØπË±°ÂºïÁî®ÔºåÁî®‰∫éÁÆ≠Â§¥ÊòæÁ§∫
          fromBar: fromBar, // Ê∑ªÂä†Ê∫ê‰ªªÂä°Êù°ÂºïÁî®
          toBar: toBar      // Ê∑ªÂä†ÁõÆÊ†á‰ªªÂä°Êù°ÂºïÁî®
        })
      }

      // ÁºìÂ≠òËÆ°ÁÆóÁªìÊûú
      this._cachedDependencyLines = lines

      return lines
    },

    // Ê∏ÖÈô§‰æùËµñÁ∫øÁºìÂ≠ò - Â¢ûÂº∫ÁâàÊú¨
    clearDependencyCache() {
      console.log('[GanttBars] Ê∏ÖÈô§‰æùËµñÁ∫øÁºìÂ≠ò');
      // Ê∏ÖÈô§‰æùËµñÁ∫øËÆ°ÁÆóÁºìÂ≠ò
      this._cachedDependencyLines = null;
      // Ê∏ÖÈô§Â∏ÉÂ±ÄÁºìÂ≠ò
      this._layoutHash = null;
      this._visibleAreaCache = null;
      // Ê∏ÖÈô§ËøûÁ∫øÂÅèÁßªÂíåÂÜ≤Á™ÅÊ£ÄÊµãÊò†Â∞Ñ
      this.lineOffsetMap = new Map();
      this.connectionConflictMap = new Map();
      // Âº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆó
      this.$nextTick(() => {
        this.calculateDependencyLines();
      });
    },

    // ÂàùÂßãÂåñÁºìÂ≠òMapÂØπË±°
    initializeCacheMaps() {
      console.log('[GanttBars] ÂàùÂßãÂåñÁºìÂ≠òMap');
      this._dependencyLayoutCache = new Map();
      this.lineOffsetMap = new Map();
      this.connectionConflictMap = new Map();
      this._visibleAreaCache = null;
      this._layoutHash = null;
    },

    // È™åËØÅÁºìÂ≠òMapÂØπË±°Áä∂ÊÄÅ - Ë∞ÉËØïÁî®
    validateCacheMaps() {
      const status = {
        _dependencyLayoutCache: this._dependencyLayoutCache instanceof Map,
        lineOffsetMap: this.lineOffsetMap instanceof Map,
        connectionConflictMap: this.connectionConflictMap instanceof Map
      }

      console.log('[ÁºìÂ≠òÈ™åËØÅ]', status)
      return Object.values(status).every(isValid => isValid)
    },

    // ÁîüÊàêÂ∏ÉÂ±ÄÂìàÂ∏åÂÄº - Ê£ÄÊµãÂ∏ÉÂ±ÄÊòØÂê¶ÂèòÂåñ
    generateLayoutHash() {
      // Âü∫‰∫é‰ªªÂä°‰ΩçÁΩÆ„ÄÅ‰æùËµñÂÖ≥Á≥ªÂíåÂèØËßÜÂå∫ÂüüÁîüÊàêÂìàÂ∏å
      const taskPositions = this.taskBars.map(bar =>
        `${bar.task.id}_${bar.left}_${bar.width}_${bar.index}`
      ).join('|')

      const dependencyStr = this.dependencies.map(dep =>
        `${dep.from}_${dep.to}_${dep.type}_${dep.lag || 0}`
      ).join('|')

      const viewState = `${this.actualUnitWidth}_${this.startDate}_${this.endDate}`

      // ËøûÁ∫øÊ†∑ÂºèÁä∂ÊÄÅ - Êñ∞Â¢ûÊîØÊåÅÊô∫ËÉΩÁÆóÊ≥ï
      const connectionStyleState = `${this.connectionStyle}_${this.connectionEditable}_${this.grayConnectionMode}`

      // ÁÆÄÂçïÂìàÂ∏åÁÆóÊ≥ï
      const str = `${taskPositions}:${dependencyStr}:${viewState}:${connectionStyleState}`
      let hash = 0
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i)
        hash = ((hash << 5) - hash) + char
        hash = hash & hash // ËΩ¨Êç¢‰∏∫32‰ΩçÊï¥Êï∞
      }
      return hash.toString()
    },

    // Ê£ÄÊü•Â∏ÉÂ±ÄÊòØÂê¶Â∑≤ÁºìÂ≠ò
    isLayoutCached() {
      const currentHash = this.generateLayoutHash()
      if (this._layoutHash === currentHash && this._cachedDependencyLines) {
        return true
      }
      this._layoutHash = currentHash
      return false
    },

    closeLinkEditModal() {
      // Â¶ÇÊûúÊúâÊú™‰øùÂ≠òÁöÑÊõ¥Êîπ‰∏îÂ≠òÂú®ÂéüÂßãÁä∂ÊÄÅÔºåÊÅ¢Â§çÂéüÂßãÁä∂ÊÄÅ
      if (this.linkEditModal.originalState) {
        console.log('[ËøûÁ∫øÁºñËæë] ÂèñÊ∂àÁºñËæëÔºåÊÅ¢Â§çÂéüÂßãÁä∂ÊÄÅ:', this.linkEditModal.originalState);

        // ÊÅ¢Â§ç‰æùËµñÂÖ≥Á≥ªÁöÑÂéüÂßãÂ±ûÊÄß
        this.$store.commit('UPDATE_DEPENDENCY_FULL', {
          from: this.linkEditModal.link.from,
          to: this.linkEditModal.link.to,
          updates: this.linkEditModal.originalState
        });

        // Ê∏ÖÈô§ÁºìÂ≠ò‰ª•Á°Æ‰øùÊõ¥Êñ∞ÁîüÊïà
        this.clearDependencyCache();
      }

      // ÈáçÁΩÆÂºπÊ°ÜÁä∂ÊÄÅ
      this.linkEditModal = {
        visible: false,
        link: null,
        type: 'FS',
        lag: 0,
        label: '',
        color: '#3498db',
        originalState: null,
        saving: false
      };
    },

    deleteLinkFromModal() {
      this.removeDependency({
        from: this.linkEditModal.link.from,
        to: this.linkEditModal.link.to
      })
      this.closeLinkEditModal()
    },

        async saveLinkChanges() {
      console.log('[GanttBars] ‰øùÂ≠òËøûÁ∫øÂèòÊõ¥ÂºÄÂßã');

      // ËÆæÁΩÆ‰øùÂ≠òÁä∂ÊÄÅ
      this.linkEditModal.saving = true;

      try {
        // Ëé∑ÂèñÂéüÂßã‰æùËµñÂÖ≥Á≥ª
        const originalDep = this.dependencies.find(dep =>
          dep.from === this.linkEditModal.link.from &&
          dep.to === this.linkEditModal.link.to
        );

        if (!originalDep) {
          throw new Error('Êâæ‰∏çÂà∞Ë¶ÅÊõ¥Êñ∞ÁöÑ‰æùËµñÂÖ≥Á≥ª');
        }

        // Á°Æ‰øùÊï∞ÊçÆÁ±ªÂûãÊ≠£Á°Æ
        const updatedDependency = {
          ...originalDep,
          type: this.linkEditModal.type,
          lag: parseInt(this.linkEditModal.lag) || 0,
          label: this.linkEditModal.label || '',
          color: this.linkEditModal.color || '#3498db'
        };

        console.log('[GanttBars] ÂáÜÂ§áÊõ¥Êñ∞‰æùËµñÂÖ≥Á≥ª:', updatedDependency);

        // 1. ÂÖàËß¶ÂèëÁà∂ÁªÑ‰ª∂Âà∑Êñ∞‰∫ã‰ª∂
        this.$emit('dependency-updated', {
          action: 'update',
          dependency: updatedDependency,
          force: true,
          requireRefresh: true
        });

        // 2. Á≠âÂæÖ‰∫ã‰ª∂Â§ÑÁêÜÂÆåÊàê
        await this.$nextTick();

        // 3. Êõ¥Êñ∞store‰∏≠ÁöÑ‰æùËµñÂÖ≥Á≥ª
        this.$store.commit('UPDATE_DEPENDENCY_FULL', {
          from: updatedDependency.from,
          to: updatedDependency.to,
          updates: {
            type: updatedDependency.type,
            lag: updatedDependency.lag,
            label: updatedDependency.label,
            color: updatedDependency.color
          }
        });

        // 4. Á≠âÂæÖstoreÊõ¥Êñ∞ÂÆåÊàê
        await this.$nextTick();

        // 5. Ê∏ÖÈô§ÊâÄÊúâÁºìÂ≠òÂπ∂ÈáçÊñ∞ËÆ°ÁÆó
        this.clearDependencyCache();
        this._cachedDependencyLines = null;
        this.taskBarMap = null;
        this.flatTaskMap = null;
        this.initializeCacheMaps();
        this._cachedDependencyLines = this.calculateDependencyLines();

        // 6. Âº∫Âà∂ÁªÑ‰ª∂ÈáçÊñ∞Ê∏≤Êüì
        this.$forceUpdate();

        // 7. ÂÖ≥Èó≠ÂºπÊ°Ü
        this.closeLinkEditModal();

        // 8. ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
        this.$message({
          message: 'Connection updated successfully',
          type: 'success',
          duration: 2000
        });

        // 9. Ëß¶ÂèëÂÖ®Â±Ä‰∫ã‰ª∂ÈÄöÁü•ÂÖ∂‰ªñÁªÑ‰ª∂
        window.dispatchEvent(new CustomEvent('dependency-updated', {
          detail: {
            from: updatedDependency.from,
            to: updatedDependency.to,
            updates: updatedDependency,
            source: 'saveLinkChanges'
          }
        }));

      } catch (error) {
        console.error('[GanttBars] ‰øùÂ≠òËøûÁ∫øÂèòÊõ¥Â§±Ë¥•:', error);
        this.$message({
          message: `Failed to update connection: ${error.message}`,
          type: 'error',
          duration: 3000
        });
      } finally {
        // ÈáçÁΩÆ‰øùÂ≠òÁä∂ÊÄÅ
        this.linkEditModal.saving = false;
      }
    },

    openLinkEditModal(line, event) {
      console.log('[Ë∞ÉËØï] openLinkEditModalË¢´Ë∞ÉÁî®', line);
      // Ê£ÄÊü•ËøûÊé•Á∫øÊòØÂê¶ÂèØÁºñËæë
      if (!this.connectionEditable) {
        console.log('[ËøûÊé•Á∫øÁºñËæë] ËøûÊé•Á∫ø‰∏çÂèØÁºñËæëÔºåË∑≥Ëøá')
        return
      }

      console.log('[ËøûÊé•Á∫øÁºñËæë] ÂèåÂáª‰∫ã‰ª∂Ëß¶ÂèëÔºåÊâìÂºÄÁºñËæëÂºπÊ°Ü', {
        from: line.from,
        to: line.to,
        type: line.type || 'FS',
        lag: line.lag || 0
      })

      // Ëé∑Âèñ‰ªªÂä°ÂêçÁß∞
      const fromTask = this.taskBars.find(bar => bar.task.id === line.from)?.task
      const toTask = this.taskBars.find(bar => bar.task.id === line.to)?.task

      // Ëé∑Âèñ‰æùËµñÂÖ≥Á≥ªËØ¶ÁªÜ‰ø°ÊÅØ
      const dependency = this.dependencies.find(dep =>
        dep.from === line.from && dep.to === line.to
      )

      // Â§á‰ªΩÂéüÂßãÁä∂ÊÄÅ
      const originalState = dependency ? {
        type: dependency.type || 'FS',
        lag: dependency.lag || 0,
        label: dependency.label || '',
        color: dependency.color || '#3498db'
      } : null;

      // ËÆæÁΩÆÂºπÊ°ÜÁä∂ÊÄÅ
      this.linkEditModal = {
        visible: true,
        link: {
          ...line,
          fromTaskName: fromTask?.name || 'Unknown Task',
          toTaskName: toTask?.name || 'Unknown Task'
        },
        type: dependency?.type || line.type || 'FS',
        lag: dependency?.lag || line.lag || 0,
        label: dependency?.label || line.label || '',
        color: dependency?.color || line.color || '#3498db',
        originalState // ‰øùÂ≠òÂéüÂßãÁä∂ÊÄÅ
      };

      console.log('[Ë∞ÉËØï] ËøûÊé•Á∫øÁºñËæëÂºπÁ™óÂ∑≤ÊòæÁ§∫', {
        visible: this.linkEditModal.visible,
        type: this.linkEditModal.type,
        lag: this.linkEditModal.lag,
        originalState: this.linkEditModal.originalState
      });
    },

    startProgressDrag(bar, event) {
      console.log('[Ë∞ÉËØï] startProgressDrag Ë¢´Ë∞ÉÁî®', bar.task.id, bar.task.progress)
      this.progressDragState = {
        bar,
        startX: event.clientX,
        startProgress: bar.task.progress,
        barWidth: bar.width
      }
      // Ê∑ªÂä†ÊãñÊãΩÁä∂ÊÄÅÁ±ªÔºåÁ¶ÅÁî®ËøáÊ∏°ÊïàÊûú
      const barElement = event.target.closest('.gantt-bar')
      if (barElement) {
        barElement.classList.add('progress-dragging')
        console.log('[Ë∞ÉËØï] .progress-dragging Á±ªÂ∑≤Ê∑ªÂä†', barElement)
      }

      // ÂàõÂª∫‰∏Ä‰∏™ËßÜËßâÂèçÈ¶àÔºåË°®Á§∫ÊãñÊãΩÂ∑≤ÂºÄÂßã
      const progressHandle = event.target.closest('.gantt-progress-handle-container')
      if (progressHandle) {
        // Ê∑ªÂä†Âä®ÁîªÊïàÊûú - Êõ¥Âº∫ÁÉàÁöÑËßÜËßâÂèçÈ¶à
        progressHandle.style.transform = 'scale(1.1) translateY(-4px)'
        progressHandle.style.opacity = '1'
        progressHandle.style.background = 'rgba(74, 144, 226, 0.2)'
        progressHandle.style.boxShadow = '0 0 10px rgba(74, 144, 226, 0.5)'

        // Ê∑ªÂä†‰∏Ä‰∏™‰∏¥Êó∂ÁöÑÊãñÊãΩÊåáÁ§∫Âô®
        const handleElement = progressHandle.querySelector('.gantt-progress-handle')
        if (handleElement) {
          handleElement.style.borderBottomColor = '#2c5f8a'
        }

        // Ê∑ªÂä†ËøõÂ∫¶Êù°Ê†∑ÂºèÂèòÂåñ
        const progressBar = barElement.querySelector('.gantt-bar-progress')
        if (progressBar) {
          progressBar.style.transition = 'none'
          progressBar.style.background = 'rgba(0, 0, 0, 0.4)'
          progressBar.style.boxShadow = 'inset 0 0 10px rgba(255, 255, 255, 0.2)'
        }
      }

      // Êåâ‰∏ãÊó∂Á´ãÂç≥Ëß¶Âèë‰∏ÄÊ¨°ÊãñÊãΩÂèçÈ¶àÔºåÊèêÂçá‰ΩìÈ™å
      this.handleProgressDragMove(event)

      // Ê∑ªÂä†ÂÖ®Â±Ä‰∫ã‰ª∂ÁõëÂê¨ÔºåÁ°Æ‰øùÊãñÊãΩËøáÁ®ã‰∏≠ËÉΩÊåÅÁª≠Ëé∑ÂèñÈº†Ê†áÁßªÂä®
      document.addEventListener('mousemove', this.handleProgressDragMove)
      document.addEventListener('mouseup', this.handleProgressDragEnd)

      event.preventDefault()
    },

    handleProgressDragMove(event) {
      if (!this.progressDragState) {
        return
      }
      const deltaX = event.clientX - this.progressDragState.startX
      const progressChange = (deltaX / this.progressDragState.barWidth) * 100
      let newProgress = this.progressDragState.startProgress + progressChange
      newProgress = Math.max(0, Math.min(100, newProgress))
      this.progressDragState.bar.task.progress = Math.round(newProgress)

      // Êõ¥Êñ∞ËøõÂ∫¶ÊãñÊãΩÊâãÊüÑÁöÑËßÜËßâÂèçÈ¶à
      const progressHandle = document.querySelector('.progress-dragging .gantt-progress-handle-container')
      if (progressHandle) {
        // Ê†πÊçÆÊãñÊãΩË∑ùÁ¶ªË∞ÉÊï¥ÊâãÊüÑÁöÑ‰ΩçÁΩÆÔºåÂáèÂ∞èscaleÈÅøÂÖç‰∏âËßíÂΩ¢ËøáÂ§ß
        const moveOffset = Math.min(Math.max(deltaX * 0.1, -5), 5) // ÈôêÂà∂ÁßªÂä®ËåÉÂõ¥
        progressHandle.style.transform = `scale(1.05) translateY(-2px) translateX(${moveOffset}px)`

        // Á°Æ‰øùÊâãÊüÑÂßãÁªàÂèØËßÅ
        progressHandle.style.opacity = '1'

        // Êõ¥Êñ∞‰∏âËßíÂΩ¢Ê†∑Âºè‰ª•Êèê‰æõÊõ¥ÊòéÊòæÁöÑËßÜËßâÂèçÈ¶àÔºå‰ΩÜ‰øùÊåÅÂêàÈÄÇÂ§ßÂ∞è
        const handleElement = progressHandle.querySelector('.gantt-progress-handle')
        if (handleElement) {
          handleElement.style.borderBottomColor = '#2c5f8a'
          handleElement.style.filter = 'drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))'
        }

        // Ê∑ªÂä†‰∏Ä‰∏™‰∏¥Êó∂ÁöÑËøõÂ∫¶ÊåáÁ§∫Âô®
        const barElement = document.querySelector('.progress-dragging')
        if (barElement) {
          const progressBar = barElement.querySelector('.gantt-bar-progress')
          if (progressBar) {
            progressBar.style.transition = 'none'
            progressBar.style.background = 'rgba(0, 0, 0, 0.4)'
            progressBar.style.boxShadow = 'inset 0 0 10px rgba(255, 255, 255, 0.2)'
          }
        }
      }

      console.log('[Ë∞ÉËØï] handleProgressDragMove', this.progressDragState.bar.task.id, 'Êñ∞ËøõÂ∫¶:', Math.round(newProgress))
      this.$emit('progress-change', {
        id: this.progressDragState.bar.task.id,
        progress: Math.round(newProgress)
      })
    },

    handleProgressDragEnd(event) {
      if (!this.progressDragState) {
        return
      }

      // ÁßªÈô§ÊãñÊãΩÁä∂ÊÄÅÁ±ª
      const barElement = document.querySelector('.progress-dragging')
      if (barElement) {
        barElement.classList.remove('progress-dragging')

        // ÈáçÁΩÆËøõÂ∫¶Êù°Ê†∑Âºè
        const progressBar = barElement.querySelector('.gantt-bar-progress')
        if (progressBar) {
          progressBar.style.transition = ''
          progressBar.style.background = ''
          progressBar.style.boxShadow = ''
        }
      }

      // ÈáçÁΩÆËøõÂ∫¶ÊãñÊãΩÊâãÊüÑÊ†∑Âºè
      const progressHandle = document.querySelector('.gantt-progress-handle-container')
      if (progressHandle) {
        progressHandle.style.transform = ''
        progressHandle.style.opacity = ''
        progressHandle.style.background = ''
        progressHandle.style.boxShadow = ''

        // ÈáçÁΩÆ‰∏âËßíÂΩ¢Ê†∑Âºè
        const handleElement = progressHandle.querySelector('.gantt-progress-handle')
        if (handleElement) {
          handleElement.style.borderBottomColor = ''
          handleElement.style.filter = ''
          handleElement.style.transform = ''
        }
      }

      // ÊúÄÂêé‰∏ÄÊ¨°ÂèëÈÄÅËøõÂ∫¶Êõ¥Êñ∞
      this.$emit('progress-change', {
        id: this.progressDragState.bar.task.id,
        progress: Math.round(this.progressDragState.bar.task.progress)
      })

      // Ê∏ÖÁêÜÁä∂ÊÄÅÂíå‰∫ã‰ª∂ÁõëÂê¨
      this.progressDragState = null
      document.removeEventListener('mousemove', this.handleProgressDragMove)
      document.removeEventListener('mouseup', this.handleProgressDragEnd)
    },

    handleParentScroll(e) {
      this.scrollLeft = e.target.scrollLeft

      // Ê∏ÖÈô§ÂèØËßÜÂå∫ÂüüÁºìÂ≠òÔºåËß¶ÂèëÈáçÊñ∞ËÆ°ÁÆó
      this._visibleAreaCache = null

      // ËäÇÊµÅÂ§ÑÁêÜÔºåÈÅøÂÖçÈ¢ëÁπÅÊõ¥Êñ∞
      if (this.scrollUpdateTimer) {
        clearTimeout(this.scrollUpdateTimer)
      }

      this.scrollUpdateTimer = setTimeout(() => {
        this.$forceUpdate()
      }, 16) // 60fps Êõ¥Êñ∞È¢ëÁéá
    },

        // ‰æùËµñÁ±ªÂûãÂèòÊõ¥Â§ÑÁêÜ
    onDependencyTypeChange(newType) {
      console.log('[Ë∞ÉËØï] ‰æùËµñÁ±ªÂûãÂèòÊõ¥', newType)
      const typeConfig = getDependencyTypeConfig(newType)

      // ÂèØ‰ª•Ê†πÊçÆ‰æùËµñÁ±ªÂûãËá™Âä®Ë∞ÉÊï¥È¢úËâ≤
      if (typeConfig && typeConfig.color) {
        this.linkEditModal.color = typeConfig.color
      }
    },

        // Ê†πÊçÆ‰æùËµñÁ±ªÂûãÂíå‰ªªÂä°Á±ªÂûãËé∑ÂèñËøûÊé•ÁÇπ‰ΩçÁΩÆÔºàÁÆÄÊ¥ÅÁâàÊú¨Ôºâ
    getConnectionPoint(taskBar, dependencyType, role) {
      if (!taskBar || !taskBar.left || !taskBar.width) {
        console.warn('getConnectionPoint: Êó†ÊïàÁöÑtaskBar', taskBar)
        return 0
      }

      const isMilestone = taskBar.task.type === 'milestone'
      const left = taskBar.left
      const width = taskBar.width

      // ÂØπ‰∫émilestoneÔºåËÄÉËôëdiamondÂΩ¢Áä∂ÔºåË∞ÉÊï¥ËøûÊé•ÁÇπ‰ΩçÁΩÆ
      if (isMilestone) {
        const centerX = left + width / 2
        const diamondRadius = width / 2 // diamondÁöÑÂçäÂæÑ

        if (role === 'from') {
          // Ê∫êmilestoneÁöÑËøûÊé•ÁÇπ
          switch (dependencyType) {
            case 'FS': // Finish-To-Start: ‰ªémilestoneÂè≥‰æß
            case 'FF': // Finish-To-Finish: ‰ªémilestoneÂè≥‰æß
              return centerX + diamondRadius + 5 // Âè≥‰æßÂ§ñÂª∂5px
            case 'SS': // Start-To-Start: ‰ªémilestoneÂ∑¶‰æß
            case 'SF': // Start-To-Finish: ‰ªémilestoneÂ∑¶‰æß
              return centerX - diamondRadius - 5 // Â∑¶‰æßÂ§ñÂª∂5px
            default:
              return centerX + diamondRadius + 5
          }
        } else {
          // ÁõÆÊ†ámilestoneÁöÑËøûÊé•ÁÇπ
          switch (dependencyType) {
            case 'FS': // Finish-To-Start: Âà∞milestoneÂ∑¶‰æß
            case 'SS': // Start-To-Start: Âà∞milestoneÂ∑¶‰æß
              return centerX - diamondRadius - 5 // Â∑¶‰æßÂ§ñÂª∂5px
            case 'FF': // Finish-To-Finish: Âà∞milestoneÂè≥‰æß
            case 'SF': // Start-To-Finish: Âà∞milestoneÂè≥‰æß
              return centerX + diamondRadius + 5 // Âè≥‰æßÂ§ñÂª∂5px
            default:
              return centerX - diamondRadius - 5
          }
        }
      } else {
        // ÊôÆÈÄö‰ªªÂä°ÁöÑËøûÊé•ÁÇπÔºàÂéüÈÄªËæëÔºâ
        if (role === 'from') {
          // Ê∫ê‰ªªÂä°ÁöÑËøûÊé•ÁÇπ
          switch (dependencyType) {
            case 'FS': // Finish-To-Start: ‰ªéÊ∫ê‰ªªÂä°ÁöÑÁªìÊùüÁÇπ
            case 'FF': // Finish-To-Finish: ‰ªéÊ∫ê‰ªªÂä°ÁöÑÁªìÊùüÁÇπ
              return left + width
            case 'SS': // Start-To-Start: ‰ªéÊ∫ê‰ªªÂä°ÁöÑÂºÄÂßãÁÇπ
            case 'SF': // Start-To-Finish: ‰ªéÊ∫ê‰ªªÂä°ÁöÑÂºÄÂßãÁÇπ
              return left
            default:
              return left + width
          }
        } else {
          // ÁõÆÊ†á‰ªªÂä°ÁöÑËøûÊé•ÁÇπ
          switch (dependencyType) {
            case 'FS': // Finish-To-Start: Âà∞ÁõÆÊ†á‰ªªÂä°ÁöÑÂºÄÂßãÁÇπ
            case 'SS': // Start-To-Start: Âà∞ÁõÆÊ†á‰ªªÂä°ÁöÑÂºÄÂßãÁÇπ
              return left
            case 'FF': // Finish-To-Finish: Âà∞ÁõÆÊ†á‰ªªÂä°ÁöÑÁªìÊùüÁÇπ
            case 'SF': // Start-To-Finish: Âà∞ÁõÆÊ†á‰ªªÂä°ÁöÑÁªìÊùüÁÇπ
              return left + width
            default:
              return left
          }
        }
      }
    },

                                                // Ê†πÊçÆÂõõÁßç‰æùËµñÂÖ≥Á≥ªÁ±ªÂûãËÆ°ÁÆó‰∏ìÁî®ËøûÁ∫øË∑ØÂæÑ
    calculateOptimizedPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar) {
      // Ê†πÊçÆÈÖçÁΩÆÈÄâÊã©ËøûÁ∫øÊ†∑Âºè
      switch (this.connectionStyle) {
        case 'bezier':
          // ‰ΩøÁî®Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÊ†∑Âºè
          return this.createBezierPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar)
        case 'z-shaped':
          // ‰ΩøÁî®Ê†áÂáÜÂõõÊÆµÂºèZÂ≠óÂΩ¢ÊäòÁ∫øÁÆóÊ≥ï
          return this.createZShapedPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar)
        case 'smart':
          // ‰ΩøÁî®Êô∫ËÉΩÂåñÁÆÄÁ∫¶ËøûÁ∫øÁÆóÊ≥ï - ‰ºòÂÖàÁõ¥Á∫øÂíåLÂΩ¢ËøûÊé•
          return this.createSmartPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar)
        default:
          // ‰ΩøÁî®‰º†ÁªüËøûÁ∫øÊ†∑Âºè
          return this.createTraditionalPath(fromX, fromY, toX, toY, dependencyType)
      }
    },

        // Êô∫ËÉΩÂåñÁÆÄÁ∫¶ËøûÁ∫øÁÆóÊ≥ï - ‰ºòÂÖàÁõ¥Á∫øÂíåLÂΩ¢ËøûÊé•ÔºåÁ°Æ‰øùÁÆ≠Â§¥Ë¥¥ËøëËäÇÁÇπ‰∏îÊñπÂêëÂáÜÁ°Æ
    createSmartPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar) {
      // ÊúÄÂ∞èÁÆ≠Â§¥È¢ÑÁïôÁ©∫Èó¥ÔºåÁ°Æ‰øùÁÆ≠Â§¥Ë¥¥ËøëËäÇÁÇπ
      const minArrowSpace = 0 // ÂáèÂ∞ëÈ¢ÑÁïôÁ©∫Èó¥ÔºåËÆ©ÁÆ≠Â§¥Êõ¥Ë¥¥ËøëËäÇÁÇπ
      const { from, to } = this.getLineDirection(dependencyType)

      // Ê†πÊçÆËøûÊé•ÊñπÂêëÂæÆË∞ÉÁªàÁÇπ‰ΩçÁΩÆÔºåÁ°Æ‰øùÁÆ≠Â§¥ÊñπÂêëÊ≠£Á°Æ
      let adjustedToX = toX

      // ÁâπÊÆäÂ§ÑÁêÜmilestoneÔºåÁ°Æ‰øùÁÆ≠Â§¥‰∏çË¢´diamondÂΩ¢Áä∂ÈÅÆÊå°‰ΩÜ‰ªçÁÑ∂Ë¥¥Ëøë
      if (toBar && toBar.task.type === 'milestone') {
        const diamondRadius = toBar.width / 2
        if (to === 'left') {
          adjustedToX = toX - diamondRadius // milestoneÂ∑¶‰æßÔºåÁÆ≠Â§¥ÊåáÂêëÂ∑¶‰æß
        } else {
          adjustedToX = toX + diamondRadius // milestoneÂè≥‰æßÔºåÁÆ≠Â§¥ÊåáÂêëÂè≥‰æß
        }
      } else {
        // ÊôÆÈÄö‰ªªÂä°ÔºåÁÆ≠Â§¥Á¥ßË¥¥ËøûÊé•ÁÇπ
        if (to === 'left') {
          adjustedToX = toX // Â∑¶‰æßËøûÊé•ÔºåÁÆ≠Â§¥ÊåáÂêëÂ∑¶‰æß
        } else {
          adjustedToX = toX // Âè≥‰æßËøûÊé•ÔºåÁÆ≠Â§¥ÊåáÂêëÂè≥‰æß
        }
      }

      // ÊÉÖÂÜµ1ÔºöÂêåË°åËøûÁ∫ø - ‰ΩøÁî®Áõ¥Á∫øÊàñÁÆÄÂçïÂºßÁ∫ø
      if (fromY === toY) {
        return this.createSameRowSmartPath(fromX, fromY, adjustedToX, toY, dependencyType, fromBar, toBar)
      }

      // ÊÉÖÂÜµ2ÔºöÂûÇÁõ¥ÂØπÈΩêÊàñÊé•ËøëÂûÇÁõ¥ - ‰ΩøÁî®LÂΩ¢ËøûÁ∫ø
      const horizontalDistance = Math.abs(adjustedToX - fromX)
      if (horizontalDistance < 50) {
        return this.createLShapePath(fromX, fromY, adjustedToX, toY, dependencyType)
      }

      // ÊÉÖÂÜµ3ÔºöÁÆÄÂçïÁõ¥ËßíËøûÁ∫ø‰ºòÂÖà
      if (this.canUseSimpleRightAngle(fromX, fromY, adjustedToX, toY, fromBar, toBar)) {
        return this.createSimpleRightAnglePath(fromX, fromY, adjustedToX, toY, dependencyType)
      }

      // ÊÉÖÂÜµ4ÔºöÂ§çÊùÇÊÉÖÂÜµ‰ΩøÁî®‰ºòÂåñÁöÑZÂ≠óÂΩ¢Ôºå‰ΩÜÂáèÂ∞ëËΩ¨ÂºØÁÇπ
      return this.createOptimizedZPath(fromX, fromY, adjustedToX, toY, dependencyType, fromBar, toBar)
    },

        // ÂêåË°åÊô∫ËÉΩËøûÁ∫ø - ‰ºòÂÖàÁõ¥Á∫øÔºåÂøÖË¶ÅÊó∂‰ΩøÁî®ÊúÄÂ∞èÂºßÂ∫¶ÈÅøËÆ©
    createSameRowSmartPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar) {
      const horizontalDistance = Math.abs(toX - fromX)

      // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ªªÂä°Êù°ÂèØËÉΩÈÅÆÊå°ËøûÁ∫øË∑ØÂæÑ
      const hasObstacle = this.checkHorizontalPathObstacles(fromX, fromY, toX, toY, fromBar, toBar)

      if (!hasObstacle && horizontalDistance > 20) {
        // Áõ¥Á∫øËøûÊé•ÔºåÁÆ≠Â§¥ÊñπÂêëÊúÄÂáÜÁ°Æ
        return `M ${fromX} ${fromY} L ${toX} ${toY}`
      } else {
        // ‰ΩøÁî®‰∏âÊÆµÂºèÁõ¥ËßíË∑ØÂæÑÈÅøËÆ©
        const offsetY = hasObstacle ? -15 : -10 // ÂáèÂ∞èÂûÇÁõ¥ÂÅèÁßª
        return `M ${fromX} ${fromY} L ${fromX} ${fromY + offsetY} L ${toX} ${fromY + offsetY} L ${toX} ${toY}`
      }
    },

        // LÂΩ¢Ë∑ØÂæÑ - ÊúÄÁÆÄ‰∏§ÊÆµÂºèËøûÁ∫øÔºåÁ°Æ‰øùÁÆ≠Â§¥ÊñπÂêëÂáÜÁ°Æ
    createLShapePath(fromX, fromY, toX, toY, dependencyType) {
      const { from, to } = this.getLineDirection(dependencyType)

      // ËÆ°ÁÆóÊúÄ‰ºòËΩ¨ÊäòÁÇπÔºåÁ°Æ‰øùÁÆ≠Â§¥ÊñπÂêëÊ≠£Á°Æ
      if (from === 'right') {
        // ‰ªéÂè≥‰æßÂá∫ÂèëÔºåÊúÄÂ∞èÂåñÊ∞¥Âπ≥Âª∂‰º∏
        const turnX = Math.max(fromX + 15, toX) // ÂáèÂ∞ëÊ∞¥Âπ≥Âª∂‰º∏
        // ‰ΩøÁî®Ê†áÂáÜLÂΩ¢Ë∑ØÂæÑ
        return `M ${fromX} ${fromY} L ${turnX} ${fromY} L ${turnX} ${toY} L ${toX} ${toY}`
      } else {
        // ‰ªéÂ∑¶‰æßÂá∫ÂèëÔºåÊúÄÂ∞èÂåñÊ∞¥Âπ≥Âª∂‰º∏
        const turnX = Math.min(fromX - 15, toX) // ÂáèÂ∞ëÊ∞¥Âπ≥Âª∂‰º∏
        // ‰ΩøÁî®Ê†áÂáÜLÂΩ¢Ë∑ØÂæÑ
        return `M ${fromX} ${fromY} L ${turnX} ${fromY} L ${turnX} ${toY} L ${toX} ${toY}`
      }
    },

    // ÁÆÄÂçïÁõ¥ËßíËøûÁ∫ø - Á°Æ‰øùÁÆ≠Â§¥ÊñπÂêëÂûÇÁõ¥ÂáÜÁ°Æ
    createSimpleRightAnglePath(fromX, fromY, toX, toY, dependencyType) {
      // ‰ΩøÁî®‰∏§ÊÆµÂºèË∑ØÂæÑÔºöÊ∞¥Âπ≥ÊÆµ + ÂûÇÁõ¥ÊÆµÔºåÊúÄÂêé‰∏ÄÊÆµÁ°Æ‰øùÁÆ≠Â§¥ÊñπÂêëÂûÇÁõ¥
      return `M ${fromX} ${fromY} L ${toX} ${fromY} L ${toX} ${toY}`
    },

        // ‰ºòÂåñÁöÑZÂ≠óÂΩ¢Ë∑ØÂæÑ - ÂáèÂ∞ëËΩ¨ÂºØÁÇπÔºåÁ°Æ‰øùÁÆ≠Â§¥Ë¥¥Ëøë‰∏îÊñπÂêëÂáÜÁ°Æ
    createOptimizedZPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar) {
      const horizontalOffset = Math.min(20, Math.abs(toX - fromX) * 0.15) // Ëøõ‰∏ÄÊ≠•ÂáèÂ∞ëÂÅèÁßªÈáè
      const { from, to } = this.getLineDirection(dependencyType)

      const offsetX = from === 'right' ? horizontalOffset : -horizontalOffset
      const midX = fromX + offsetX

      // ‰ΩøÁî®Ê†áÂáÜ‰∏âÊÆµÂºèË∑ØÂæÑÔºå‰øùÊåÅÁõ¥Ëßí
      return `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${toY} L ${toX} ${toY}`
    },

    // Ê£ÄÊü•Ê∞¥Âπ≥Ë∑ØÂæÑÊòØÂê¶ÊúâÈöúÁ¢çÁâ©
    checkHorizontalPathObstacles(fromX, fromY, toX, toY, fromBar, toBar) {
      // ÁÆÄÂåñÁöÑÈöúÁ¢çÁâ©Ê£ÄÊµã - Ê£ÄÊü•Ë∑ØÂæÑ‰∏äÊòØÂê¶ÊúâÂÖ∂‰ªñ‰ªªÂä°Êù°
      const minX = Math.min(fromX, toX)
      const maxX = Math.max(fromX, toX)

      // Ê£ÄÊü•ÂêåË°åÊòØÂê¶ÊúâÂÖ∂‰ªñ‰ªªÂä°ÂèØËÉΩÈÄ†ÊàêËßÜËßâÂÜ≤Á™Å
      const sameRowTasks = this.taskBars.filter(bar => {
        if (!bar || bar === fromBar || bar === toBar) return false
        const barY = (bar.index || 0) * 28 + 14
        return Math.abs(barY - fromY) < 10 // ÂêåË°åÊàñÊé•ËøëÂêåË°å
      })

      return sameRowTasks.some(bar => {
        const barLeft = bar.left || 0
        const barRight = barLeft + (bar.width || 0)
        // Ê£ÄÊü•‰ªªÂä°Êù°ÊòØÂê¶Âú®ËøûÁ∫øË∑ØÂæÑ‰∏ä
        return (barLeft < maxX && barRight > minX)
      })
    },

    // Âà§Êñ≠ÊòØÂê¶ÂèØ‰ª•‰ΩøÁî®ÁÆÄÂçïÁõ¥ËßíËøûÁ∫ø
    canUseSimpleRightAngle(fromX, fromY, toX, toY, fromBar, toBar) {
      // Ê£ÄÊü•ÂûÇÁõ¥Ë∑ØÂæÑÂíåÊ∞¥Âπ≥Ë∑ØÂæÑÊòØÂê¶ÈÉΩÊ≤°ÊúâÈöúÁ¢çÁâ©
      const hasVerticalObstacle = this.checkVerticalPathObstacles(fromX, fromY, toX, toY, fromBar, toBar)
      const hasHorizontalObstacle = this.checkHorizontalPathObstacles(toX, fromY, toX, toY, fromBar, toBar)

      return !hasVerticalObstacle && !hasHorizontalObstacle
    },

    // Ê£ÄÊü•ÂûÇÁõ¥Ë∑ØÂæÑÊòØÂê¶ÊúâÈöúÁ¢çÁâ©
    checkVerticalPathObstacles(fromX, fromY, toX, toY, fromBar, toBar) {
      const minY = Math.min(fromY, toY)
      const maxY = Math.max(fromY, toY)

      // Ê£ÄÊü•ÂûÇÁõ¥Ë∑ØÂæÑ‰∏äÊòØÂê¶Êúâ‰ªªÂä°Êù°
      return this.taskBars.some(bar => {
        if (!bar || bar === fromBar || bar === toBar) return false

        const barY = (bar.index || 0) * 28 + 14
        const barLeft = bar.left || 0
        const barRight = barLeft + (bar.width || 0)

        // Ê£ÄÊü•‰ªªÂä°Êù°ÊòØÂê¶Âú®ÂûÇÁõ¥Ë∑ØÂæÑ‰∏ä
        return (barY >= minY && barY <= maxY &&
                barLeft <= toX && barRight >= toX)
      })
    },

        // ÂàõÂª∫Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øË∑ØÂæÑ
    createBezierPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar) {
      // ËÆ°ÁÆóÂü∫Á°ÄÊ∞¥Âπ≥ÂÅèÁßª
      const baseOffset = this.calculateHorizontalOffset(dependencyType, fromBar, toBar)

      // Ê†πÊçÆ‰æùËµñÁ±ªÂûãÂíåÊñπÂêëË∞ÉÊï¥ÊéßÂà∂ÁÇπ
      const { from, to } = this.getLineDirection(dependencyType)

      // ËÆ°ÁÆóÂûÇÁõ¥Ë∑ùÁ¶ªÂíåÂä®ÊÄÅÂÅèÁßª
      const verticalDist = Math.abs(toY - fromY)
      const horizontalDist = Math.abs(toX - fromX)

      // Âä®ÊÄÅË∞ÉÊï¥Ê∞¥Âπ≥ÂÅèÁßªÔºå‰ΩøÂÖ∂‰∏éÂûÇÁõ¥Ë∑ùÁ¶ªÊàêÊØî‰æã
      const dynamicOffset = Math.min(baseOffset, verticalDist * 0.5)

      // ËÆ°ÁÆóÊéßÂà∂ÁÇπ
      let cp1x, cp2x

      // Â§ÑÁêÜÂêåË°åËøûÁ∫øÁöÑÁâπÊÆäÊÉÖÂÜµ
      if (fromY === toY) {
        // ‰ΩøÁî®Êõ¥Âπ≥ÊªëÁöÑÊ∞¥Âπ≥Êõ≤Á∫ø
        const midX = (fromX + toX) / 2
        const smoothOffset = Math.min(Math.abs(toX - fromX) * 0.2, baseOffset)

        if (from === 'right') {
          cp1x = fromX + smoothOffset
        } else {
          cp1x = fromX - smoothOffset
        }

        if (to === 'right') {
          cp2x = toX + smoothOffset
        } else {
          cp2x = toX - smoothOffset
        }

        return `M ${fromX} ${fromY} C ${cp1x} ${fromY} ${cp2x} ${toY} ${toX} ${toY}`
      }

      // ËÆ°ÁÆóÂûÇÁõ¥ÊñπÂêëÁöÑÊéßÂà∂ÁÇπÂÅèÁßª
      const verticalOffset = verticalDist * 0.2
      const cp1y = fromY + (toY > fromY ? verticalOffset : -verticalOffset)
      const cp2y = toY - (toY > fromY ? verticalOffset : -verticalOffset)

      // Ê†πÊçÆËøûÊé•ÊñπÂêëÂíåË∑ùÁ¶ªÂä®ÊÄÅË∞ÉÊï¥Ê∞¥Âπ≥ÊéßÂà∂ÁÇπ
      if (from === 'right') {
        cp1x = fromX + Math.min(dynamicOffset, horizontalDist * 0.4)
      } else {
        cp1x = fromX - Math.min(dynamicOffset, horizontalDist * 0.4)
      }

      if (to === 'right') {
        cp2x = toX + Math.min(dynamicOffset, horizontalDist * 0.4)
      } else {
        cp2x = toX - Math.min(dynamicOffset, horizontalDist * 0.4)
      }

      // ÂàõÂª∫‰∏âÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øË∑ØÂæÑÔºå‰ΩøÁî®ÂûÇÁõ¥ÂÅèÁßªÂÆûÁé∞Êõ¥Ëá™ÁÑ∂ÁöÑÊõ≤Á∫ø
      return `M ${fromX} ${fromY} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${toX} ${toY}`
    },

            // ‰ºòÂåñÁöÑZÂ≠óÂΩ¢ÊäòÁ∫øÁÆóÊ≥ï - Êô∫ËÉΩËΩ¨ÂºØÂ§ÑÁêÜÔºåÁÆ≠Â§¥ÊåáÂêëÈ°∂ÈÉ®
    createZShapedPath(fromX, fromY, toX, toY, dependencyType, fromBar, toBar) {
      // Ê†πÊçÆ‰æùËµñÁ±ªÂûãÁ°ÆÂÆöËøûÁ∫øËµ∑ÂßãÂíåÁªìÊùüÊñπÂêë
      const { from, to } = this.getLineDirection(dependencyType)

      // ËÆ°ÁÆóÊ∞¥Âπ≥ÂíåÂûÇÁõ¥Ë∑ùÁ¶ª
      const horizontalDist = Math.abs(toX - fromX)
      const verticalDist = Math.abs(toY - fromY)

      // Ëé∑Âèñ‰ªªÂä°Êù°‰ø°ÊÅØ
        const fromTaskWidth = fromBar ? fromBar.width : 0
        const toTaskWidth = toBar ? toBar.width : 0

            // Êô∫ËÉΩÂà§Êñ≠ËøûÊé•ÁÇπ‰ΩçÁΩÆ
      const taskHeight = 28 // ‰ªªÂä°Êù°È´òÂ∫¶

      // ËÆ°ÁÆóËµ∑ÁÇπ‰ΩçÁΩÆ
      let adjustedFromY = fromY
      if (from === 'right') {
        adjustedFromY = fromY - taskHeight / 4 // Âè≥‰æßÂá∫ÂèëÊó∂Ôºå‰ªé‰∏≠‰∏äÈÉ®Âá∫Âèë
        } else {
        adjustedFromY = fromY - taskHeight / 4 // Â∑¶‰æßÂá∫ÂèëÊó∂Ôºå‰πü‰ªé‰∏≠‰∏äÈÉ®Âá∫Âèë
      }

      // Êô∫ËÉΩÂà§Êñ≠ÁªàÁÇπ‰ΩçÁΩÆ
      let adjustedToX = toX
      let adjustedToY = toY
      const verticalDiff = toY - fromY

      if (Math.abs(verticalDiff) > taskHeight) {
        // ÂûÇÁõ¥Ë∑ùÁ¶ªËæÉÂ§ßÊó∂ÔºåËøûÊé•Âà∞È°∂ÈÉ®ÊàñÂ∫ïÈÉ®
        if (verticalDiff > 0) {
          // ÁõÆÊ†áÂú®‰∏ãÊñπÔºåËøûÊé•Âà∞È°∂ÈÉ®
          adjustedToY = toY - taskHeight / 2
        } else {
          // ÁõÆÊ†áÂú®‰∏äÊñπÔºåËøûÊé•Âà∞Â∫ïÈÉ®
          adjustedToY = toY + taskHeight / 2
        }
      } else {
        // ÂûÇÁõ¥Ë∑ùÁ¶ªËæÉÂ∞èÊó∂ÔºåËøûÊé•Âà∞‰æßÈù¢‰∏≠ÁÇπ
        adjustedToY = toY
        if (to === 'left') {
          adjustedToX = toX // Â∑¶‰æßËøûÊé•ÁÇπ
        } else {
          adjustedToX = toX // Âè≥‰æßËøûÊé•ÁÇπ
        }
      }

      // Â§ÑÁêÜÂêåË°åËøûÁ∫øÁöÑÁâπÊÆäÊÉÖÂÜµ
      if (fromY === toY) {
        const tasksMayOverlap = fromTaskWidth > 0 && toTaskWidth > 0 &&
          horizontalDist < (fromTaskWidth + toTaskWidth) * 1.2

        if (tasksMayOverlap) {
          // ‰ΩøÁî®‰∏âÊÆµÂºèË∑ØÂæÑÈÅøÂºÄ‰ªªÂä°Êù°ÔºåÂπ∂Á°Æ‰øùÁÆ≠Â§¥Âú®Â§ñÈÉ®
          const yOffset = -10 // ÂáèÂ∞èÂêë‰∏äÂÅèÁßª
          return `M ${fromX} ${adjustedFromY} L ${fromX} ${adjustedFromY + yOffset} L ${adjustedToX} ${adjustedFromY + yOffset} L ${adjustedToX} ${adjustedToY}`
        } else {
          // Ë∑ùÁ¶ªÂ§üËøúÊó∂‰πüË¶ÅË∞ÉÊï¥ÁªàÁÇπ‰ΩçÁΩÆ
          return `M ${fromX} ${adjustedFromY} L ${adjustedToX} ${adjustedToY}`
        }
      }

      // Âà§Êñ≠ÊòØÂê¶ÈúÄË¶ÅËΩ¨ÂºØ
      const needsTurn = (from === 'right' && toX < fromX) || (from === 'left' && toX > fromX)

      if (needsTurn) {
        // ËÆ°ÁÆóËΩ¨ÂºØÁÇπÁöÑÊ∞¥Âπ≥‰ΩçÁΩÆÔºåËÄÉËôëÁÆ≠Â§¥Á©∫Èó¥
        const turnOffset = 15 // ÂáèÂ∞èËΩ¨ÂºØÂÅèÁßª
        const turnX = from === 'right' ?
          Math.max(fromX + turnOffset, (fromX + adjustedToX) / 2) :
          Math.min(fromX - turnOffset, (fromX + adjustedToX) / 2)

        // Ê†πÊçÆÂûÇÁõ¥Ë∑ùÁ¶ªÂÜ≥ÂÆöÊòØÂê¶ÈúÄË¶ÅÈ¢ùÂ§ñÁöÑ‰∏≠Èó¥ÁÇπ
        if (verticalDist > 50) {
          // ‰ΩøÁî®ÂõõÊÆµÂºèË∑ØÂæÑÔºåÂú®ÂûÇÁõ¥ÊñπÂêëÊ∑ªÂä†‰∏Ä‰∏™‰∏≠Èó¥ÁÇπ
          const midY = (adjustedFromY + adjustedToY) / 2
          return `M ${fromX} ${adjustedFromY} L ${turnX} ${adjustedFromY} L ${turnX} ${midY} L ${adjustedToX} ${midY} L ${adjustedToX} ${adjustedToY}`
      } else {
        // ‰ΩøÁî®‰∏âÊÆµÂºèË∑ØÂæÑ
          return `M ${fromX} ${adjustedFromY} L ${turnX} ${adjustedFromY} L ${turnX} ${adjustedToY} L ${adjustedToX} ${adjustedToY}`
        }
      } else {
        // ‰∏çÈúÄË¶ÅËΩ¨ÂºØÊó∂‰ΩøÁî®ÁÆÄÂçïÁöÑLÂΩ¢Ë∑ØÂæÑÔºå‰ΩÜ‰ªçÈúÄË∞ÉÊï¥ÁªàÁÇπ
        return `M ${fromX} ${adjustedFromY} L ${adjustedToX} ${adjustedFromY} L ${adjustedToX} ${adjustedToY}`
      }
    },

    // ËÆ°ÁÆóÊ∞¥Âπ≥ÂÅèÁßªË∑ùÁ¶ª - Ê†πÊçÆ‰æùËµñÁ±ªÂûãÂíåËäÇÁÇπÈó¥Ë∑ùÊô∫ËÉΩË∞ÉÊï¥ÔºåÈõÜÊàêÈÅøÈöúÁÆóÊ≥ï
    calculateHorizontalOffset(dependencyType, fromBar, toBar) {
      const baseOffset = 25 // ÂáèÂ∞ëÂü∫Á°ÄÂÅèÁßªË∑ùÁ¶ªÔºåËÆ©ËøûÁ∫øÊõ¥ÁÆÄÊ¥Å

      // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûú‰ªªÂä°Êù°‰ø°ÊÅØ‰∏çÂÆåÊï¥Ôºå‰ΩøÁî®ÈªòËÆ§ÂÅèÁßª
      if (!fromBar || !toBar || typeof fromBar.left !== 'number' || typeof toBar.left !== 'number') {
        return baseOffset
      }

      const taskDistance = Math.abs(toBar.left - fromBar.left)

      // Âü∫Á°ÄÂÅèÁßªËÆ°ÁÆó
      let offset = baseOffset
      if (taskDistance < 100) {
        offset = baseOffset + 20 // Ë∑ùÁ¶ªËæÉËøëÊó∂Â¢ûÂä†ÂÅèÁßª
      } else if (taskDistance > 300) {
        offset = Math.max(baseOffset - 10, 20) // Ë∑ùÁ¶ªËæÉËøúÊó∂ÂáèÂ∞ëÂÅèÁßª
      }

      // ÈõÜÊàêÈÅøÈöúÂÅèÁßª - ÈÅøÂÖçËøûÁ∫ø‰∫§ÂèâÂíåÁ©øËøáËäÇÁÇπ
      try {
        const fromY = (fromBar.index || 0) * 28 + 14
        const toY = (toBar.index || 0) * 28 + 14
        const fromX = this.getConnectionPoint(fromBar, dependencyType, 'from')
        const toX = this.getConnectionPoint(toBar, dependencyType, 'to')

        const avoidanceOffset = this.calculateCollisionAvoidanceOffset(
          fromX, fromY, toX, toY, fromBar, toBar, dependencyType
        )

        // Â∫îÁî®ÈÅøÈöúÂÅèÁßªÔºåÂ¢ûÂä†ËøûÁ∫øÈó¥ÁöÑË∑ùÁ¶ª
        offset += Math.abs(avoidanceOffset.horizontal)
      } catch (error) {
        // ÈÅøÈöúÁÆóÊ≥ïÂá∫ÈîôÊó∂‰ΩøÁî®Âü∫Á°ÄÂÅèÁßª
        console.warn('ÈÅøÈöúÁÆóÊ≥ïËÆ°ÁÆóÂ§±Ë¥•Ôºå‰ΩøÁî®Âü∫Á°ÄÂÅèÁßª', error)
      }

      return offset
    },

    // ËÆ°ÁÆóÂûÇÁõ¥Èó¥Ë∑ù - ÈÅøÂÖçÂ§öÊù°ËøûÁ∫øÈáçÂè†
    calculateVerticalSpacing(fromBar, toBar) {
      const baseSpacing = 20

      // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÂ¶ÇÊûú‰ªªÂä°Êù°‰ø°ÊÅØ‰∏çÂÆåÊï¥Ôºå‰ΩøÁî®ÈªòËÆ§Èó¥Ë∑ù
      if (!fromBar || !toBar || typeof fromBar.index !== 'number' || typeof toBar.index !== 'number') {
        return baseSpacing
      }

      const rowDifference = Math.abs(toBar.index - fromBar.index)

      // Ë°åË∑ùËæÉÂ∞èÊó∂ÂáèÂ∞ëÂûÇÁõ¥Èó¥Ë∑ùÔºåË°åË∑ùËæÉÂ§ßÊó∂Â¢ûÂä†ÂûÇÁõ¥Èó¥Ë∑ù
      if (rowDifference <= 1) {
        return baseSpacing
      } else if (rowDifference <= 3) {
        return baseSpacing + 10
      } else {
        return baseSpacing + Math.min(rowDifference * 5, 30)
      }
    },

    // Ëé∑ÂèñËøûÁ∫øÊñπÂêë‰ø°ÊÅØ - Ê†πÊçÆ‰æùËµñÁ±ªÂûãÁ°ÆÂÆöËµ∑ÂßãÂíåÁªìÊùüÊñπÂêë
    getLineDirection(dependencyType) {
      switch (dependencyType) {
        case 'FS': // Finish-To-Start: Âè≥‰æßÂá∫ÂèëÔºåÂ∑¶‰æßÂà∞Ëææ
          return { from: 'right', to: 'left' }
        case 'SS': // Start-To-Start: Â∑¶‰æßÂá∫ÂèëÔºåÂ∑¶‰æßÂà∞Ëææ
          return { from: 'left', to: 'left' }
        case 'FF': // Finish-To-Finish: Âè≥‰æßÂá∫ÂèëÔºåÂè≥‰æßÂà∞Ëææ
          return { from: 'right', to: 'right' }
        case 'SF': // Start-To-Finish: Â∑¶‰æßÂá∫ÂèëÔºåÂè≥‰æßÂà∞Ëææ
          return { from: 'left', to: 'right' }
        default:
          return { from: 'right', to: 'left' }
      }
    },

    // ÂàõÂª∫ÂêåË°åZÂ≠óÂΩ¢Ë∑ØÂæÑ - Â§ÑÁêÜÊ∫êËäÇÁÇπÂíåÁõÆÊ†áËäÇÁÇπÂú®Âêå‰∏ÄË°åÁöÑÊÉÖÂÜµ
    createSameRowZPath(fromX, fromY, toX, toY, direction, horizontalOffset, verticalSpacing) {
      const { from: fromDirection, to: toDirection } = direction

      // ËÆ°ÁÆóÈÅøËÆ©È´òÂ∫¶Ôºå‰ºòÂÖà‰ΩøÁî®‰∏äÊñπÈÅøËÆ©
      const avoidanceY = fromY - verticalSpacing

      // ËÆ°ÁÆóÊ∞¥Âπ≥ÊÆµÁöÑËµ∑ÁÇπÂíåÁªàÁÇπ
      const startOffset = fromDirection === 'right' ? horizontalOffset : -horizontalOffset
      const endOffset = toDirection === 'right' ? horizontalOffset : -horizontalOffset

      const p1X = fromX + startOffset
      const p2X = toX + endOffset

      // Â¶ÇÊûúËøûÁ∫øË∑ùÁ¶ªÂæàÁü≠Ôºå‰ΩøÁî®Êõ≤Á∫øËøûÊé•‰ª•Ëé∑ÂæóÊõ¥Â•ΩÁöÑËßÜËßâÊïàÊûú
      if (Math.abs(toX - fromX) < 80) {
        const midX = (fromX + toX) / 2
        const controlY = avoidanceY - 10 // Â¢ûÂä†Êõ≤Á∫øÂºØÊõ≤Â∫¶
        return `M ${fromX} ${fromY} Q ${midX} ${controlY} ${toX} ${toY}`
      }

      // Ê†áÂáÜÂõõÊÆµÂºèZÂ≠óÂΩ¢Ë∑ØÂæÑÔºöÊ∞¥Âπ≥‚ÜíÂûÇÁõ¥‚ÜíÊ∞¥Âπ≥‚ÜíÂûÇÁõ¥
      return `M ${fromX} ${fromY} L ${p1X} ${fromY} L ${p1X} ${avoidanceY} L ${p2X} ${avoidanceY} L ${p2X} ${toY} L ${toX} ${toY}`
    },

    // ÂàõÂª∫Ê†áÂáÜÂõõÊÆµÂºèZÂ≠óÂΩ¢Ë∑ØÂæÑ - Â§ÑÁêÜ‰∏çÂêåË°å‰πãÈó¥ÁöÑËøûÁ∫ø
    createStandardZPath(fromX, fromY, toX, toY, direction, horizontalOffset, verticalSpacing) {
      const { from: fromDirection, to: toDirection } = direction

      // ËÆ°ÁÆóÂõõÊÆµÂºèË∑ØÂæÑÁöÑÂÖ≥ÈîÆÁÇπ
      const startOffset = fromDirection === 'right' ? horizontalOffset : -horizontalOffset
      const endOffset = toDirection === 'right' ? horizontalOffset : -horizontalOffset

      // Á¨¨‰∏ÄÊÆµÔºöÊ∞¥Âπ≥ÊÆµ - ‰ªéËøûÊé•ÁÇπÊ∞¥Âπ≥Âª∂‰º∏
      const p1X = fromX + startOffset
      const p1Y = fromY

      // Êô∫ËÉΩËÆ°ÁÆóËΩ¨ÊäòÁÇπ‰ΩçÁΩÆÔºåÁ°Æ‰øùZÂ≠óÂΩ¢ÁæéËßÇ
      let midY
      const yDistance = Math.abs(toY - fromY)

      if (yDistance > 60) {
        // Ë∑ùÁ¶ªËæÉËøúÊó∂Ôºå‰ΩøÁî®Êõ¥Âπ≥ÊªëÁöÑ‰∏≠Èó¥‰ΩçÁΩÆ
        midY = fromY + (toY - fromY) * 0.5
      } else {
        // Ë∑ùÁ¶ªËæÉËøëÊó∂Ôºå‰ΩøÁî®ÂÅèÂêëËµ∑ÁÇπÁöÑ‰ΩçÁΩÆÔºåÈÅøÂÖçËøûÁ∫øËøá‰∫éÈô°Â≥≠
        midY = fromY + (toY - fromY) * 0.3
      }

      // Á¨¨‰∫åÊÆµÔºöÂûÇÁõ¥ÊÆµ - ËΩ¨Âêë‰∏≠Èó¥Ê∞¥Âπ≥Á∫ø
      const p2X = p1X
      const p2Y = midY

      // Á¨¨‰∏âÊÆµÔºöÊ∞¥Âπ≥ÊÆµ - Âú®‰∏≠Èó¥È´òÂ∫¶Ê∞¥Âπ≥ÁßªÂä®Âà∞ÁõÆÊ†áÂå∫Âüü
      const p3X = toX + endOffset
      const p3Y = midY

      // Á¨¨ÂõõÊÆµÔºöÂûÇÁõ¥ÊÆµÂà∞ËææÁõÆÊ†á
      const p4X = p3X
      const p4Y = toY

      // ÊûÑÂª∫‰ºòÂåñÁöÑÂõõÊÆµÂºèZÂ≠óÂΩ¢SVGË∑ØÂæÑ
      // Á°Æ‰øùË∑ØÂæÑÁÇπÁ≤æÁ°ÆÂà∞Êï¥Êï∞ÔºåÈÅøÂÖçÊ®°Á≥äÊ∏≤Êüì
      const points = [
        [Math.round(fromX), Math.round(fromY)],
        [Math.round(p1X), Math.round(p1Y)],
        [Math.round(p2X), Math.round(p2Y)],
        [Math.round(p3X), Math.round(p3Y)],
        [Math.round(p4X), Math.round(p4Y)],
        [Math.round(toX), Math.round(toY)]
      ]

      return `M ${points[0][0]} ${points[0][1]} L ${points[1][0]} ${points[1][1]} L ${points[2][0]} ${points[2][1]} L ${points[3][0]} ${points[3][1]} L ${points[4][0]} ${points[4][1]} L ${points[5][0]} ${points[5][1]}`
    },

    // ‰º†ÁªüËøûÁ∫øÁÆóÊ≥ï - ÂêëÂêéÂÖºÂÆπ‰øùÁïô
    createTraditionalPath(fromX, fromY, toX, toY, dependencyType) {
      const offset = 30 // ‰º†ÁªüÂÅèÁßªË∑ùÁ¶ª

      // ÂêåË°åËøûÊé•Â§ÑÁêÜ - Êô∫ËÉΩÈÅøËÆ©
      if (fromY === toY) {
        const avoidanceOffset = 15
        let midY = fromY - avoidanceOffset

        // ËæπÁïåÊ£ÄÊµãÔºöÂ¶ÇÊûú‰∏äÊñπÁ©∫Èó¥‰∏çË∂≥Ôºå‰ΩøÁî®‰∏ãÊñπÈÅøËÆ©
        if (fromY - avoidanceOffset < 10) {
          midY = fromY + 30
        }

        if (Math.abs(toX - fromX) < 50) {
          return `M ${fromX} ${fromY} Q ${(fromX + toX) / 2} ${midY} ${toX} ${toY}`
        }
        return `M ${fromX} ${fromY} L ${fromX} ${midY} L ${toX} ${midY} L ${toX} ${toY}`
      }

      // ‰º†ÁªüÁöÑÂàÜÁ±ªÂûãËøûÁ∫øÂ§ÑÁêÜ
      switch (dependencyType) {
        case 'SS': // Start-To-Start
          return this.createTraditionalSSPath(fromX, fromY, toX, toY, offset)
        case 'SF': // Start-To-Finish
          return this.createTraditionalSFPath(fromX, fromY, toX, toY, offset)
        case 'FS': // Finish-To-Start
          return this.createTraditionalFSPath(fromX, fromY, toX, toY, offset)
        case 'FF': // Finish-To-Finish
          return this.createTraditionalFFPath(fromX, fromY, toX, toY, offset)
        default:
          return this.createTraditionalFSPath(fromX, fromY, toX, toY, offset)
      }
    },

    // ‰º†ÁªüFSË∑ØÂæÑ
    createTraditionalFSPath(fromX, fromY, toX, toY, offset) {
      const avoidanceOffset = 15
      const minY = Math.min(fromY, toY)
      const maxY = Math.max(fromY, toY)
      const containerHeight = this.actualChartHeight || 600

      let avoidanceY = minY - avoidanceOffset
      if (minY - avoidanceOffset < 10) {
        const downAvoidance = maxY + 30
        avoidanceY = downAvoidance > containerHeight - 20 ? minY - 5 : downAvoidance
      }

      const rightExtend = fromX + offset
      const leftExtend = toX - offset
      return `M ${fromX} ${fromY} L ${rightExtend} ${fromY} L ${rightExtend} ${avoidanceY} L ${leftExtend} ${avoidanceY} L ${leftExtend} ${toY} L ${toX} ${toY}`
    },

    // ‰º†ÁªüSSË∑ØÂæÑ
    createTraditionalSSPath(fromX, fromY, toX, toY, offset) {
      const avoidanceOffset = 15
      const minY = Math.min(fromY, toY)
      const leftExtend = fromX - offset
      const avoidanceY = minY - avoidanceOffset

      return `M ${fromX} ${fromY} L ${leftExtend} ${fromY} L ${leftExtend} ${avoidanceY} L ${toX - offset} ${avoidanceY} L ${toX - offset} ${toY} L ${toX} ${toY}`
    },

    // ‰º†ÁªüSFË∑ØÂæÑ
    createTraditionalSFPath(fromX, fromY, toX, toY, offset) {
      const avoidanceOffset = 15
      const minY = Math.min(fromY, toY)
      const leftExtend = fromX - offset
      const rightExtend = toX + offset
      const avoidanceY = minY - avoidanceOffset

      return `M ${fromX} ${fromY} L ${leftExtend} ${fromY} L ${leftExtend} ${avoidanceY} L ${rightExtend} ${avoidanceY} L ${rightExtend} ${toY} L ${toX} ${toY}`
    },

    // ‰º†ÁªüFFË∑ØÂæÑ
    createTraditionalFFPath(fromX, fromY, toX, toY, offset) {
      const avoidanceOffset = 15
      const minY = Math.min(fromY, toY)
      const rightExtend1 = fromX + offset
      const rightExtend2 = toX + offset
      const avoidanceY = minY - avoidanceOffset

      return `M ${fromX} ${fromY} L ${rightExtend1} ${fromY} L ${rightExtend1} ${avoidanceY} L ${rightExtend2} ${avoidanceY} L ${rightExtend2} ${toY} L ${toX} ${toY}`
    },

        // ËøûÁ∫øÈÅøÈöúÁÆóÊ≥ï - Ê£ÄÊµãÂπ∂ÈÅøÂÖçËøûÁ∫ø‰∫§Âèâ/Á©øËøáËäÇÁÇπ
    calculateCollisionAvoidanceOffset(fromX, fromY, toX, toY, fromBar, toBar, dependencyType) {
      const connectionKey = `${fromBar.task.id}_${toBar.task.id}`

      // ÂÆâÂÖ®Ê£ÄÊü•MapÊòØÂê¶Â∑≤ÂàùÂßãÂåñ
      if (!this.lineOffsetMap) {
        this.lineOffsetMap = new Map()
      }

      // Ê£ÄÊü•ÁºìÂ≠ò
      if (this.lineOffsetMap.has(connectionKey)) {
        return this.lineOffsetMap.get(connectionKey)
      }

      // ËÆ°ÁÆóÂü∫Á°ÄÂÅèÁßª
      let horizontalOffset = 0
      let verticalOffset = 0

      // 1. Ê£ÄÊµã‰∏éÂÖ∂‰ªñ‰ªªÂä°ËäÇÁÇπÁöÑÂÜ≤Á™Å
      const conflictingBars = this.detectNodeConflicts(fromX, fromY, toX, toY, fromBar, toBar)
      if (conflictingBars.length > 0) {
        horizontalOffset += conflictingBars.length * 8 // ÊØè‰∏™ÂÜ≤Á™ÅËäÇÁÇπÂ¢ûÂä†8pxÂÅèÁßª
      }

      // 2. Ê£ÄÊµã‰∏éÂÖ∂‰ªñËøûÁ∫øÁöÑÂÜ≤Á™Å
      const conflictingLines = this.detectLineConflicts(fromX, fromY, toX, toY, connectionKey)
      if (conflictingLines.length > 0) {
        verticalOffset += conflictingLines.length * 12 // ÊØèÊù°ÂÜ≤Á™ÅËøûÁ∫øÂ¢ûÂä†12pxÂÅèÁßª
      }

      // 3. Ê†πÊçÆ‰æùËµñÁ±ªÂûãË∞ÉÊï¥ÂÅèÁßªÊñπÂêë
      const direction = this.getLineDirection(dependencyType)
      if (direction.from === 'left') {
        horizontalOffset = -horizontalOffset
      }

      const offset = { horizontal: horizontalOffset, vertical: verticalOffset }
      this.lineOffsetMap.set(connectionKey, offset)
      return offset
    },

    // Ê£ÄÊµãËäÇÁÇπÂÜ≤Á™Å - ËøûÁ∫øÊòØÂê¶‰ºöÁ©øËøáÂÖ∂‰ªñ‰ªªÂä°ËäÇÁÇπ
    detectNodeConflicts(fromX, fromY, toX, toY, fromBar, toBar) {
      const conflictingBars = []
      const lineRect = this.getLineRect(fromX, fromY, toX, toY)

      for (const bar of this.taskBars) {
        // Ë∑≥ËøáËµ∑ÂßãÂíåÁªìÊùü‰ªªÂä°
        if (bar.task.id === fromBar.task.id || bar.task.id === toBar.task.id) {
          continue
        }

        // Ê£ÄÊü•‰ªªÂä°ËäÇÁÇπÊòØÂê¶‰∏éËøûÁ∫øË∑ØÂæÑÁõ∏‰∫§
        const barY = (bar.index || 0) * 28
        const barRect = {
          left: bar.left,
          top: barY,
          right: bar.left + bar.width,
          bottom: barY + 28
        }

        if (this.isRectIntersecting(lineRect, barRect)) {
          conflictingBars.push(bar)
        }
      }

      return conflictingBars
    },

    // Ê£ÄÊµãËøûÁ∫øÂÜ≤Á™Å - ËøûÁ∫øÊòØÂê¶‰∏éÂÖ∂‰ªñËøûÁ∫øÈáçÂè†
    detectLineConflicts(fromX, fromY, toX, toY, currentConnectionKey) {
      const conflictingLines = []
      const currentLineRect = this.getLineRect(fromX, fromY, toX, toY)

      // ÂÆâÂÖ®Ê£ÄÊü•MapÊòØÂê¶Â∑≤ÂàùÂßãÂåñ
      if (!this.connectionConflictMap) {
        this.connectionConflictMap = new Map()
      }

      // ÈÅçÂéÜÂ∑≤ÁºìÂ≠òÁöÑËøûÁ∫ø
      for (const [key, cachedLine] of this.connectionConflictMap) {
        if (key === currentConnectionKey) continue

        const cachedLineRect = cachedLine.rect
        if (this.isRectIntersecting(currentLineRect, cachedLineRect)) {
          conflictingLines.push(cachedLine)
        }
      }

      // ÁºìÂ≠òÂΩìÂâçËøûÁ∫ø‰ø°ÊÅØ
      this.connectionConflictMap.set(currentConnectionKey, {
        rect: currentLineRect,
        fromX, fromY, toX, toY
      })

      return conflictingLines
    },

    // Ëé∑ÂèñËøûÁ∫øÁöÑËæπÁïåÁü©ÂΩ¢
    getLineRect(fromX, fromY, toX, toY) {
      const padding = 5 // ËøûÁ∫øËæπÁïåÊâ©Â±ï
      return {
        left: Math.min(fromX, toX) - padding,
        top: Math.min(fromY, toY) - padding,
        right: Math.max(fromX, toX) + padding,
        bottom: Math.max(fromY, toY) + padding
      }
    },

    // Âà§Êñ≠‰∏§‰∏™Áü©ÂΩ¢ÊòØÂê¶Áõ∏‰∫§
    isRectIntersecting(rect1, rect2) {
      return !(rect1.right < rect2.left ||
              rect1.left > rect2.right ||
              rect1.bottom < rect2.top ||
              rect1.top > rect2.bottom)
    },

                                        // SS: Start-To-Start ËøûÁ∫øË∑ØÂæÑ - ‰ΩøÁî®ZÂ≠óÂΩ¢ÁÆóÊ≥ï
    createStartToStartPath(fromX, fromY, toX, toY, offset) {
      // ‰ΩøÁî®Áªü‰∏ÄÁöÑZÂ≠óÂΩ¢ÁÆóÊ≥ïÔºå‰øùÊåÅ‰ª£Á†Å‰∏ÄËá¥ÊÄß
      return this.createZShapedPath(fromX, fromY, toX, toY, 'SS', null, null)
    },

                        // SF: Start-To-Finish ËøûÁ∫øË∑ØÂæÑ - ‰ΩøÁî®ZÂ≠óÂΩ¢ÁÆóÊ≥ï
    createStartToFinishPath(fromX, fromY, toX, toY, offset) {
      // ‰ΩøÁî®Áªü‰∏ÄÁöÑZÂ≠óÂΩ¢ÁÆóÊ≥ïÔºå‰øùÊåÅ‰ª£Á†Å‰∏ÄËá¥ÊÄß
      return this.createZShapedPath(fromX, fromY, toX, toY, 'SF', null, null)
    },

                        // FS: Finish-To-Start ËøûÁ∫øË∑ØÂæÑ - ‰ΩøÁî®ZÂ≠óÂΩ¢ÁÆóÊ≥ï
    createFinishToStartPath(fromX, fromY, toX, toY, offset) {
      // ‰ΩøÁî®Áªü‰∏ÄÁöÑZÂ≠óÂΩ¢ÁÆóÊ≥ïÔºå‰øùÊåÅ‰ª£Á†Å‰∏ÄËá¥ÊÄß
      return this.createZShapedPath(fromX, fromY, toX, toY, 'FS', null, null)
    },

                        // FF: Finish-To-Finish ËøûÁ∫øË∑ØÂæÑ - ‰ΩøÁî®ZÂ≠óÂΩ¢ÁÆóÊ≥ï
    createFinishToFinishPath(fromX, fromY, toX, toY, offset) {
      // ‰ΩøÁî®Áªü‰∏ÄÁöÑZÂ≠óÂΩ¢ÁÆóÊ≥ïÔºå‰øùÊåÅ‰ª£Á†Å‰∏ÄËá¥ÊÄß
      return this.createZShapedPath(fromX, fromY, toX, toY, 'FF', null, null)
         },

        // Á°Æ‰øùÁÆ≠Â§¥ÂèØËßÅÊÄß - ÊúÄÂ∞èË∞ÉÊï¥Ôºå‰øùÊåÅÁÆ≠Â§¥Ë¥¥ËøëËäÇÁÇπ
    ensureArrowVisibility(path, dependencyType, fromBar, toBar) {
      if (!path || !toBar) return path

      // Ê£ÄÊü•ÊúÄÂêé‰∏ÄÊÆµË∑ØÂæÑÊòØÂê¶ÂèØËÉΩË¢´‰ªªÂä°Êù°ÈÅÆÊå°
      const lastSegmentMatch = path.match(/L\s*([\d.-]+)\s+([\d.-]+)$/)
      if (!lastSegmentMatch) return path

      const lastX = parseFloat(lastSegmentMatch[1])
      const lastY = parseFloat(lastSegmentMatch[2])

      // ËÆ°ÁÆó‰ªªÂä°Êù°ÁöÑËæπÁïå
      const taskLeft = toBar.left || 0
      const taskRight = taskLeft + (toBar.width || 0)
      const taskY = (toBar.index || 0) * 28 + 14

      // ‰ªÖÂú®ÁÆ≠Â§¥ÂÆåÂÖ®Ë¢´‰ªªÂä°Êù°ÈÅÆÊå°Êó∂ÊâçË∞ÉÊï¥
      const arrowCompletelyBlocked = Math.abs(lastY - taskY) < 8 && // ÂûÇÁõ¥‰ΩçÁΩÆÈùûÂ∏∏Êé•Ëøë‰ªªÂä°Êù°‰∏≠ÂøÉ
                                     lastX > taskLeft + 5 && lastX < taskRight - 5 // Ê∞¥Âπ≥‰ΩçÁΩÆÂú®‰ªªÂä°Êù°ÂÜÖÈÉ®

      if (arrowCompletelyBlocked) {
        // ÊúÄÂ∞èË∞ÉÊï¥ÔºåÁ°Æ‰øùÁÆ≠Â§¥ÂàöÂ•ΩÈú≤Âá∫‰ªªÂä°Êù°ËæπÁºò
        const minExtension = 8 // ÊúÄÂ∞èÂª∂‰º∏Ë∑ùÁ¶ªÔºå‰øùÊåÅÁÆ≠Â§¥Ë¥¥Ëøë
        let adjustedX

        if (dependencyType === 'FS' || dependencyType === 'SS') {
          // ËøûÊé•Âà∞ÂºÄÂßãÁÇπÔºåÂæÆË∞ÉÂà∞Â∑¶ËæπÁºòÂ§ñ
          adjustedX = taskLeft - minExtension
        } else {
          // ËøûÊé•Âà∞ÁªìÊùüÁÇπÔºåÂæÆË∞ÉÂà∞Âè≥ËæπÁºòÂ§ñ
          adjustedX = taskRight + minExtension
        }

        path = path.replace(/L\s*([\d.-]+)\s+([\d.-]+)$/, `L ${adjustedX} ${lastY}`)
      }

      return path
    },

    // Ë∞ÉÊï¥milestoneÁÆ≠Â§¥Ë∑ØÂæÑÔºåÁ°Æ‰øù‰∏çË¢´diamondÂΩ¢Áä∂ÈÅÆÊå°‰ΩÜ‰øùÊåÅË¥¥Ëøë
    adjustMilestoneArrowPath(path, dependencyType, toBar) {
      if (!path || !toBar) return path

      const diamondRadius = (toBar.width || 0) / 2
      const centerX = (toBar.left || 0) + diamondRadius
      const minExtendLength = 10 // ÊúÄÂ∞èÂª∂‰º∏Ë∑ùÁ¶ªÔºå‰øùÊåÅÁÆ≠Â§¥Ë¥¥Ëøëmilestone

      const lastSegmentMatch = path.match(/L\s*([\d.-]+)\s+([\d.-]+)$/)
      if (lastSegmentMatch) {
        const lastX = parseFloat(lastSegmentMatch[1])
        const lastY = parseFloat(lastSegmentMatch[2])

        // Ê†πÊçÆËøûÊé•ÊñπÂêëÂÜ≥ÂÆöÂª∂‰º∏ÊñπÂêëÔºåÊúÄÂ∞èÂåñË∑ùÁ¶ª
        let extendX = lastX
        if (dependencyType === 'FS' || dependencyType === 'SS') {
          // ËøûÊé•Âà∞ÂºÄÂßãÁÇπÔºåÁÆ≠Â§¥Âú®Â∑¶‰æßÔºåÂàöÂ•ΩÈÅøÂºÄdiamond
          extendX = centerX - diamondRadius - minExtendLength
        } else if (dependencyType === 'FF' || dependencyType === 'SF') {
          // ËøûÊé•Âà∞ÁªìÊùüÁÇπÔºåÁÆ≠Â§¥Âú®Âè≥‰æßÔºåÂàöÂ•ΩÈÅøÂºÄdiamond
          extendX = centerX + diamondRadius + minExtendLength
        }

        path = path.replace(/L\s*([\d.-]+)\s+([\d.-]+)$/, `L ${extendX} ${lastY}`)
      }

      return path
    },

    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÁªìÊùüÁÇπËøûÊé•
    isEndPointConnection(line) {
      if (!line.dependency) return false
      const dependencyType = line.dependency.type || 'FS'
      return dependencyType === 'FF' || dependencyType === 'SF'
    },

    // Ëé∑ÂèñÁªàÁÇπÊåáÁ§∫Âô®XÂùêÊ†á
    getEndPointIndicatorX(line) {
      // ‰ΩøÁî®toBarÂºïÁî®ËÄå‰∏çÊòØdependency
      const toBar = line.toBar || this.getTaskBarById(line.to)
      if (!toBar) return 0

      const dependencyType = line.type || 'FS'
      const isMilestone = toBar.task.type === 'milestone'

      if (dependencyType === 'FF' || dependencyType === 'SF') {
        // ÁªìÊùüÁÇπÔºöÂú®ËäÇÁÇπÂè≥‰æßÂ§ñÈÉ®ÊòæÁ§∫ÊåáÁ§∫Âô®
        if (isMilestone) {
          // milestoneÔºöÊåáÁ§∫Âô®Âú®diamondÂè≥‰æßÊõ¥ËøúÁöÑ‰ΩçÁΩÆ
          const centerX = toBar.left + toBar.width / 2
          const diamondRadius = toBar.width / 2
          return centerX + diamondRadius + 25 // Á°Æ‰øù‰∏çË¢´diamondÊå°‰Ωè
        } else {
          // ÊôÆÈÄö‰ªªÂä°ÔºöÊåáÁ§∫Âô®Âú®‰ªªÂä°Êù°Âè≥‰æß
          return toBar.left + toBar.width + 12
        }
      }
      return 0
    },

    // Ëé∑ÂèñÁªàÁÇπÊåáÁ§∫Âô®YÂùêÊ†á
    getEndPointIndicatorY(line) {
      // ‰ΩøÁî®toBarÂºïÁî®ËÄå‰∏çÊòØÈáçÊñ∞Êü•Êâæ
      const toBar = line.toBar || this.getTaskBarById(line.to)
      if (!toBar) return 0
      return (toBar.index || 0) * 28 + 14
    },

    // Ëé∑ÂèñËøûÊé•Á∫øÈ¢úËâ≤ - ÊîØÊåÅÁÅ∞Ëâ≤Ê®°ÂºèÂíå‰∏çÂèØÁºñËæëÊ®°Âºè
    getConnectionLineColor(line) {
      // Â¶ÇÊûúËøûÊé•Á∫ø‰∏çÂèØÁºñËæëÔºå‰ΩøÁî®ÈªòËÆ§ÁÅ∞Ëâ≤
      if (!this.connectionEditable) {
        return this.connectionDefaultColor
      }

      if (this.grayConnectionMode) {
        return '#9e9e9e' // bryntumÈ£éÊ†ºÁöÑÁÅ∞Ëâ≤
      }
      return line.color || '#666'
    },

    // Âà§Êñ≠ÊòØÂê¶ÊòØÁªìÊùüÁÇπËøûÊé•ÔºàÈúÄË¶ÅÈ¢ùÂ§ñÁöÑÁªàÁÇπÊåáÁ§∫Âô®Ôºâ
    isEndPointConnection(line) {
      const dependencyType = line.type || 'FS'
      // Ê£ÄÊü•ÊòØÂê¶ËøûÊé•Âà∞milestoneÁ±ªÂûã‰ªªÂä°ÁöÑÁªìÊùüÁÇπ
      const toBar = line.toBar || this.getTaskBarById(line.to)
      const isMilestone = toBar && toBar.task.type === 'milestone'

      // milestoneÁ±ªÂûãÊàñFF/SFÁ±ªÂûãÈÉΩÈúÄË¶ÅÁªàÁÇπÊåáÁ§∫Âô®
      return (dependencyType === 'FF' || dependencyType === 'SF') || isMilestone
    },

    // Âà§Êñ≠ÊòØÂê¶ÊòæÁ§∫ËøûÊé•Á∫ø
    shouldShowDependencyLine(line) {
      // Â¶ÇÊûúËÆæÁΩÆ‰∫ÜÂÖ®Â±ÄÈöêËóè‰æùËµñÁ∫ø
      if (this.temporarilyHideDependencies) {
        return false
      }

      // Â¶ÇÊûúËÆæÁΩÆ‰∫ÜÈöêËóèÁâπÂÆö‰ªªÂä°ÁöÑ‰æùËµñÁ∫ø
      if (this.hidingTaskId) {
        if (line.from === this.hidingTaskId || line.to === this.hidingTaskId) {
          return false
        }
      }

      // Â¶ÇÊûúËÆæÁΩÆ‰∫ÜÈöêËóèÂ§ö‰∏™‰ªªÂä°ÁöÑ‰æùËµñÁ∫øÔºàÁà∂ËäÇÁÇπÂèäÂÖ∂Â≠êËäÇÁÇπÔºâ
      if (this.hidingTaskIds && this.hidingTaskIds.length > 0) {
        if (this.hidingTaskIds.includes(line.from) || this.hidingTaskIds.includes(line.to)) {
          return false
        }
      }

      // Ê£ÄÊü•ËøûÊé•Á∫øÁöÑ‰∏§Á´ØËäÇÁÇπÊòØÂê¶ÈÉΩÂ≠òÂú®
      const fromBar = this.taskBars.find(bar => bar.task.id === line.from)
      const toBar = this.taskBars.find(bar => bar.task.id === line.to)
      if (!fromBar || !toBar) {
        return false
      }

      return true
    },

    // ËÆ°ÁÆóÂÖ≥ÈîÆË∑ØÂæÑ - ‰ΩøÁî®CPMÁÆóÊ≥ï
    calculateCriticalPath() {
      // Â¶ÇÊûú‰∏çÊòæÁ§∫ÂÖ≥ÈîÆË∑ØÂæÑÔºåÁõ¥Êé•ËøîÂõûÁ©∫Êï∞ÁªÑ
      if (!this.showCriticalPath) {
        return []
      }

      // ÂàõÂª∫‰ªªÂä°Êò†Â∞ÑË°®Ôºå‰æø‰∫éÂø´ÈÄüÊü•Êâæ
      const taskMap = {}
      this.tasks.forEach(task => {
        taskMap[task.id] = {
          ...task,
          earliestStart: 0,
          earliestFinish: 0,
          latestStart: Infinity,
          latestFinish: Infinity,
          slack: 0,
          isCritical: false,
          successors: [],
          duration: 0
        }
      })

      // ËÆ°ÁÆó‰ªªÂä°ÊåÅÁª≠Êó∂Èó¥ÔºàÂ§©Êï∞Ôºâ
      for (const taskId in taskMap) {
        const task = taskMap[taskId]
        if (task.startDate && task.endDate) {
          const startDate = moment(task.startDate)
          const endDate = moment(task.endDate)
          task.duration = endDate.diff(startDate, 'days') + 1 // ÂåÖÂê´È¶ñÂ∞æÊó•Êúü
        }
      }

      // ÊûÑÂª∫‰ªªÂä°‰æùËµñÂÖ≥Á≥ªÂõæ
      this.dependencies.forEach(dep => {
        if (taskMap[dep.from] && taskMap[dep.to]) {
          taskMap[dep.from].successors.push(dep.to)
        }
      })

      // ÊâæÂá∫ÊâÄÊúâÊ≤°ÊúâÂâçÁΩÆ‰ªªÂä°ÁöÑËµ∑ÂßãËäÇÁÇπ
      const startNodes = []
      for (const taskId in taskMap) {
        const task = taskMap[taskId]
        const hasIncomingDeps = this.dependencies.some(dep => dep.to === taskId)
        if (!hasIncomingDeps) {
          startNodes.push(taskId)
        }
      }

      // ÂâçÂêëÈÅçÂéÜÔºöËÆ°ÁÆóÊúÄÊó©ÂºÄÂßãÂíåÊúÄÊó©ÂÆåÊàêÊó∂Èó¥
      const visited = new Set()

      // ÂÆö‰πâÈÄíÂΩíÂáΩÊï∞ËÆ°ÁÆóÊúÄÊó©Êó∂Èó¥
      const calculateEarliestTimes = (taskId) => {
        if (visited.has(taskId)) return
        visited.add(taskId)

        const task = taskMap[taskId]

        // ËÆ°ÁÆóÂâçÁΩÆ‰ªªÂä°ÁöÑÊúÄÊó©ÂÆåÊàêÊó∂Èó¥
        const predecessors = this.dependencies
          .filter(dep => dep.to === taskId)
          .map(dep => dep.from)

        // Â¶ÇÊûúÊúâÂâçÁΩÆ‰ªªÂä°ÔºåÂèñÊúÄÂ§ßÁöÑÊúÄÊó©ÂÆåÊàêÊó∂Èó¥‰Ωú‰∏∫ÂΩìÂâç‰ªªÂä°ÁöÑÊúÄÊó©ÂºÄÂßãÊó∂Èó¥
        if (predecessors.length > 0) {
          let maxEarliestFinish = 0
          predecessors.forEach(predId => {
            if (!visited.has(predId)) {
              calculateEarliestTimes(predId)
            }
            maxEarliestFinish = Math.max(maxEarliestFinish, taskMap[predId].earliestFinish)
          })
          task.earliestStart = maxEarliestFinish
        }

        // ËÆ°ÁÆóÊúÄÊó©ÂÆåÊàêÊó∂Èó¥
        task.earliestFinish = task.earliestStart + task.duration

        // ÈÄíÂΩíËÆ°ÁÆóÂêéÁª≠‰ªªÂä°
        task.successors.forEach(succId => {
          calculateEarliestTimes(succId)
        })
      }

      // ‰ªéÊâÄÊúâËµ∑ÂßãËäÇÁÇπÂºÄÂßãËÆ°ÁÆó
      startNodes.forEach(taskId => {
        calculateEarliestTimes(taskId)
      })

      // ÊâæÂá∫È°πÁõÆÁöÑÁªìÊùüÊó∂Èó¥ÔºàÊâÄÊúâ‰ªªÂä°‰∏≠ÊúÄÂ§ßÁöÑÊúÄÊó©ÂÆåÊàêÊó∂Èó¥Ôºâ
      let projectFinish = 0
      for (const taskId in taskMap) {
        projectFinish = Math.max(projectFinish, taskMap[taskId].earliestFinish)
      }

      // ÊâæÂá∫ÊâÄÊúâÊ≤°ÊúâÂêéÁª≠‰ªªÂä°ÁöÑÁªìÊùüËäÇÁÇπ
      const endNodes = []
      for (const taskId in taskMap) {
        const task = taskMap[taskId]
        if (task.successors.length === 0) {
          endNodes.push(taskId)
          // ËÆæÁΩÆÁªìÊùüËäÇÁÇπÁöÑÊúÄÊôöÂÆåÊàêÊó∂Èó¥‰∏∫È°πÁõÆÁªìÊùüÊó∂Èó¥
          task.latestFinish = projectFinish
        }
      }

      // ÂèçÂêëÈÅçÂéÜÔºöËÆ°ÁÆóÊúÄÊôöÂºÄÂßãÂíåÊúÄÊôöÂÆåÊàêÊó∂Èó¥
      visited.clear()

      // ÂÆö‰πâÈÄíÂΩíÂáΩÊï∞ËÆ°ÁÆóÊúÄÊôöÊó∂Èó¥
      const calculateLatestTimes = (taskId) => {
        if (visited.has(taskId)) return
        visited.add(taskId)

        const task = taskMap[taskId]

        // Â¶ÇÊûúÊòØÁªìÊùüËäÇÁÇπÔºåÂ∑≤ÁªèËÆæÁΩÆ‰∫ÜÊúÄÊôöÂÆåÊàêÊó∂Èó¥
        if (task.successors.length === 0) {
          task.latestStart = task.latestFinish - task.duration
        } else {
          // ËÆ°ÁÆóÊâÄÊúâÂêéÁª≠‰ªªÂä°ÁöÑÊúÄÊôöÂºÄÂßãÊó∂Èó¥
          let minLatestStart = Infinity
          task.successors.forEach(succId => {
            if (!visited.has(succId)) {
              calculateLatestTimes(succId)
            }
            minLatestStart = Math.min(minLatestStart, taskMap[succId].latestStart)
          })

          // ÂΩìÂâç‰ªªÂä°ÁöÑÊúÄÊôöÂÆåÊàêÊó∂Èó¥ÊòØÂêéÁª≠‰ªªÂä°ÁöÑÊúÄÊó©ÂºÄÂßãÊó∂Èó¥
          task.latestFinish = minLatestStart
          task.latestStart = task.latestFinish - task.duration
        }

        // ÈÄíÂΩíËÆ°ÁÆóÂâçÁΩÆ‰ªªÂä°
        this.dependencies
          .filter(dep => dep.to === taskId)
          .forEach(dep => {
            calculateLatestTimes(dep.from)
          })
      }

      // ‰ªéÊâÄÊúâÁªìÊùüËäÇÁÇπÂºÄÂßãÂèçÂêëËÆ°ÁÆó
      endNodes.forEach(taskId => {
        calculateLatestTimes(taskId)
      })

      // ËÆ°ÁÆóÊØè‰∏™‰ªªÂä°ÁöÑÊùæÂºõÊó∂Èó¥Âπ∂Á°ÆÂÆöÂÖ≥ÈîÆË∑ØÂæÑ
      const criticalPathTaskIds = []
      for (const taskId in taskMap) {
        const task = taskMap[taskId]
        task.slack = task.latestStart - task.earliestStart

        // ÊùæÂºõÊó∂Èó¥‰∏∫0ÁöÑ‰ªªÂä°Âú®ÂÖ≥ÈîÆË∑ØÂæÑ‰∏ä
        if (task.slack === 0) {
          task.isCritical = true
          criticalPathTaskIds.push(taskId)
        }
      }

      return criticalPathTaskIds
    },

    // Ëé∑ÂèñÂèØËßÅ‰ªªÂä°IDÔºàËôöÊãüÊªöÂä®ÊàñÂèØËßÅÂå∫ËøáÊª§Ôºâ- ÊÄßËÉΩ‰ºòÂåñÁâàÊú¨
    getVisibleTaskIds() {
      // ÁºìÂ≠òÂèØËßÜÂå∫Âüü‰ªªÂä°IDÔºåÈÅøÂÖçÈáçÂ§çËÆ°ÁÆó
      const cacheKey = this.generateVisibleAreaCacheKey()
      if (this._visibleAreaCache && this._visibleAreaCache.key === cacheKey) {
        return this._visibleAreaCache.taskIds
      }

      // Ëé∑ÂèñÊªöÂä®ÂÆπÂô®‰ø°ÊÅØ
      const container = this._ganttScrollContainer
      if (!container) {
        // ÂÖúÂ∫ïÔºöËøîÂõûÊâÄÊúâ‰ªªÂä°ID
        const allTaskIds = this.taskBars.map(bar => bar.task.id)
        this._visibleAreaCache = { key: cacheKey, taskIds: allTaskIds }
        return allTaskIds
      }

      // ËÆ°ÁÆóÂèØËßÜÂå∫ÂüüËåÉÂõ¥
      const scrollLeft = container.scrollLeft
      const containerWidth = container.clientWidth
      const visibleLeft = scrollLeft - 100 // Â∑¶‰æßÁºìÂÜ≤Âå∫
      const visibleRight = scrollLeft + containerWidth + 100 // Âè≥‰æßÁºìÂÜ≤Âå∫

      // ËøáÊª§ÂèØËßÜÂå∫ÂüüÂÜÖÁöÑ‰ªªÂä°
      const visibleTaskIds = this.taskBars
        .filter(bar => {
          const barRight = bar.left + bar.width
          return barRight >= visibleLeft && bar.left <= visibleRight
        })
        .map(bar => bar.task.id)

      // ÁºìÂ≠òÁªìÊûú
      this._visibleAreaCache = { key: cacheKey, taskIds: visibleTaskIds }
      return visibleTaskIds
    },

    // ÁîüÊàêÂèØËßÜÂå∫ÂüüÁºìÂ≠òÈîÆ
    generateVisibleAreaCacheKey() {
      if (!this._ganttScrollContainer) return 'no-container'

      const container = this._ganttScrollContainer
      return `${container.scrollLeft}_${container.clientWidth}_${this.taskBars.length}`
    },

    // ÂÖ®Â±ÄÂèåÂáª‰∫ã‰ª∂Â§ÑÁêÜ
    handleGlobalDblClick(event) {
      console.log('[Ë∞ÉËØï] ÂÖ®Â±ÄÂèåÂáª‰∫ã‰ª∂Ëß¶Âèë', event);

      // Èò≤Ê≠¢ÈáçÂ§çËß¶Âèë
      if (this.dragPreventedByDblClick) {
        return;
      }

      // ËÆæÁΩÆÂèåÂáªÈò≤ÊãñÊãΩÊ†áÂøó
      this.dragPreventedByDblClick = true;
      setTimeout(() => { this.dragPreventedByDblClick = false; }, 300);

      // 1. Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫Ü‰ªªÂä°Êù°ÊàñÂÖ∂Â≠êÂÖÉÁ¥†ÔºàÊîπËøõÈÄâÊã©Âô®Ôºâ
      const barContainer = event.target.closest('.gantt-bar-container');
      if (barContainer) {
        // Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫Ü‰ªªÂä°Êù°Êú¨Ë∫´ÊàñÂÖ∂Â≠êÂÖÉÁ¥†Ôºà‰ΩÜÊéíÈô§ÁâπÂÆöÁöÑ‰∫§‰∫íÂÖÉÁ¥†Ôºâ
        const isTaskBar = event.target.closest('.gantt-bar') ||
                         event.target.closest('.gantt-milestone-marker') ||
                         event.target.classList.contains('gantt-bar') ||
                         event.target.classList.contains('gantt-bar-text') ||
                         event.target.classList.contains('task-name') ||
                         event.target.classList.contains('gantt-bar-progress-text') ||
                         event.target.classList.contains('task-type-icon');

        // ÊéíÈô§ËøûÊé•ÁÇπ„ÄÅË∞ÉÊï¥ÊâãÊüÑÂíåÂà†Èô§ÊåâÈíÆÂå∫Âüü
        const isExcludedElement = event.target.closest('.gantt-connection-point') ||
                                event.target.closest('.resize-handle') ||
                                event.target.closest('.task-delete-btn') ||
                                event.target.closest('.gantt-progress-handle-container') ||
                                event.target.classList.contains('parent-indicator');

        if (isTaskBar && !isExcludedElement) {
          // ÊâæÂà∞ÂØπÂ∫îÁöÑ‰ªªÂä°
          const taskId = barContainer.dataset.taskId;
          if (taskId) {
            const task = this.tasks.find(t => t.id === taskId);
            if (task) {
              console.log('[Ë∞ÉËØï] ÂèåÂáª‰ªªÂä°Êù°Âå∫ÂüüÔºåÁºñËæë‰ªªÂä°', task);
              this.editTask(task);
              return;
            }
          }
        }
      }

      // 2. Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫Ü‰æùËµñÁ∫ø
      const linkElement = event.target.closest('.gantt-link-hit-area, .gantt-dependency-line-visual');
      if (linkElement) {
        // ÊâæÂà∞ÂØπÂ∫îÁöÑ‰æùËµñÁ∫ø
        const fromId = linkElement.closest('.gantt-dependency-group')?.dataset.from;
        const toId = linkElement.closest('.gantt-dependency-group')?.dataset.to;
        if (fromId && toId) {
          const line = this.dependencyLines.find(l => l.from === fromId && l.to === toId);
          if (line && this.connectionEditable) {
            console.log('[Ë∞ÉËØï] ÂèåÂáª‰æùËµñÁ∫øÔºåÁºñËæëËøûÁ∫ø', line);
            this.openLinkEditModal(line, event);
            return;
          }
        }
      }

      // 3. Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫ÜÈáåÁ®ãÁ¢ëÔºà‰øùÊåÅÂéüÊúâÈÄªËæëÔºâ
      const milestoneElement = event.target.closest('.milestone');
      if (milestoneElement) {
        // ÊâæÂà∞ÂØπÂ∫îÁöÑ‰ªªÂä°
        const taskId = milestoneElement.closest('.gantt-bar-container')?.dataset.taskId;
        if (taskId) {
          const task = this.tasks.find(t => t.id === taskId);
          if (task) {
            console.log('[Ë∞ÉËØï] ÂèåÂáªÈáåÁ®ãÁ¢ëÔºåÁºñËæë‰ªªÂä°', task);
            this.editTask(task);
            return;
          }
        }
      }
    },

        // ÊòæÁ§∫‰ªªÂä°Âè≥ÈîÆËèúÂçï
    showTaskContextMenu(task, event) {
      console.log('[Ë∞ÉËØï] ÊòæÁ§∫‰ªªÂä°Âè≥ÈîÆËèúÂçï', task);

      // ÂèÇËÄÉtooltipÈÄªËæëËÆ°ÁÆóËèúÂçï‰ΩçÁΩÆ
      const menuWidth = 200; // ‰º∞ËÆ°ËèúÂçïÂÆΩÂ∫¶
      const menuHeight = 200; // ‰º∞ËÆ°ËèúÂçïÈ´òÂ∫¶
      const padding = 10;
      const offset = 5; // Ë∑ùÁ¶ªÈº†Ê†áÁöÑÂÅèÁßª

      // Ëé∑ÂèñGanttÂå∫ÂüüÂÆπÂô®
      const container = this._ganttScrollContainer;
      let x, y;

      if (!container) {
        // ÂÖúÂ∫ïÔºöÊó†ÂÆπÂô®Êó∂‰ΩøÁî®Áõ∏ÂØπ‰∫éviewportÁöÑÂÆö‰Ωç
        x = event.clientX + offset;
        y = event.clientY + offset;

        // Êô∫ËÉΩËæπÁïåÊ£ÄÊü•
        if (x + menuWidth > window.innerWidth - padding) {
          x = event.clientX - menuWidth - offset;
        }
        if (x < padding) x = padding;
        if (y + menuHeight > window.innerHeight - padding) {
          y = event.clientY - menuHeight - offset;
        }
        if (y < padding) y = event.clientY + offset + 20;

        // ÊúÄÁªàËæπÁïåÈôêÂà∂
        x = Math.max(padding, Math.min(x, window.innerWidth - menuWidth - padding));
        y = Math.max(padding, Math.min(y, window.innerHeight - menuHeight - padding));
      } else {
        // Ëé∑ÂèñÂÆπÂô®ÁöÑËæπÁïå‰ø°ÊÅØ
        const containerRect = container.getBoundingClientRect();

        // ËÆ°ÁÆóÁõ∏ÂØπ‰∫éÂÆπÂô®ÁöÑÂàùÂßã‰ΩçÁΩÆ
        const relativeX = event.clientX - containerRect.left;
        const relativeY = event.clientY - containerRect.top;

        // ËÆ°ÁÆóÂú®ÂÆπÂô®ÂÜÖÁöÑÁªùÂØπ‰ΩçÁΩÆÔºàËÄÉËôëÊªöÂä®Ôºâ
        x = relativeX + container.scrollLeft + offset;
        y = relativeY + container.scrollTop + offset;

        // ÂÆπÂô®ËæπÁïåËÆ°ÁÆó
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const maxX = container.scrollLeft + containerWidth - menuWidth - padding;
        const minX = container.scrollLeft + padding;
        const maxY = container.scrollTop + containerHeight - menuHeight - padding;
        const minY = container.scrollTop + padding;

        // Êô∫ËÉΩ‰ΩçÁΩÆË∞ÉÊï¥
        if (x > maxX) {
          // ËèúÂçïË∂ÖÂá∫Âè≥ËæπÁïåÔºåË∞ÉÊï¥Âà∞Èº†Ê†áÂ∑¶‰æß
          x = relativeX + container.scrollLeft - menuWidth - offset;
        }
        if (x < minX) {
          // ËèúÂçïË∂ÖÂá∫Â∑¶ËæπÁïåÔºåË¥¥ËøëÂ∑¶ËæπÁïå
          x = minX;
        }
        if (y > maxY) {
          // ËèúÂçïË∂ÖÂá∫‰∏ãËæπÁïåÔºåË∞ÉÊï¥Âà∞Èº†Ê†á‰∏äÊñπ
          y = relativeY + container.scrollTop - menuHeight - offset;
        }
        if (y < minY) {
          // ËèúÂçïË∂ÖÂá∫‰∏äËæπÁïåÔºåÂú®Èº†Ê†á‰∏ãÊñπÁïôÂá∫Êõ¥Â§öÁ©∫Èó¥
          y = relativeY + container.scrollTop + offset + 20;
        }

        // ÊúÄÁªàËæπÁïå‰øùÊä§
        x = Math.max(minX, Math.min(x, maxX));
        y = Math.max(minY, Math.min(y, maxY));
      }

      this.contextMenu = {
        visible: true,
        x: Math.round(x),
        y: Math.round(y),
        type: 'task',
        task: task,
        dependency: null
      }

      console.log('[Ë∞ÉËØï] Âè≥ÈîÆËèúÂçï‰ΩçÁΩÆËÆ°ÁÆóÂÆåÊàê', { x: this.contextMenu.x, y: this.contextMenu.y, containerInfo: container ? 'container found' : 'no container' });

      // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂‰º†Êí≠ÔºåÁ°Æ‰øù‰∏ç‰ºöËß¶ÂèëÊãñÂä®
      event.preventDefault();
      event.stopPropagation();
    },

    // ÊòæÁ§∫‰æùËµñÁ∫øÂè≥ÈîÆËèúÂçï
    showDependencyContextMenu(line, event) {
      console.log('[Ë∞ÉËØï] ÊòæÁ§∫‰æùËµñÁ∫øÂè≥ÈîÆËèúÂçï', line);

      // ËÆ°ÁÆóËèúÂçï‰ΩçÁΩÆÔºåËÄÉËôëÊªöÂä®ÂÅèÁßªÂíåËßÜÂè£ËæπÁïå
      const x = event.pageX;
      const y = event.pageY;

      // Ë∞ÉÊï¥ËèúÂçï‰ΩçÁΩÆÔºåÁ°Æ‰øù‰∏çË∂ÖÂá∫ËßÜÂè£ËæπÁïå
      const menuWidth = 200; // ‰º∞ËÆ°ËèúÂçïÂÆΩÂ∫¶
      const menuHeight = 150; // ‰º∞ËÆ°ËèúÂçïÈ´òÂ∫¶
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Â¶ÇÊûúËèúÂçï‰ºöË∂ÖÂá∫Âè≥ËæπÁïåÔºåÂêëÂ∑¶ÂÅèÁßª
      const adjustedX = x + menuWidth > viewportWidth ? x - menuWidth : x;
      // Â¶ÇÊûúËèúÂçï‰ºöË∂ÖÂá∫‰∏ãËæπÁïåÔºåÂêë‰∏äÂÅèÁßª
      const adjustedY = y + menuHeight > viewportHeight ? y - menuHeight : y;

      this.contextMenu = {
        visible: true,
        x: adjustedX,
        y: adjustedY,
        type: 'dependency',
        task: null,
        dependency: line
      }

      // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂‰º†Êí≠ÔºåÁ°Æ‰øù‰∏ç‰ºöËß¶ÂèëÊãñÂä®
      event.preventDefault();
      event.stopPropagation();
    },

    // ÈöêËóèÂè≥ÈîÆËèúÂçï
    hideContextMenu(event) {
      // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØËèúÂçïÊú¨Ë∫´Ôºå‰∏çÈöêËóè
      if (event && event.target && event.target.closest('.gantt-context-menu')) {
        return;
      }
      this.contextMenu.visible = false;
    },

    // ‰ªéÂè≥ÈîÆËèúÂçïÁºñËæë‰ªªÂä°
    editTaskFromMenu() {
      console.log('[Ë∞ÉËØï] ‰ªéÂè≥ÈîÆËèúÂçïÁºñËæë‰ªªÂä°', this.contextMenu.task);
      if (this.contextMenu.task) {
        // Á°Æ‰øùË∞ÉÁî®Ê≠£Á°ÆÁöÑÁºñËæëÂáΩÊï∞
        this.$nextTick(() => {
          this.editTask(this.contextMenu.task);
        });
      }
      this.hideContextMenu();
    },

    // ‰ªéÂè≥ÈîÆËèúÂçïÂà†Èô§‰ªªÂä°
    deleteTaskFromMenu() {
      if (this.contextMenu.task) {
        this.deleteTaskDirectly(this.contextMenu.task);
      }
      this.hideContextMenu();
    },

    // ‰ªéÂè≥ÈîÆËèúÂçïÊ∑ªÂä†Â≠ê‰ªªÂä°
    addChildTaskFromMenu() {
      if (this.contextMenu.task) {
        this.$emit('add-child-task', this.contextMenu.task);
      }
      this.hideContextMenu();
    },

    // ‰ªéÂè≥ÈîÆËèúÂçïÊ∑ªÂä†ÂêåÁ∫ß‰ªªÂä°
    addSiblingTaskFromMenu() {
      if (this.contextMenu.task) {
        this.$emit('add-sibling-task', this.contextMenu.task);
      }
      this.hideContextMenu();
    },

    // ‰ªéÂè≥ÈîÆËèúÂçïÁºñËæë‰æùËµñÁ∫ø
    editDependencyFromMenu() {
      console.log('[Ë∞ÉËØï] ‰ªéÂè≥ÈîÆËèúÂçïÁºñËæëËøûÁ∫ø', this.contextMenu.dependency);
      if (this.contextMenu.dependency) {
        // Á°Æ‰øùË∞ÉÁî®Ê≠£Á°ÆÁöÑÁºñËæëÂáΩÊï∞
        this.$nextTick(() => {
          this.openLinkEditModal(this.contextMenu.dependency);
          console.log('[Ë∞ÉËØï] ÁºñËæëËøûÁ∫øÂºπÊ°ÜÁä∂ÊÄÅ:', this.linkEditModal.visible);
        });
      }
      this.hideContextMenu();
    },

    // ‰ªéÂè≥ÈîÆËèúÂçïÂà†Èô§‰æùËµñÁ∫ø
    deleteDependencyFromMenu() {
      if (this.contextMenu.dependency) {
        this.removeDependency({
          from: this.contextMenu.dependency.from,
          to: this.contextMenu.dependency.to
        });
      }
      this.hideContextMenu();
    },

    // Ëé∑Âèñ‰ªªÂä°Á±ªÂûãÈÖçÁΩÆ
    getTaskTypeConfig(type) {
      return getTaskTypeConfig(type);
    },

    /**
     * Ëé∑Âèñ‰æùËµñÁ±ªÂûãÁöÑÊèèËø∞
     * @param {string} type ‰æùËµñÁ±ªÂûã
     * @returns {string} ÊèèËø∞ÊñáÊú¨
     */
    getDependencyDescription(type) {
      const typeConfig = {
        'FS': 'AÂÆåÊàêÂêéBÂºÄÂßã',
        'SS': 'AÂºÄÂßãÂêéBÂºÄÂßã',
        'FF': 'AÂÆåÊàêÂêéBÂÆåÊàê',
        'SF': 'AÂºÄÂßãÂêéBÂÆåÊàê'
      }
      return typeConfig[type] || typeConfig['FS']
    },

    /**
     * Ëé∑ÂèñlagÊïàÊûúÊèèËø∞
     * @param {string} type ‰æùËµñÁ±ªÂûã
     * @param {number} lag lagÂÄºÔºàÂ§©Êï∞Ôºâ
     * @returns {string} ÊïàÊûúÊèèËø∞
     */
    getLagEffectDescription(type, lag) {
      if (lag === 0) return ''

      const absLag = Math.abs(lag)
      const direction = lag > 0 ? 'Âª∂Ëøü' : 'ÊèêÂâç'

      const effectMap = {
        'FS': lag > 0 ? `BÂ∞ÜÂú®AÂÆåÊàê${absLag}Â§©ÂêéÂºÄÂßã` : `BÂ∞ÜÂú®AÂÆåÊàêÂâç${absLag}Â§©ÂºÄÂßã`,
        'SS': lag > 0 ? `BÂ∞ÜÂú®AÂºÄÂßã${absLag}Â§©ÂêéÂºÄÂßã` : `BÂ∞ÜÂú®AÂºÄÂßãÂâç${absLag}Â§©ÂºÄÂßã`,
        'FF': lag > 0 ? `BÂ∞ÜÂú®AÂÆåÊàê${absLag}Â§©ÂêéÂÆåÊàê` : `BÂ∞ÜÂú®AÂÆåÊàêÂâç${absLag}Â§©ÂÆåÊàê`,
        'SF': lag > 0 ? `BÂ∞ÜÂú®AÂºÄÂßã${absLag}Â§©ÂêéÂÆåÊàê` : `BÂ∞ÜÂú®AÂºÄÂßãÂâç${absLag}Â§©ÂÆåÊàê`
      }

      return ` ‚Üí ${effectMap[type] || ''}`
    },

    /**
     * ÁîüÊàêËøûÁ∫øÊ†áÁ≠æÊñáÊú¨ÔºàÂåÖÂê´lag‰ø°ÊÅØÔºâ
     * @param {object} dependency ‰æùËµñÂÖ≥Á≥ªÂØπË±°
     * @returns {string} Ê†áÁ≠æÊñáÊú¨
     */
    generateConnectionLabel(dependency) {
      if (!dependency) return ''

      let label = ''

      // Ê∑ªÂä†‰æùËµñÁ±ªÂûã
      if (dependency.type && dependency.type !== 'FS') {
        label += dependency.type
      }

      // Ê∑ªÂä†lag‰ø°ÊÅØ
      if (dependency.lag && dependency.lag !== 0) {
        const lagText = dependency.lag > 0 ? `+${dependency.lag}d` : `${dependency.lag}d`
        label += (label ? ' ' : '') + lagText
      }

      // Ê∑ªÂä†Ëá™ÂÆö‰πâÊ†áÁ≠æ
      if (dependency.label) {
        label += (label ? ' ' : '') + dependency.label
      }

      return label
    },

    applyUpdates(updates) {
      updates.forEach(update => {
        const task = this.tasks.find(t => t.id === update.taskId);
        if (task) {
          task.startDate = update.newStart;
          task.endDate = update.newEnd;
          // Ëß¶Âèë‰ªªÂä°Êõ¥Êñ∞‰∫ã‰ª∂ÊàñÂÖ∂‰ªñÂøÖË¶ÅÁöÑÊìç‰Ωú
          this.$emit('task-updated', task);
        }
      });
    }
  }
}
</script>

<style scoped>
.gantt-bars {
  position: relative;
  height: 100%;
  /* ‰ΩøÁî®‰º†ÂÖ•ÁöÑchart-heightÂä®ÊÄÅËÆæÁΩÆÊúÄÂ∞èÈ´òÂ∫¶ */
  min-height: 200px;
  /* Á°Æ‰øùÂÆπÂô®È´òÂ∫¶Á≤æÁ°ÆÂåπÈÖçÂÜÖÂÆπÔºåÈÅøÂÖçÈ¢ùÂ§ñÁ©∫ÁôΩ */
  max-height: 100%;
  /* ‰øÆÊîπoverflowËÆæÁΩÆÔºåÂÖÅËÆ∏Ê∞¥Âπ≥Ê∫¢Âá∫‰ΩÜÂûÇÁõ¥ÊñπÂêëÂèØÊªöÂä® */
  overflow-x: visible;
  /* overflow-y: clip; */
  /* Á°Æ‰øùÂÜÖÂÆπ‰∏ç‰ºö‰∫ßÁîüÈ¢ùÂ§ñÁöÑÁ©∫ÁôΩÂå∫Âüü */
  box-sizing: border-box;
  /* ‰∏çÂåÖÂê´Â∏ÉÂ±ÄÔºåÂÖÅËÆ∏Â≠êÂÖÉÁ¥†Ê∫¢Âá∫ */
  contain: none;
}

/* È´ò‰∫ÆË°åËÉåÊôØÊ†∑Âºè */
.highlighted-row-background {
  position: absolute;
  left: 0;
  background:linear-gradient(90deg, rgba(74, 144, 226, 0.12) 0%, rgba(74, 144, 226, 0.08) 100%);


  z-index: 1;

}

.dependency-lines {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: auto;
  z-index: 2;
}

.dependency-group {
  cursor: pointer;
}

.dependency-hit-area {
  cursor: pointer;
  stroke-width: 20;
  opacity: 0;
}

.dependency-hit-area:hover {
  opacity: 0.1;
  stroke: #3498db;
}

.dependency-line {
  transition: stroke 0.2s ease, stroke-width 0.2s ease;
  cursor: pointer;
}

.dependency-line:hover {
  stroke-width: 3 !important;
  filter: brightness(1.2);
}

.dependency-line.selected {
  stroke: #ff4757 !important;
  stroke-width: 4 !important;
}

.label-group {
  cursor: pointer;
}

.label-background {
  cursor: pointer;
  transition: all 0.2s ease;
}

.label-background:hover {
  fill: #f0f8ff;
  stroke: #3498db;
}

.dependency-label {
  font-size: 12px;
  fill: #333;
  text-anchor: middle;
  cursor: pointer;
  user-select: none;
  font-weight: 500;
  transition: fill 0.2s ease;
}

.dependency-label:hover {
  fill: #3498db;
  font-weight: 600;
}

.dependency-label.selected {
  fill: #ff4757;
  font-weight: 600;
}

.control-buttons {
  cursor: pointer;
}

.color-button-group,
.delete-button-group {
  cursor: pointer;
  transition: opacity 0.2s ease;
}

.color-button-group:hover,
.delete-button-group:hover {
  opacity: 0.8;
}

.color-button,
.delete-button {
  cursor: pointer;
  transition: fill 0.2s ease;
}

.color-inner-circle {
  transition: opacity 0.2s ease;
}

.color-button-group:hover .color-inner-circle {
  opacity: 0.6;
}

.delete-button-group:hover .delete-button {
  fill: #c0392b !important;
}

.connection-preview {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 3;
}

.gantt-bar-container {
  position: absolute;
  height: 28px;
  z-index: 10;
  display: flex;
  align-items: center;
}

.plan-date-range {
  position: absolute;
  height: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: linear-gradient(45deg,
    rgba(24, 144, 255, 0.2) 25%,
    transparent 25%,
    transparent 50%,
    rgba(24, 144, 255, 0.2) 50%,
    rgba(24, 144, 255, 0.2) 75%,
    transparent 75%
  );
  background-size: 8px 8px;
  border: 1px dashed rgba(24, 144, 255, 0.5);
  border-radius: 4px;
  z-index: 5; /* Á°Æ‰øùÂú®ÂÆûÈôÖ‰ªªÂä°Êù°‰∏ãÈù¢ */
  pointer-events: none;
}

.gantt-bar {
  height: 16px;
  width: 100%;
  border-radius: 2px;
  position: relative;
  cursor: move;
  transition: all 0.15s ease;
  border: 1px solid rgba(255, 255, 255, 0.3);
  z-index: 10; /* Á°Æ‰øùÂú®plan-date-range‰∏äÈù¢ */
  font-size: 11px; /* ÂéãÁº©ÊñáÂ≠óÂ§ßÂ∞è */
  line-height: 1.2; /* Á¥ßÂáëË°åÈ´ò */
  will-change: transform; /* ÂêØÁî®Á°¨‰ª∂Âä†ÈÄü */
  transform: translateZ(0); /* Âº∫Âà∂Á°¨‰ª∂Âä†ÈÄü */
}

.gantt-bar:hover {
  border-color: rgba(255, 255, 255, 0.5);
}

.gantt-bar.dragging {
  z-index: 100;
  opacity: 0.9;
  will-change: transform;
  transition: none; /* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏° */
  transform: translateZ(0); /* ‰øùÊåÅÁ°¨‰ª∂Âä†ÈÄü */
  backface-visibility: hidden; /* ÈÅøÂÖçÊãñÊãΩÈó™ÁÉÅ */
  pointer-events: none; /* ÊãñÊãΩÊó∂Á¶ÅÁî®ÊåáÈíà‰∫ã‰ª∂ÔºåÈÅøÂÖçÂÜ≤Á™Å */
}

.gantt-bar.connecting {
  border-color: #4a90e2;
  background-color: rgba(74, 144, 226, 0.1);
}

.gantt-bar.selected {
  border-color: #4a90e2;
  background-color: rgba(74, 144, 226, 0.1);
}

/* Áà∂Á∫ßËäÇÁÇπÊ†∑Âºè - ÂèÇËÄÉBryntumÁîòÁâπÂõæ */
.gantt-bar.parent-task {
  position: relative;
  border-radius: 0;
  font-size: 11px; /* ÂéãÁº©ÊñáÂ≠óÂ§ßÂ∞è */
  box-shadow: none;
  margin-top: 0;
  z-index: 20;
  border: none;
  display: flex;
  align-items: center;
  overflow: visible !important; /* ÂÖÅËÆ∏‰∏âËßíÂΩ¢Ë∂ÖÂá∫ */
  height: 14px; /* ÂéãÁº©Áà∂ËäÇÁÇπÈ´òÂ∫¶ */
  transform-style: preserve-3d; /* Á°Æ‰øùÂ≠êÂÖÉÁ¥†Ë∑üÈöèÁà∂ÂÖÉÁ¥†‰∏ÄËµ∑ÂèòÊç¢ */
  will-change: transform; /* ‰ºòÂåñÂèòÊç¢ÊÄßËÉΩ */
}




/* Áà∂ËäÇÁÇπÊãñÊãΩÊó∂ÁöÑÊ†∑Âºè */
.gantt-bar.parent-dragging {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
  z-index: 20 !important;
  will-change: transform; /* ÊèêÁ§∫ÊµèËßàÂô®ËØ•ÂÖÉÁ¥†Â∞ÜËøõË°åÂèòÊç¢Ôºå‰ºòÂåñÊ∏≤Êüì */
  transition: none; /* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏° */
  backface-visibility: hidden; /* ÈÅøÂÖçÊãñÊãΩÈó™ÁÉÅ */
}

/* Áà∂ËäÇÁÇπÊãñÊãΩÊó∂ÁöÑ‰∏âËßíÂΩ¢Ê†∑Âºè */
.gantt-bar.parent-dragging::before,
.gantt-bar.parent-dragging::after {
  will-change: transform; /* ÊèêÁ§∫ÊµèËßàÂô®ËØ•ÂÖÉÁ¥†Â∞ÜËøõË°åÂèòÊç¢Ôºå‰ºòÂåñÊ∏≤Êüì */
}

/* Áà∂ËäÇÁÇπËøõÂ∫¶Êù°Ê†∑Âºè */
.gantt-bar.parent-task .gantt-bar-progress {
  background: rgba(255, 255, 255, 0.3) !important;
  height: 14px; /* ÈÄÇÈÖçÊñ∞ÁöÑÁà∂ËäÇÁÇπÈ´òÂ∫¶ */
  top: 0;
  border-radius: 0;
  transition: width 0.3s ease;
}

/* Áà∂ËäÇÁÇπÊåáÁ§∫Âô® */
.gantt-bar.parent-task .parent-indicator {
  position: absolute;
  left: 3px;
  top: 50%;
  transform: translateY(-50%);
  width: 10px; /* ÂéãÁº©ÊåáÁ§∫Âô®Â∞∫ÂØ∏ */
  height: 10px; /* ÂéãÁº©ÊåáÁ§∫Âô®Â∞∫ÂØ∏ */
  background: rgba(255, 255, 255, 0.9);
  border-radius: 1px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 21;
  font-size: 8px; /* ÂéãÁº©Â≠ó‰Ωì */
  font-weight: bold;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
  transition: all 0.2s ease;
}

.gantt-bar.parent-task .parent-indicator:hover {
  transform: translateY(-50%) scale(1.15);
  background: rgba(255, 255, 255, 1);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* ÈªòËÆ§ÊòæÁ§∫ÂáèÂè∑ÔºàÂ±ïÂºÄÁä∂ÊÄÅÔºâ */
.gantt-bar.parent-task .parent-indicator::before {
  content: '‚àí';
  color: #6b7280; /* ‰øÆÊîπ‰∏∫Ê∑±ÁÅ∞Ëâ≤ */
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px; /* ÂéãÁº©Â≠ó‰Ωì */
  line-height: 0.8;
  font-weight: bold;
  transition: all 0.2s ease;
}

/* ÊäòÂè†Áä∂ÊÄÅÊòæÁ§∫Âä†Âè∑ */
.gantt-bar.parent-task .parent-indicator[data-collapsed="true"]::before {
  content: '+';
  font-size: 9px; /* ÂéãÁº©Â≠ó‰Ωì */
  line-height: 1;
  transition: all 0.2s ease;
}



/* Áà∂ËäÇÁÇπÊñáÊú¨Ê†∑Âºè */
.gantt-bar.parent-task .gantt-bar-text {
  padding-left: 22px; /* ‰∏∫Â±ïÂºÄ/ÊäòÂè†ÂõæÊ†áÁïôÂá∫Á©∫Èó¥ */
  font-weight: 600;
  font-size: 12px;
  color: #ffffff;
  text-shadow: none;
  letter-spacing: 0.3px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Áà∂ËäÇÁÇπÈÄâ‰∏≠Ê†∑Âºè */
.gantt-bar.parent-task.selected {
  background: #6b7280 !important; /* Ê∑±ÁÅ∞Ëâ≤Ë°®Á§∫ÈÄâ‰∏≠ */
  box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.4) !important;
}

.gantt-bar.parent-task.selected::before {
  border-right-color: #6b7280;
}

.gantt-bar.parent-task.selected::after {
  border-left-color: #6b7280;
}

.gantt-bar-progress {
  height: 100%;
  border-radius: 2px;
  transition: width 0.2s ease;
  background: rgba(0,0,0,0.3) !important;
  position: absolute;
  top: 0;
  left: 0;
}

/* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏°ÊïàÊûúÔºåÁ°Æ‰øùÊµÅÁïÖ */
.gantt-bar.progress-dragging .gantt-bar-progress {
  transition: none;
}

/* ËøõÂ∫¶ÊãñÊãΩÊó∂ÁöÑÁâπÊÆäÊ†∑Âºè */
.gantt-bar.progress-dragging .gantt-progress-handle {
  border-bottom-color: #2c5f8a;
  border-left-width: 10px;
  border-right-width: 10px;
  border-bottom-width: 14px;
  filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.4));
}

/* ËøõÂ∫¶ÊãñÊãΩÊó∂Ê∑ªÂä†Âä®ÁîªÊïàÊûú */
.gantt-bar.progress-dragging .gantt-bar-progress {
  background: rgba(0, 0, 0, 0.4) !important;
  box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2);
}

.gantt-bar-text {
  position: absolute;
  top: 0;
  left: 8px;
  right: 8px;
  height: 100%;
  display: flex;
  align-items: center;
  color: white;
  font-size: 10px;
  font-weight: 500;
  overflow: hidden;
  pointer-events: none; /* ÈÅøÂÖçÂπ≤Êâ∞ÊãñÊãΩ */
}

.task-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
}

/* ÁôæÂàÜÊØîÊòæÁ§∫ - Áõ¥Êé•ÊîæÂú®ËøõÂ∫¶Êù°‰∏ä */
.gantt-bar-progress-text {
  position: absolute;
  top: 50%;
  right: 4px; /* ‰ªéËøõÂ∫¶Êù°Âè≥Á´ØÂêëÂ∑¶ÂÅèÁßª4px */
  transform: translateY(-50%);
  font-weight: 600;
  font-size: 9px;
  color: white;
  white-space: nowrap;
  pointer-events: none;
  z-index: 24;
  opacity: 1;
  transition: all 0.15s ease;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); /* Â¢ûÂä†ÊñáÂ≠óÈò¥ÂΩ±ÊèêÂçáÂèØËØªÊÄß */
}

.resize-handle {
  position: absolute;
  width: 6px;
  height: 24px;
  cursor: col-resize;
  background: #4a90e2;
  opacity: 0;
  transition: opacity 0.2s ease, background-color 0.2s ease;
  z-index: 15;
  border-radius: 2px;
}

.resize-handle.left {
  left: -8px; /* ÊâÅÂπ≥ÂåñËÆæËÆ°Ôºå‰ΩçÁΩÆÊõ¥Èù†ËøëËäÇÁÇπ */
  top: 50%;
  transform: translateY(-50%);
}

.resize-handle.right {
  right: -8px; /* ÊâÅÂπ≥ÂåñËÆæËÆ°Ôºå‰ΩçÁΩÆÊõ¥Èù†ËøëËäÇÁÇπ */
  top: 50%;
  transform: translateY(-50%);
}

.gantt-bar:hover .resize-handle {
  opacity: 1;
}



.resize-handle:hover {
  background: #357abd;
  transform: translateY(-50%) scale(1.1);
}

.task-delete-btn {
  position: absolute;
  top: -10px;
  right: -10px;
  width: 18px;
  height: 18px;
  line-height: 18px;
  background: #e74c3c;
  color: white;
  border-radius: 50%;
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 13px;
  font-weight: bold;
  line-height: 1;
  z-index: 20;
  transition: all 0.2s ease;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.task-delete-btn:hover {
  background: #c0392b;
  transform: scale(1.1);
}

.gantt-bar:hover .task-delete-btn {
  display: flex;
}

.milestone {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 3;
  transition: all 0.3s ease;
}

.milestone-diamond {
  width: 16px;
  height: 16px;
  background: #f39c12;
  transform: rotate(45deg);
  border: 2px solid white;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.milestone-icon {
  position: absolute;
  font-size: 8px;
  transform: rotate(-45deg);
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

/* MilestoneÁä∂ÊÄÅÊ†∑Âºè */
.milestone.milestone-completed .milestone-diamond {
  background: #52c41a;
  border-color: #b7eb8f;
}

.milestone.milestone-overdue .milestone-diamond {
  background: #ff4d4f;
  border-color: #ff7875;
  animation: milestone-warning 2s infinite ease-in-out;
}

.milestone.milestone-editable:hover {
  transform: translateY(-50%) scale(1.2);
  cursor: pointer;
}

.milestone.milestone-editable:hover .milestone-diamond {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* MilestoneËøûÊé•ÁÇπÊ†∑Âºè */
.milestone-connection-points {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 4;
}

.milestone-connection-point {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #3498db;
  border: 2px solid white;
  border-radius: 50%;
  cursor: crosshair;
  opacity: 0;
  transition: all 0.2s ease;
  pointer-events: none;
}

.milestone-connection-left {
  top: 50%;
  left: -16px; /* ‰∏éÊôÆÈÄöËøûÊé•ÁÇπ‰øùÊåÅ‰∏ÄËá¥ */
  transform: translateY(-50%);
}

.milestone-connection-right {
  top: 50%;
  right: -16px; /* ‰∏éÊôÆÈÄöËøûÊé•ÁÇπ‰øùÊåÅ‰∏ÄËá¥ */
  transform: translateY(-50%);
}

.milestone:hover .milestone-connection-point {
  opacity: 1;
  pointer-events: auto;
}

.milestone-connection-point:hover {
  background: #1890ff;
  transform: translateY(-50%) scale(1.3);
  box-shadow: 0 2px 6px rgba(24, 144, 255, 0.4);
}

.connection-dot {
  width: 4px;
  height: 4px;
  background: white;
  border-radius: 50%;
  margin: 2px;
}

@keyframes milestone-warning {
  0%, 100% {
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }
  50% {
    box-shadow: 0 4px 16px rgba(255, 77, 79, 0.6);
  }
}

.color-picker {
  position: absolute;
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  padding: 16px;
  z-index: 1000;
  min-width: 220px;
  user-select: none;
}

.color-picker-header {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #333;
  text-align: center;
}

.color-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  margin-bottom: 8px;
}

.color-option {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.15s ease;
  position: relative;
}

.color-option:hover {
  border-color: #333;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.color-option:active {
  transform: scale(0.95);
}

.close-picker {
  position: absolute;
  top: 4px;
  right: 8px;
  background: none;
  border: none;
  font-size: 18px;
  cursor: pointer;
  color: #666;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.close-picker:hover {
  color: #333;
}

.connection-hint {
  position: absolute;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  z-index: 1000;
  pointer-events: none;
  white-space: nowrap;
}

/* Element UI Ëá™ÂÆö‰πâÊ†∑Âºè‰ºòÂåñ */
.gantt-dialog .el-dialog {
  transform: none !important;
  zoom: 1 !important;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
}

.gantt-dialog .el-dialog__header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 20px 25px;
  border-bottom: none;
}

.gantt-dialog .el-dialog__title {
  color: white;
  font-size: 18px;
  font-weight: 600;
}

.gantt-dialog .el-dialog__close {
  color: white;
  font-size: 20px;
  opacity: 0.8;
  transition: opacity 0.2s ease;
}

.gantt-dialog .el-dialog__close:hover {
  opacity: 1;
}

.gantt-dialog .el-dialog__body {
  padding: 25px;
  background: #fafbfc;
}

.gantt-dialog .el-form {
  background: white;
  padding: 25px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.gantt-dialog .el-form-item {
  margin-bottom: 22px;
}

.gantt-dialog .el-slider {
  margin-right: 15px;
}

.gantt-dialog .el-slider__runway {
  background: #e2e8f0;
  border-radius: 6px;
  height: 8px;
}

.gantt-dialog .el-slider__bar {
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  border-radius: 6px;
}

.gantt-dialog .el-slider__button {
  border: 3px solid white;
  background: #667eea;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  width: 20px;
  height: 20px;
}

.gantt-dialog .el-slider__input {
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 6px;
}

.gantt-dialog .el-color-picker {
  vertical-align: top;
}

.gantt-dialog .el-color-picker__trigger {
  border: 2px solid #e2e8f0;
  border-radius: 8px;
  width: 50px;
  height: 28px; /* ‰øÆÂ§çÈ¢úËâ≤ÈÄâÊã©Âô®È´òÂ∫¶ */
  transition: all 0.2s ease;
}

.gantt-dialog .el-color-picker__trigger:hover {
  border-color: #667eea;
}

.gantt-dialog .el-select .el-input__inner {
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 8px;
}

.gantt-dialog .el-checkbox__inner {
  border-color: #e2e8f0;
  border-radius: 4px;
  background: #f8fafc;
}

.gantt-dialog .el-checkbox__input.is-checked .el-checkbox__inner {
  background: #667eea;
  border-color: #667eea;
}

.gantt-dialog .el-checkbox__label {
  color: #2d3748;
  font-weight: 500;
}

.gantt-dialog .el-dialog__footer {
  padding: 20px 25px;
  background: #f8fafc;
  border-top: 1px solid #e2e8f0;
}

.gantt-dialog .el-button {
  border-radius: 8px;
  padding: 12px 24px;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.2s ease;
}

.gantt-dialog .el-button--primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.gantt-dialog .el-button--primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
}

.gantt-dialog .el-button--danger {
  background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
  border: none;
  box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
}

.gantt-dialog .el-button--danger:hover {
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(231, 76, 60, 0.4);
}

.gantt-dialog .el-button--default {
  background: white;
  border: 2px solid #e2e8f0;
  color: #4a5568;
}

.gantt-dialog .el-button--default:hover {
  border-color: #667eea;
  color: #667eea;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(-20px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Tooltip Ê†∑Âºè */
.gantt-tooltip {
  position: absolute;
  background: white;
  border: 1px solid #e1e8ed;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  padding: 16px;
  z-index: 1000;
  font-size: 12px;
  line-height: 1.4;
  min-width: 280px;
  max-width: 480px;
  user-select: none;
  pointer-events: auto;
}

.tooltip-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  border-bottom: 1px solid #f0f0f0;
  padding-bottom: 8px;
}

.tooltip-title {
  font-weight: 600;
  font-size: 14px;
  color: #333;
  max-width: 180px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tooltip-progress {
  padding: 2px 8px;
  border-radius: 12px;
  color: white;
  font-size: 11px;
  font-weight: 600;
  min-width: 35px;
  text-align: center;
}

.tooltip-content {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.tooltip-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.tooltip-label {
  font-weight: 500;
  color: #666;
  min-width: 80px;
}

.tooltip-value {
  font-weight: 400;
  color: #333;
  text-align: right;
}

.tooltip-value.plan-date-tooltip {
  color: #1890ff;
  font-style: italic;
}

.tooltip-value.status {
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
}

.tooltip-value.status.status-completed {
  background: #f6ffed;
  color: #52c41a;
  border: 1px solid #b7eb8f;
}

.tooltip-value.status.status-progress {
  background: #fff7e6;
  color: #fa8c16;
  border: 1px solid #ffd591;
}

.tooltip-value.status.status-not-started {
  background: #f5f5f5;
  color: #8c8c8c;
  border: 1px solid #d9d9d9;
}

.tooltip-value.milestone {
  color: #f39c12;
  font-weight: 600;
}



.gantt-bar.highlighted {
  box-shadow: 0 0 10px rgba(255, 193, 7, 0.8);
  transform: scale(1.02);
  z-index: 30;
}

.gantt-bar.connection-highlight {
  box-shadow: 0 0 8px rgba(24, 144, 255, 0.6);
  border: 2px solid #1890ff;
  z-index: 25;
  transform: scale(1.01);
  transition: all 0.3s ease;
}

.gantt-bar.connection-source {
  box-shadow: 0 0 12px rgba(255, 77, 79, 0.8);
  border: 3px solid #ff4d4f;
  z-index: 35;
  transform: scale(1.05);
  transition: all 0.3s ease;
}

.plan-date-tooltip {
  color: #1890ff;
  font-style: italic;
}

.plan-date-tooltip::before {
  content: 'üìÖ ';
  font-size: 10px;
}

/* Ë°ÄÁºòÂÖ≥Á≥ªÈ´ò‰∫ÆÊ†∑Âºè */
.gantt-bar.lineage-highlighted {
  box-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
  border: 2px solid #3498db;
}

.gantt-bar.lineage-dimmed {
  opacity: 0.3;
  filter: grayscale(50%);
}

.gantt-bar.lineage-source {
  box-shadow: 0 0 12px rgba(231, 76, 60, 0.8);
  border: none;
  animation: pulse-source 2s infinite;
}

.gantt-bar.lineage-upstream {
  box-shadow: 0 0 8px rgba(46, 204, 113, 0.6);
  border: 2px solid #2ecc71;
}

.gantt-bar.lineage-downstream {
  box-shadow: 0 0 8px rgba(155, 89, 182, 0.6);
  border: 2px solid #9b59b6;
}

@keyframes pulse-source {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 12px rgba(231, 76, 60, 0.8);
  }
  50% {
    transform: scale(1.02);
    box-shadow: 0 0 16px rgba(231, 76, 60, 1);
  }
}

/* ÂÖ≥ÈîÆË∑ØÂæÑÊ†∑Âºè */
.gantt-bar.critical-path {
  box-shadow: 0 0 0 2px rgba(255, 71, 87, 0.7) !important;
  z-index: 15;
  position: relative;
}

.gantt-bar.critical-path::before {
  content: '';
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border: 2px dashed rgba(255, 71, 87, 0.5);
  border-radius: 4px;
  pointer-events: none;
  animation: pulse-border 2s infinite;
}

@keyframes pulse-border {
  0% { border-color: rgba(255, 71, 87, 0.5); }
  50% { border-color: rgba(255, 71, 87, 0.8); }
  100% { border-color: rgba(255, 71, 87, 0.5); }
}

/* ‰æùËµñËøûÁ∫øÈ´ò‰∫ÆÊ†∑Âºè */
.dependency-line.highlighted {
  animation: line-pulse 2s infinite;
}

.dependency-line.dimmed {
  opacity: 0.2;
  stroke-dasharray: 5,5;
}

@keyframes line-pulse {
  0%, 100% {
    stroke-width: 3;
  }
  50% {
    stroke-width: 4;
  }
}

.gantt-connection-points {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 11;
}

.gantt-connection-point {
  position: absolute;
  width: 10px; /* ÊâÅÂπ≥ÂåñËÆæËÆ°ÔºåÂ∞∫ÂØ∏ÈÄÇ‰∏≠ */
  height: 10px; /* ÊâÅÂπ≥ÂåñËÆæËÆ°ÔºåÂ∞∫ÂØ∏ÈÄÇ‰∏≠ */
  border-radius: 50%;
  background: #ffffff;
  border: 2px solid #3498db;
  opacity: 0;
  transition: opacity 0.2s ease, transform 0.2s ease;
  z-index: 12;
  pointer-events: auto;
  cursor: crosshair;
  top: 50%;
  transform: translateY(-50%);
}

.gantt-connection-point.gantt-connection-point-left {
  left: -16px; /* Êõ¥Ë¥¥ËøëËäÇÁÇπÔºåÊèêÈ´òÊòìÁî®ÊÄß */
}

.gantt-connection-point.gantt-connection-point-right {
  right: -16px; /* Êõ¥Ë¥¥ËøëËäÇÁÇπÔºåÊèêÈ´òÊòìÁî®ÊÄß */
}

.gantt-connection-point.active {
  opacity: 1;
}

.gantt-connection-point.connecting {
  background: #ff4757;
  border-color: #ffffff;
  z-index: 7;
}

.gantt-connection-dot {
  display: none; /* ‰∏çÂÜçÈúÄË¶ÅÂÜÖÈÉ®dot */
}

.gantt-connection-point:hover {
  background: #3498db;
  border-color: #ffffff;
  transform: translateY(-50%) scale(1.2);
}

.gantt-connection-point.active {
  opacity: 1;
}

.gantt-connection-preview {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 4;
}

.gantt-connection-preview line {
  stroke: #1890ff;
  stroke-width: 2;
  stroke-dasharray: 4,4;
  opacity: 0.8;
}

.gantt-connection-preview circle {
  fill: #1890ff;
  opacity: 0.8;
}

/* dhtmlxÈ£éÊ†ºÁöÑ‰æùËµñËøûÊé•Á∫øÊ†∑Âºè */
.gantt-dependency-lines {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 2;
}

.gantt-dependency-group {
  pointer-events: auto;
}

.gantt-link-container {
  cursor: pointer;
}

.gantt-link-hit-area {
  cursor: pointer;
  opacity: 0;
}

.gantt-link-hit-area:hover {
  opacity: 0.1;
  stroke: #1890ff;
}

.gantt-dependency-line {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  stroke-linecap: round;
  stroke-linejoin: round;
  opacity: 0.9;
}

.gantt-dependency-line.selected {
  filter: url(#connectionShadow) drop-shadow(0 0 3px rgba(255, 71, 87, 0.6));
  opacity: 1;
}

.gantt-dependency-line.highlighted {
  filter: url(#connectionShadow) drop-shadow(0 0 3px rgba(24, 144, 255, 0.6));
  animation: link-highlight 2s infinite;
  opacity: 1;
}

.gantt-dependency-line.dimmed {
  opacity: 0.25;
  stroke-dasharray: 3,3;
  filter: none;
}

.gantt-dependency-line.gray-mode {
  opacity: 0.7;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes link-highlight {
  0%, 100% {
    stroke-opacity: 1;
  }
  50% {
    stroke-opacity: 0.6;
  }
}

/* ËøûÊé•Á∫øÊ†áÁ≠æÊ†∑Âºè */
.gantt-link-label-group {
  pointer-events: auto;
  cursor: pointer;
}

.gantt-link-label-bg {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.gantt-link-label-bg:hover {
  fill: rgba(248, 249, 250, 0.98);
  stroke: rgba(24, 144, 255, 0.8);
  stroke-width: 0.8;
}

.gantt-link-label-text {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  user-select: none;
}

.gantt-link-label-text.selected {
  font-weight: 600;
}

.gantt-link-label-text:hover {
  fill: #1890ff;
}

/* ÊéßÂà∂ÊåâÈíÆÊ†∑Âºè */
.gantt-link-controls {
  pointer-events: auto;
}

.gantt-link-color-btn,
.gantt-link-delete-btn {
  cursor: pointer;
  transition: all 0.2s ease;
}

.gantt-link-color-btn:hover .gantt-color-button,
.gantt-link-delete-btn:hover .gantt-delete-button {
  transform: scale(1.1);
  filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.2));
}

.gantt-color-button,
.gantt-delete-button {
  transition: all 0.2s ease;
}

/* ËøûÊé•ÁÇπÂú®‰ªªÂä°Êù°ÊÇ¨ÂÅúÊó∂ÊòæÁ§∫ */
.gantt-bar-container:hover .gantt-connection-point {
  opacity: 1;
  pointer-events: auto;
}

/* ËøûÊé•Á∫øÁºñËæëÂØπËØùÊ°ÜÊ†∑Âºè - Element UI Dialog */
/* Á°Æ‰øùÂØπËØùÊ°ÜÂíåÈÅÆÁΩ©Â±ÇÁöÑÊ≠£Á°ÆÂ±ÇÁ∫ß */
.gantt-link-edit-dialog {

}

.gantt-link-edit-dialog .el-dialog {
  margin-top: 5vh !important;

}


.gantt-link-edit-content {
  padding: 0;
}

.gantt-link-info {
  margin-bottom: 20px;
}

.gantt-color-selector {
  display: flex;
  align-items: center;
  gap: 15px;
}

.gantt-color-preview {
  width: 28px; /* ‰øÆÂ§çÈ¢úËâ≤È¢ÑËßàÂ∞∫ÂØ∏ */
  height: 28px; /* ‰øÆÂ§çÈ¢úËâ≤È¢ÑËßàÂ∞∫ÂØ∏ */
  border-radius: 6px;
  border: 2px solid #e1e5e9;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

.color-text {
  font-size: 10px;
  color: white;
  text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
  font-weight: 600;
  text-transform: uppercase;
}

.gantt-color-options {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.gantt-color-option {
  width: 32px;
  height: 32px;
  border-radius: 6px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: all 0.2s ease;
}

.gantt-color-option:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.gantt-color-option.selected {
  border-color: #409eff;
  transform: scale(1.15);
  box-shadow: 0 0 0 2px rgba(64, 158, 255, 0.3);
}

/* ÂéüÊúâÊåâÈíÆÊ†∑ÂºèÂ∑≤ÁßªÈô§ÔºåÁé∞Âú®‰ΩøÁî® Element UI ÊåâÈíÆ */

/* ËøõÂ∫¶ÊãñÊãΩÊâãÊüÑÂÆπÂô® - ÈªòËÆ§ÈöêËóèÔºåhoverÊó∂ÊòæÁ§∫ */
.gantt-progress-handle-container {
  position: absolute;
  top: 100%;
  right: -10px; /* Ëøõ‰∏ÄÊ≠•Áº©Â∞è‰ΩçÁΩÆÂÅèÁßª */
  width: 20px; /* Ëøõ‰∏ÄÊ≠•ÂáèÂ∞èÁÇπÂáªÂå∫Âüü */
  height: 16px; /* Ëøõ‰∏ÄÊ≠•ÂáèÂ∞èÁÇπÂáªÂå∫ÂüüÈ´òÂ∫¶ */
  cursor: col-resize;
  z-index: 25;
  opacity: 0; /* ÈªòËÆ§ÈöêËóè */
  transition: opacity 0.3s ease, transform 0.15s ease, background 0.15s ease;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  border-radius: 2px;
  will-change: transform;
  background: transparent; /* ÁßªÈô§ËÉåÊôØ */
  /* Êõ¥Á≤æÁ°ÆÁöÑÁÇπÂáªÂå∫ÂüüÔºåËß£ÂÜ≥ÊãñÊãΩÊó∂ÊòæÁ§∫ËøáÂ§ßÁöÑÈóÆÈ¢ò */
}

/* Â∫ïÈÉ®‰∏âËßíÂΩ¢ËøõÂ∫¶ÊãñÊãΩÊâãÊüÑ - Êõ¥Â∞èÊõ¥Á≤æËá¥ */
.gantt-progress-handle {
  width: 0;
  height: 0;
  border-left: 4px solid transparent;
  border-right: 4px solid transparent;
  border-bottom: 6px solid #4a90e2;
  transition: transform 0.1s ease, border-bottom-color 0.1s ease;
  will-change: transform, border-bottom-color;
  /* Ëøõ‰∏ÄÊ≠•Áº©Â∞è‰∏âËßíÂΩ¢Â∞∫ÂØ∏ÔºåËß£ÂÜ≥ÊãñÊãΩÊó∂ÊòæÁ§∫ËøáÂ§ßÁöÑÈóÆÈ¢ò */
}

.gantt-bar:hover .gantt-progress-handle-container {
  opacity: 1; /* ÊÇ¨ÂÅúÁîòÁâπÊù°Êó∂ÊòæÁ§∫ÊâãÊüÑ */
}

/* ÁôæÂàÜÊØîÂßãÁªàÂèØËßÅÔºåÁßªÈô§ÊÇ¨ÂÅúÈÄªËæë */

.gantt-progress-handle-container:hover {
  opacity: 1;
  transform: translateY(-1px);
  background: transparent; /* ÁßªÈô§ËÉåÊôØ */
}

.gantt-progress-handle-container:hover .gantt-progress-handle {
  border-bottom-color: #357abd;
  /* ÊÇ¨ÂÅúÊó∂Âè™ÊîπÂèòÈ¢úËâ≤Ôºå‰∏çÊîæÂ§ß */
}

/* ÁôæÂàÜÊØîÂßãÁªàÂèØËßÅÔºåÁßªÈô§ÁâπÊÆäÊÇ¨ÂÅúÊïàÊûú */

.gantt-progress-handle-container:active {
  transform: translateY(0px);
  background: transparent;
}

.gantt-progress-handle-container:active .gantt-progress-handle {
  border-bottom-color: #2c5f8a;
}

/* ===== ‰ªªÂä°ÂêçÁß∞Ê†áÁ≠æÊ†∑Âºè - JIRAÈ£éÊ†º ===== */
.gantt-task-name-label {
  position: absolute;
  font-size: 12px;
  color: #5e6c84;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  font-weight: 400;
  white-space: nowrap;
  pointer-events: none;
  z-index: 4;
  user-select: none;
  /* Á≤æÁ°ÆÂûÇÁõ¥Â±Ö‰∏≠ÂØπÈΩê */
  line-height: 12px;
  height: 12px;
  /* Ë∂ÖÈïøÂêçÁß∞Â§ÑÁêÜ */
  max-width: 180px;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* ÊöóËâ≤‰∏ªÈ¢ò‰∏ãÁöÑ‰ªªÂä°ÂêçÁß∞Ê†áÁ≠æ */
.dark-theme .gantt-task-name-label {
  color: #9fadbc;
}

/* Element UI ÂØπËØùÊ°ÜÂ∫ïÈÉ®ÊåâÈíÆÂå∫ÂüüÊ†∑Âºè */
.dialog-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Áà∂ËäÇÁÇπÁîòÁâπÊù°Ê†∑Âºè - ÁªøËâ≤‰º†ÁªüÊ†∑Âºè */
.gantt-bar.parent-task {
  background: linear-gradient(to bottom, #4CAF50, #388E3C);
  pointer-events: auto;
  height: 14px;
  border-radius: 0;
  padding: 0;
  overflow: visible;
  display: block;
  position: relative;
  /* ÁªøËâ≤‰º†ÁªüÁîòÁâπÂõæÁà∂ËäÇÁÇπÊ†∑Âºè */
}

.gantt-bar.parent-task::before {
  content: "";
    position: absolute;
    left: 3px;
    transform: translateX(-50%) rotate(135deg);
    bottom: -5px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid #3d9641;

}

.gantt-bar.parent-task::after {
   content: "";
    position: absolute;
    right: -15px;
    transform: translateX(-50%) rotate(90deg);
    bottom: -5px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid #3d9641;
  /* Âè≥Á´ØÁªøËâ≤‰∏âËßíÂΩ¢ */
}

.gantt-bar.parent-task .gantt-bar-main {
  height: 100%;
  background: linear-gradient(to bottom, #4CAF50, #388E3C);
  border-radius: 0;
  margin: 0;
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
  /* ÁªøËâ≤‰∏ª‰ΩìÂå∫Âüü */
}

.gantt-bar.parent-task .gantt-bar-text {
  position: absolute;
  top: 50%;
  left: 8px;
  right: 8px;
  transform: translateY(-50%);
  text-align: left;
  font-size: 10px;
  font-weight: 600;
  color: #ffffff;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
  /* ÁôΩËâ≤ÊñáÂ≠óÔºåÂ±Ö‰∏≠ÊòæÁ§∫ */
}

.gantt-bar.parent-task .gantt-bar-progress-text {
  position: absolute;
  top: 50%;
  right: 8px;
  transform: translateY(-50%);
  font-size: 10px;
  font-weight: 600;
  color: #ffffff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
  /* ËøõÂ∫¶ÊñáÂ≠ó */
}

/* Áà∂ËäÇÁÇπËøõÂ∫¶Êù°Ê†∑Âºè */
.gantt-bar.parent-task .gantt-bar-progress {
  background: linear-gradient(135deg, #66BB6A, #43A047);
  border-radius: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3);
  height: 100%;
  position: relative;
  overflow: hidden;
}

.gantt-bar.parent-task .gantt-bar-progress::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 50%;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0.2), transparent);
  border-radius: 0;
}



/* Áà∂ËäÇÁÇπÊãñÊãΩÊó∂ÁöÑÁâπÊÆäÊ†∑Âºè */
.gantt-bar.parent-dragging {
  z-index: 150;
}

.gantt-bar.parent-dragging::before,
.gantt-bar.parent-dragging::after {
  background: linear-gradient(135deg, #f39c12, #e67e22);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 8px rgba(243, 156, 18, 0.4);
  animation: parent-drag-pulse 1s infinite;
}

.gantt-bar.parent-dragging .gantt-bar-main {
  background: linear-gradient(to bottom, #e74c3c, #c0392b);
  box-shadow: inset 0 -1px 2px rgba(0, 0, 0, 0.4);
}

.gantt-bar.parent-dragging .gantt-bar-text {
  color: #ffffff;
  font-weight: 700;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);
}

@keyframes parent-drag-pulse {
  0%, 100% {
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.3), 0 2px 8px rgba(243, 156, 18, 0.4);
    opacity: 1;
  }
  50% {
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5), 0 4px 12px rgba(243, 156, 18, 0.6);
    opacity: 0.9;
  }
}

/* ÂÖ≥ÈîÆË∑ØÂæÑ‰ªªÂä°Ê†∑Âºè */
.gantt-bar.critical-path {
  position: relative;
  background: linear-gradient(to right, #ff6b6b, #f53b57);
  border: 2px solid #ff4757 !important;
  box-shadow: 0 2px 8px rgba(255, 71, 87, 0.3) !important;
  animation: critical-path-glow 2s infinite ease-in-out;
  z-index: 10;
}

.gantt-bar.critical-path::before {
  content: '‚ö†';
  position: absolute;
  top: -2px;
  left: -2px;
  background: #ff4757;
  color: white;
  font-size: 10px;
  line-height: 1;
  padding: 2px 4px;
  border-radius: 3px;
  z-index: 10;
  font-weight: bold;
}

.gantt-bar.critical-path .gantt-bar-text {
  color: #fff !important;
  font-weight: bold !important;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

.gantt-bar.critical-path:hover {
  background: linear-gradient(to right, #ff5252, #e84393);
  box-shadow: 0 4px 12px rgba(255, 82, 82, 0.4) !important;
}

.gantt-bar.critical-path .gantt-bar-progress {
  background: rgba(255, 255, 255, 0.25);
}

@keyframes critical-path-glow {
  0%, 100% {
    box-shadow: 0 2px 8px rgba(255, 71, 87, 0.3);
  }
  50% {
    box-shadow: 0 4px 16px rgba(255, 71, 87, 0.6);
  }
}

.gantt-bar.progress-dragging {
  box-shadow: 0 0 8px #4a90e2;
  border-color: #4a90e2;
  opacity: 0.95;
}

.gantt-bar.progress-dragging .gantt-progress-handle {
  border-bottom-color: #ff9800;
  filter: drop-shadow(0 2px 8px #ff9800);
  border-bottom-width: 16px;
  border-left-width: 12px;
  border-right-width: 12px;
  transition: all 0.1s;
}



/* ÂÖ≥ÈîÆË∑ØÂæÑËøûÊé•Á∫øÊ†∑Âºè */
.dependency-line.critical-path {
  stroke: #ff5252;
  stroke-width: 2px;
  filter: drop-shadow(0 1px 3px rgba(255, 82, 82, 0.3));
}

.dependency-arrow.critical-path {
  fill: #ff5252;
}

/* Âè≥ÈîÆËèúÂçïÊ†∑Âºè */
.gantt-context-menu {
  position: fixed;
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  padding: 5px 0;
  z-index: 9999;
  min-width: 150px;
  max-width: 250px;
}

.context-menu-header {
  padding: 8px 16px;
  font-weight: bold;
  color: #606266;
  font-size: 14px;
  border-bottom: 1px solid #e0e0e0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 5px;
}

.context-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 13px;
  color: #606266;
  display: flex;
  align-items: center;
}

.context-menu-item i {
  margin-right: 8px;
  font-size: 16px;
}

.context-menu-item:hover {
  background-color: #f5f7fa;
  color: #409EFF;
}

/* ‰ªªÂä°Á±ªÂûãÂõæÊ†áÊ†∑Âºè */
.task-type-icon {
  margin-right: 4px;
  font-size: 12px;
  vertical-align: middle;
  display: inline-block;
}

/* ‰ªªÂä°Á±ªÂûãÂõæÊ†áÈ¢úËâ≤ */
.task-type-icon.deliverable {
  color: #1890ff;
}

.task-type-icon.task {
  color: #52c41a;
}

.task-type-icon.milestone {
  color: #faad14;
}

/* GanttBars ÂºπÊ°Ü‰∏ìÁî®Ê†∑Âºè - Á°Æ‰øùÊúÄÈ´òÂ±ÇÁ∫ß */
.gantt-bars-dialog .el-dialog__wrapper {
  z-index: 10002 !important;
}

.gantt-bars-dialog .el-dialog {
  z-index: 10003 !important;
}

/* Á°Æ‰øùÂºπÊ°ÜÂÜÖÁöÑ‰∏ãÊãâÁªÑ‰ª∂Âú®ÊúÄÈ°∂Â±Ç */
.gantt-bars-dialog .el-select-dropdown {
  z-index: 10004 !important;
}

.gantt-bars-dialog .el-picker-panel {
  z-index: 10004 !important;
}

.gantt-bars-dialog .el-color-dropdown {
  z-index: 10004 !important;
}

.gantt-bars-dialog .el-color-picker__panel {
  z-index: 10004 !important;
}

/* Á°Æ‰øùÊâÄÊúâElement UIÁöÑpopperÁªÑ‰ª∂Âú®ÂºπÊ°Ü‰∏äÊñπ */
.gantt-bars-dialog .el-popper {
  z-index: 10004 !important;
}

/* Milestone Ê†áËÆ∞Ê†∑Âºè */
.gantt-milestone-marker {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  cursor: pointer;
  z-index: 10;
  transition: transform 0.15s ease;
  will-change: transform;
  transform: translateZ(0); /* ÂêØÁî®Á°¨‰ª∂Âä†ÈÄü */
}

.gantt-milestone-marker .milestone-diamond {
  width: 20px;
  height: 20px;
  background: linear-gradient(135deg, #f39c12, #e67e22);
  border: 2px solid #d68910;
  border-radius: 3px;
  transform: rotate(45deg);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
  position: relative;
}

.gantt-milestone-marker .milestone-icon {
  transform: rotate(-45deg);
  font-size: 12px;
  color: #ffffff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  line-height: 1;
}

.gantt-milestone-marker .milestone-title {
  position: absolute;
  top: -30px;
  left: 50%;
  transform: translateX(-50%);
  white-space: nowrap;
  font-size: 11px;
  font-weight: 600;
  color: #333333;
  background: rgba(255, 255, 255, 0.9);
  padding: 2px 6px;
  border-radius: 3px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  z-index: 12;
  pointer-events: none;
}

/* Milestone ÊÇ¨ÂÅúÊïàÊûú */
.gantt-milestone-marker:hover .milestone-diamond {
  background: linear-gradient(135deg, #f4d03f, #f39c12);
  border-color: #e67e22;
  transform: rotate(45deg) scale(1.1);
  box-shadow: 0 4px 12px rgba(243, 156, 18, 0.4);
}

/* Milestone ÈÄâ‰∏≠Áä∂ÊÄÅ */
.gantt-milestone-marker.selected .milestone-diamond {
  background: linear-gradient(135deg, #3498db, #2980b9);
  border-color: #1f5f8b;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.5);
}

/* Milestone ÊãñÊãΩÁä∂ÊÄÅ - ‰ºòÂåñÊÄßËÉΩ */
.gantt-milestone-marker.dragging {
  transform: translateZ(0) scale(1.1);
  z-index: 100;
  will-change: transform;
  transition: none; /* ÊãñÊãΩÊó∂Á¶ÅÁî®ËøáÊ∏° */
  backface-visibility: hidden; /* ÈÅøÂÖçÊãñÊãΩÈó™ÁÉÅ */
}

.gantt-milestone-marker.dragging .milestone-diamond {
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  border-color: #a93226;
  box-shadow: 0 4px 12px rgba(231, 76, 60, 0.5);
}

/* Milestone ËøûÊé•ÁÇπÊ†∑Âºè */
.gantt-milestone-marker .milestone-connection-points {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 40px;
  height: 24px;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 11;
}

.gantt-milestone-marker .milestone-connection-point {
  position: absolute;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid #3498db;
  opacity: 0;
  transition: all 0.2s ease;
  z-index: 12;
  pointer-events: auto;
  cursor: crosshair;
  top: 50%;
  transform: translateY(-50%);
}

.gantt-milestone-marker .milestone-connection-left {
  left: -16px; /* ‰∏éÂÖ∂‰ªñËøûÊé•ÁÇπ‰øùÊåÅ‰∏ÄËá¥ */
}

.gantt-milestone-marker .milestone-connection-right {
  right: -16px; /* ‰∏éÂÖ∂‰ªñËøûÊé•ÁÇπ‰øùÊåÅ‰∏ÄËá¥ */
}

.gantt-milestone-marker:hover .milestone-connection-point,
.gantt-milestone-marker .milestone-connection-point.active {
  opacity: 1;
}

.gantt-milestone-marker .milestone-connection-point:hover {
  background: #3498db;
  border-color: #fff;
  transform: translateY(-50%) scale(1.2);
}

.gantt-milestone-marker .milestone-connection-point.connecting {
  background: #ff4757;
  border-color: #fff;
  box-shadow: 0 0 8px rgba(255, 71, 87, 0.5);
}

.gantt-milestone-marker .connection-dot {
  display: none; /* ‰∏çÈúÄË¶ÅÂÜÖÈÉ®ÁÇπ */
}

/* ‰æùËµñÁ±ªÂûãÈÄâÊã©Âô®Ê†∑Âºè */
.gantt-dependency-type-selector {
  width: 100%;
}

.gantt-dependency-type-option {
  padding: 8px 12px !important;
  height: auto !important;
  line-height: 1.4 !important;
}

.dependency-type-icon {
  font-size: 16px;
  margin-right: 8px;
  display: inline-block;
  width: 20px;
  text-align: center;
}

.dependency-type-label {
  font-weight: 500;
  color: #303133;
}

.dependency-type-description {
  font-size: 12px;
  color: #909399;
  margin-top: 2px;
  line-height: 1.3;
}

/* LagËæìÂÖ•Ê°ÜÊ†∑Âºè */
.gantt-lag-input {
  width: 100%;
}

.lag-help-text {
  font-size: 12px;
  color: #909399;
  margin-top: 8px;
  line-height: 1.4;
}

.lag-explanation {
  margin-bottom: 8px;
  padding: 8px;
  background: #f8f9fa;
  border-radius: 4px;
}

.lag-explanation strong {
  color: #303133;
}

.lag-explanation ul {
  margin: 6px 0 0 0;
  padding-left: 18px;
}

.lag-explanation li {
  margin: 2px 0;
}

.lag-current-info {
  padding: 6px 8px;
  background: #e7f5ff;
  border-radius: 4px;
  border-left: 3px solid #409eff;
}

.lag-effect {
  color: #67c23a;
  font-weight: 500;
}

/* ËøûÁ∫øÁºñËæëÂºπÊ°ÜÊ†∑ÂºèÂ¢ûÂº∫ */
.gantt-link-edit-dialog .el-dialog__body {
  padding: 20px;
}

.gantt-link-edit-dialog .el-form-item {
  margin-bottom: 20px;
}

.gantt-link-edit-dialog .el-form-item__label {
  font-weight: 500;
  color: #303133;
}

/* ËøûÁ∫ø‰ø°ÊÅØÊòæÁ§∫Âå∫Âüü */
.gantt-link-info {
  background: #f5f7fa;
  padding: 12px 16px;
  border-radius: 4px;
  margin-bottom: 20px;
  border-left: 4px solid #409eff;
}

.gantt-link-info p {
  margin: 4px 0;
  font-size: 14px;
  color: #606266;
}

.gantt-link-info strong {
  color: #303133;
  font-weight: 500;
}

/* ËøûÊé•ÁÇπËßÜËßâÂå∫ÂàÜÊ†∑Âºè */
.connection-dot-start,
.gantt-connection-dot-start {
  background: #52c41a !important; /* ÁªøËâ≤Ë°®Á§∫ÂºÄÂßãÁÇπ */
  position: relative;
}

.connection-dot-start::before,
.gantt-connection-dot-start::before {
  content: 'S';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  font-weight: bold;
  color: white;
  line-height: 1;
}

.connection-dot-end,
.gantt-connection-dot-end {
  background: #f5222d !important; /* Á∫¢Ëâ≤Ë°®Á§∫ÁªìÊùüÁÇπ */
  position: relative;
}

.connection-dot-end::before,
.gantt-connection-dot-end::before {
  content: 'E';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 8px;
  font-weight: bold;
  color: white;
  line-height: 1;
}

/* ËøûÊé•ÁÇπhoverÊïàÊûúÂ¢ûÂº∫ */
.gantt-connection-start:hover .gantt-connection-dot-start,
.milestone-connection-start:hover .connection-dot-start {
  background: #389e0d !important;
  transform: scale(1.3);
  box-shadow: 0 0 8px rgba(82, 196, 26, 0.6);
}

.gantt-connection-end:hover .gantt-connection-dot-end,
.milestone-connection-end:hover .connection-dot-end {
  background: #cf1322 !important;
  transform: scale(1.3);
  box-shadow: 0 0 8px rgba(245, 34, 45, 0.6);
}

/* SVGÁÆ≠Â§¥Ê†∑ÂºèÁ°Æ‰øùÂèØËßÅÊÄß */
.gantt-dependency-lines marker polygon {
  stroke: none;
  opacity: 1;
}

.gantt-dependency-line-visual {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Â¢ûÂº∫ÁÆ≠Â§¥ÁöÑÊòæÁ§∫ÊïàÊûú */
.gantt-dependency-lines marker {
  fill-opacity: 1;
  stroke-opacity: 1;
}

/* Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øËøûÊé•Á∫øÊ†∑Âºè */
.gantt-dependency-line.bezier {
  stroke-dasharray: none;
  stroke-linecap: round;
  stroke-linejoin: round;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.gantt-dependency-line.bezier:hover {
  stroke-width: 2.5;
  filter: drop-shadow(0 0 3px rgba(52, 152, 219, 0.5));
}

.gantt-dependency-line.bezier.selected {
  stroke-width: 3;
  filter: drop-shadow(0 0 4px rgba(255, 71, 87, 0.6));
}

.gantt-dependency-line.bezier.highlighted {
  stroke-width: 2.5;
  filter: drop-shadow(0 0 4px rgba(24, 144, 255, 0.6));
  animation: bezier-highlight 2s infinite;
}

@keyframes bezier-highlight {
  0%, 100% {
    stroke-opacity: 1;
    stroke-width: 2.5;
  }
  50% {
    stroke-opacity: 0.7;
    stroke-width: 3;
  }
}
</style>
